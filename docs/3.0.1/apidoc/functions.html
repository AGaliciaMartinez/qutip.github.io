
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Functions &mdash; QuTiP 3.0 Documentation</title>
    
    <link rel="stylesheet" href="../static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../static/bootswatch-3.1.0/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../static/site.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../static/favicon.ico"/>
    <link rel="top" title="QuTiP 3.0 Documentation" href="../index.html" />
    <link rel="up" title="API documentation" href="apidoc.html" />
    <link rel="next" title="Change Log" href="../changelog.html" />
    <link rel="prev" title="Classes" href="classes.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          QuTiP</a>
        <span class="navbar-text navbar-version pull-left"><b>3.0.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Docs <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../frontmatter.html#about-this-documentation">About This Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frontmatter.html#citing-this-project">Citing This Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frontmatter.html#funding">Funding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frontmatter.html#about-qutip">About QuTiP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../frontmatter.html#contributing-to-qutip">Contributing to QuTiP</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#general-requirements">General Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#platform-independent-installation">Platform-independent installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#get-the-source-code">Get the source code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#installing-from-source">Installing from source</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#installation-on-ubuntu-linux">Installation on Ubuntu Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#installation-on-mac-os-x-10-6">Installation on Mac OS X (10.6+)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#installation-on-windows">Installation on Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#optional-installation-options">Optional Installation Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#verifying-the-installation">Verifying the Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation.html#checking-version-information-using-the-about-function">Checking Version Information using the About Function</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../guide/guide.html">Users Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-overview.html">Guide Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-basics.html">Basic Operations on Quantum Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-states.html">Manipulating States and Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-tensor.html">Using Tensor Products and Partial Traces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-dynamics.html">Time Evolution and Quantum System Dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-steady.html">Solving for Steady-State Solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-eseries.html">An Overview of the Eseries Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-correlation.html">Two-time correlation functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-bloch.html">Plotting on the Bloch Sphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-visualization.html">Visualization of quantum states and processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-parfor.html">Running Problems in Parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-saving.html">Saving QuTiP Objects and Data Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-random.html">Generating Random Quantum States &amp; Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide/guide-settings.html">Modifying Internal QuTiP Settings</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="apidoc.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-3-0-1-aug-5-2014">Version 3.0.1 (Aug 5, 2014):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-3-0-0-july-17-2014">Version 3.0.0 (July 17, 2014):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-2-2-0-march-01-2013">Version 2.2.0 (March 01, 2013):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-2-1-0-october-05-2012">Version 2.1.0 (October 05, 2012):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-2-0-0-june-01-2012">Version 2.0.0 (June 01, 2012):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-1-1-4-may-28-2012">Version 1.1.4 (May 28, 2012):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-1-1-3-november-21-2011">Version 1.1.3 (November 21, 2011):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-1-1-2-october-27-2011">Version 1.1.2 (October 27, 2011)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-1-1-1-october-25-2011">Version 1.1.1 (October 25, 2011)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-1-1-0-october-04-2011">Version 1.1.0 (October 04, 2011)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changelog.html#version-1-0-0-july-29-2011">Version 1.0.0 (July 29, 2011)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../contributors.html#lead-developers">Lead Developers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contributors.html#contributors">Contributors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Functions</a><ul>
<li><a class="reference internal" href="#manipulation-and-creation-of-states-and-operators">Manipulation and Creation of States and Operators</a><ul>
<li><a class="reference internal" href="#module-qutip.states">Quantum States</a></li>
<li><a class="reference internal" href="#module-qutip.operators">Quantum Operators</a></li>
<li><a class="reference internal" href="#module-qutip.random_objects">Random Operators and States</a></li>
<li><a class="reference internal" href="#module-qutip.three_level_atom">Three-Level Atoms</a><ul>
<li><a class="reference internal" href="#references">References</a></li>
<li><a class="reference internal" href="#notes">Notes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-qutip.superoperator">Superoperators and Liouvillians</a></li>
<li><a class="reference internal" href="#module-qutip.superop_reps">Superoperator Representations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functions-acting-on-states-and-operators">Functions acting on states and operators</a><ul>
<li><a class="reference internal" href="#module-qutip.tensor">Tensor</a></li>
<li><a class="reference internal" href="#module-qutip.expect">Expectation Values</a></li>
<li><a class="reference internal" href="#module-qutip.partial_transpose">Partial Transpose</a></li>
<li><a class="reference internal" href="#module-qutip.entropy">Entropy Functions</a></li>
<li><a class="reference internal" href="#module-qutip.metrics">Density Matrix Metrics</a></li>
<li><a class="reference internal" href="#module-qutip.continuous_variables">Continous Variables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dynamics-and-time-evolution">Dynamics and Time-Evolution</a><ul>
<li><a class="reference internal" href="#module-qutip.sesolve">Schrödinger Equation</a></li>
<li><a class="reference internal" href="#module-qutip.mesolve">Master Equation</a></li>
<li><a class="reference internal" href="#module-qutip.mcsolve">Monte Carlo Evolution</a></li>
<li><a class="reference internal" href="#module-qutip.essolve">Exponential Series</a></li>
<li><a class="reference internal" href="#module-qutip.bloch_redfield">Bloch-Redfield Master Equation</a></li>
<li><a class="reference internal" href="#module-qutip.floquet">Floquet States and Floquet-Markov Master Equation</a></li>
<li><a class="reference internal" href="#module-qutip.stochastic">Stochastic Schrödinger Equation and Master Equation</a></li>
<li><a class="reference internal" href="#module-qutip.correlation">Correlation Functions</a></li>
<li><a class="reference internal" href="#module-qutip.steadystate">Steady-state Solvers</a></li>
<li><a class="reference internal" href="#module-qutip.propagator">Propagators</a></li>
<li><a class="reference internal" href="#module-qutip">Time-dependent problems</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization">Visualization</a><ul>
<li><a class="reference internal" href="#module-qutip.wigner">Pseudoprobability Functions</a></li>
<li><a class="reference internal" href="#module-qutip.visualization">Graphs and Visualization</a></li>
<li><a class="reference internal" href="#module-qutip.tomography">Quantum Process Tomography</a></li>
</ul>
</li>
<li><a class="reference internal" href="#quantum-information-processing">Quantum Information Processing</a><ul>
<li><a class="reference internal" href="#module-qutip.qip.gates">Gates</a></li>
<li><a class="reference internal" href="#module-qutip.qip.qubits">Qubits</a></li>
<li><a class="reference internal" href="#module-qutip.qip.algorithms.qft">Algorithms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#utilitiy-functions">Utilitiy Functions</a><ul>
<li><a class="reference internal" href="#graph-theory-routines">Graph Theory Routines</a></li>
<li><a class="reference internal" href="#module-qutip.utilities">Utility Functions</a></li>
<li><a class="reference internal" href="#module-qutip.fileio">File I/O Functions</a></li>
<li><a class="reference internal" href="#module-qutip.ipynbtools">IPython Notebook Tools</a></li>
<li><a class="reference internal" href="#module-qutip">Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="classes.html" title="Previous Chapter: Classes"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm">&laquo; Classes</span>
    </a>
  </li>
  <li>
    <a href="../changelog.html" title="Next Chapter: Change Log"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm">Change Log &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="functions">
<span id="id1"></span><h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="manipulation-and-creation-of-states-and-operators">
<h2>Manipulation and Creation of States and Operators<a class="headerlink" href="#manipulation-and-creation-of-states-and-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.states">
<span id="quantum-states"></span><h3>Quantum States<a class="headerlink" href="#module-qutip.states" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.states.basis">
<tt class="descname">basis</tt><big>(</big><em>N</em>, <em>n=0</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#qutip.states.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the vector representation of a Fock state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p>Integer corresponding to desired number state, defaults
to 0 if omitted.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the state.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote class="last">
<div><p>Qobj representing the requested number state <tt class="docutils literal"><span class="pre">|n&gt;</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A subtle incompatibility with the quantum optics toolbox: In QuTiP:</p>
<div class="highlight-python"><div class="highlight"><pre>basis(N, 0) = ground state
</pre></div>
</div>
<p>but in the qotoolbox:</p>
<div class="highlight-python"><div class="highlight"><pre>basis(N, 1) = ground state
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.coherent">
<tt class="descname">coherent</tt><big>(</big><em>N</em>, <em>alpha</em>, <em>offset=0</em>, <em>method='operator'</em><big>)</big><a class="headerlink" href="#qutip.states.coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a coherent state with eigenvalue alpha.</p>
<p>Constructed using displacement operator on vacuum state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>alpha</strong> : float/complex</p>
<blockquote>
<div><p>Eigenvalue of coherent state.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the state. Using a non-zero offset will make the
default method &#8216;analytic&#8217;.</p>
</div></blockquote>
<p><strong>method</strong> : string {&#8216;operator&#8217;, &#8216;analytic&#8217;}</p>
<blockquote>
<div><p>Method for generating coherent state.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote class="last">
<div><p>Qobj quantum object for coherent state</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Select method &#8216;operator&#8217; (default) or &#8216;analytic&#8217;. With the
&#8216;operator&#8217; method, the coherent state is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size &#8216;N&#8217;. This method guarantees that the
resulting state is normalized. With &#8216;analytic&#8217; method the coherent state
is generated using the analytical formula for the coherent state
coefficients in the Fock basis. This method does not guarantee that the
state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mf">0.25j</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[  9.69233235e-01+0.j        ]</span>
<span class="go"> [  0.00000000e+00+0.24230831j]</span>
<span class="go"> [ -4.28344935e-02+0.j        ]</span>
<span class="go"> [  0.00000000e+00-0.00618204j]</span>
<span class="go"> [  7.80904967e-04+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.coherent_dm">
<tt class="descname">coherent_dm</tt><big>(</big><em>N</em>, <em>alpha</em>, <em>offset=0</em>, <em>method='operator'</em><big>)</big><a class="headerlink" href="#qutip.states.coherent_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix representation of a coherent state.</p>
<p>Constructed via outer product of <a class="reference internal" href="#qutip.states.coherent" title="qutip.states.coherent"><tt class="xref py py-func docutils literal"><span class="pre">qutip.states.coherent</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>alpha</strong> : float/complex</p>
<blockquote>
<div><p>Eigenvalue for coherent state.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the state.</p>
</div></blockquote>
<p><strong>method</strong> : string {&#8216;operator&#8217;, &#8216;analytic&#8217;}</p>
<blockquote>
<div><p>Method for generating coherent density matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Density matrix representation of coherent state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Select method &#8216;operator&#8217; (default) or &#8216;analytic&#8217;. With the
&#8216;operator&#8217; method, the coherent density matrix is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size &#8216;N&#8217;. This method guarantees that the
resulting density matrix is normalized. With &#8216;analytic&#8217; method the coherent
density matrix is generated using the analytical formula for the coherent
state coefficients in the Fock basis. This method does not guarantee that
the state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.25j</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.93941695+0.j          0.00000000-0.23480733j -0.04216943+0.j        ]</span>
<span class="go"> [ 0.00000000+0.23480733j  0.05869011+0.j          0.00000000-0.01054025j]</span>
<span class="go"> [-0.04216943+0.j          0.00000000+0.01054025j  0.00189294+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.fock">
<tt class="descname">fock</tt><big>(</big><em>N</em>, <em>n=0</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#qutip.states.fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bosonic Fock (number) state.</p>
<p>Same as <a class="reference internal" href="#qutip.states.basis" title="qutip.states.basis"><tt class="xref py py-func docutils literal"><span class="pre">qutip.states.basis</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of states in the Hilbert space.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">int</span></tt> for desired number state, defaults to 0 if omitted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>Requested number state :math:`left|nright&gt;`.</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fock</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [1]], shape = [4, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.fock_dm">
<tt class="descname">fock_dm</tt><big>(</big><em>N</em>, <em>n=0</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#qutip.states.fock_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix representation of a Fock state</p>
<p>Constructed via outer product of <a class="reference internal" href="#qutip.states.fock" title="qutip.states.fock"><tt class="xref py py-func docutils literal"><span class="pre">qutip.states.fock</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of Fock states in Hilbert space.</p>
</div></blockquote>
<p><strong>n</strong> : int</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">int</span></tt> for desired number state, defaults to 0 if omitted.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Density matrix representation of Fock state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.ket2dm">
<tt class="descname">ket2dm</tt><big>(</big><em>Q</em><big>)</big><a class="headerlink" href="#qutip.states.ket2dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes input ket or bra vector and returns density matrix
formed by outer product.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Q</strong> : qobj</p>
<blockquote>
<div><p>Ket or bra type quantum object.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Density matrix formed by outer product of <cite>Q</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2dm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.qutrit_basis">
<tt class="descname">qutrit_basis</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.states.qutrit_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis states for a three level system (qutrit)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>qstates</strong> : array</p>
<blockquote class="last">
<div><p>Array of qutrit basis vectors</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.thermal_dm">
<tt class="descname">thermal_dm</tt><big>(</big><em>N</em>, <em>n</em>, <em>method='operator'</em><big>)</big><a class="headerlink" href="#qutip.states.thermal_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix for a thermal state of n particles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of basis states in Hilbert space.</p>
</div></blockquote>
<p><strong>n</strong> : float</p>
<blockquote>
<div><p>Expectation value for number of particles in thermal state.</p>
</div></blockquote>
<p><strong>method</strong> : string {&#8216;operator&#8217;, &#8216;analytic&#8217;}</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">string</span></tt> that sets the method used to generate the
thermal state probabilities</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Thermal state density matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The &#8216;operator&#8217; method (default) generates
the thermal state using the truncated number operator <tt class="docutils literal"><span class="pre">num(N)</span></tt>. This
is the method that should be used in computations. The
&#8216;analytic&#8217; method uses the analytic coefficients derived in
an infinite Hilbert space. The analytic form is not necessarily normalized,
if truncated too aggressively.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.51612903  0.          0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.25806452  0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.12903226  0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.06451613  0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.          0.03225806]]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;analytic&#39;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.5      0.       0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.25     0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.125    0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.0625   0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.       0.03125]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_enumerate">
<tt class="descname">state_number_enumerate</tt><big>(</big><em>dims</em>, <em>state=None</em>, <em>idx=0</em><big>)</big><a class="headerlink" href="#qutip.states.state_number_enumerate" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator that enumerate all the state number arrays (quantum numbers on
the form [n1, n2, n3, ...]) for a system with dimensions given by dims.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">state_number_enumerate</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">print</span> <span class="n">state</span>
<span class="go">[ 0.  0.]</span>
<span class="go">[ 0.  1.]</span>
<span class="go">[ 1.  0.]</span>
<span class="go">[ 1.  1.]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list or array</p>
<blockquote>
<div><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</div></blockquote>
<p><strong>state</strong> : list</p>
<blockquote>
<div><p>Current state in the iteration. Used internally.</p>
</div></blockquote>
<p><strong>idx</strong> : integer</p>
<blockquote>
<div><p>Current index in the iteration. Used internally.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state_number</strong> : list</p>
<blockquote class="last">
<div><p>Successive state number arrays that can be used in loops and other
iterations, using standard state enumeration <em>by definition</em>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_index">
<tt class="descname">state_number_index</tt><big>(</big><em>dims</em>, <em>state</em><big>)</big><a class="headerlink" href="#qutip.states.state_number_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of a quantum state corresponding to state,
given a system with dimensions given by dims.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_index</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">6.0</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list or array</p>
<blockquote>
<div><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</div></blockquote>
<p><strong>state</strong> : list</p>
<blockquote>
<div><p>State number array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>idx</strong> : list</p>
<blockquote class="last">
<div><p>The index of the state given by <cite>state</cite> in standard enumeration
ordering.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_index_number">
<tt class="descname">state_index_number</tt><big>(</big><em>dims</em>, <em>index</em><big>)</big><a class="headerlink" href="#qutip.states.state_index_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a quantum number representation given a state index, for a system
of composite structure defined by dims.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">state_index_number</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 1, 0]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list or array</p>
<blockquote>
<div><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</div></blockquote>
<p><strong>index</strong> : integer</p>
<blockquote>
<div><p>The index of the state in standard enumeration ordering.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : list</p>
<blockquote class="last">
<div><p>The state number array corresponding to index <cite>index</cite> in standard
enumeration ordering.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_qobj">
<tt class="descname">state_number_qobj</tt><big>(</big><em>dims</em>, <em>state</em><big>)</big><a class="headerlink" href="#qutip.states.state_number_qobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Qobj representation of a quantum state specified by the state
array <cite>state</cite>.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_qobj</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : list or array</p>
<blockquote>
<div><p>The quantum state dimensions array, as it would appear in a Qobj.</p>
</div></blockquote>
<p><strong>state</strong> : list</p>
<blockquote>
<div><p>State number array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj.qobj</span></tt></p>
<blockquote class="last">
<div><p>The state as a <tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj.qobj</span></tt> instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.phase_basis">
<tt class="descname">phase_basis</tt><big>(</big><em>N</em>, <em>m</em>, <em>phi0=0</em><big>)</big><a class="headerlink" href="#qutip.states.phase_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis vector for the mth phase of the Pegg-Barnett phase operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of basis vectors in Hilbert space.</p>
</div></blockquote>
<p><strong>m</strong> : int</p>
<blockquote>
<div><p>Integer corresponding to the mth discrete phase phi_m=phi0+2*pi*m/N</p>
</div></blockquote>
<p><strong>phi0</strong> : float (default=0)</p>
<blockquote>
<div><p>Reference phase angle.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote class="last">
<div><p>Ket vector for mth Pegg-Barnett phase operator basis state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett basis states form a complete set over the truncated
Hilbert space.</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.operators">
<span id="quantum-operators"></span><h3>Quantum Operators<a class="headerlink" href="#module-qutip.operators" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.operators.create">
<tt class="descname">create</tt><big>(</big><em>N</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#qutip.operators.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation (raising) operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of Hilbert space.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote>
<div><p>Qobj for raising operator.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote class="last">
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">create</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 1.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  1.41421356+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.73205081+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.destroy">
<tt class="descname">destroy</tt><big>(</big><em>N</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#qutip.operators.destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Destruction (lowering) operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of Hilbert space.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Qobj for lowering operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">destroy</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  1.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.41421356+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  1.73205081+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.displace">
<tt class="descname">displace</tt><big>(</big><em>N</em>, <em>alpha</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#qutip.operators.displace" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode displacement operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of Hilbert space.</p>
</div></blockquote>
<p><strong>alpha</strong> : float/complex</p>
<blockquote>
<div><p>Displacement amplitude.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Displacement operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">displace</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.96923323+0.j -0.24230859+0.j  0.04282883+0.j -0.00626025+0.j]</span>
<span class="go"> [ 0.24230859+0.j  0.90866411+0.j -0.33183303+0.j  0.07418172+0.j]</span>
<span class="go"> [ 0.04282883+0.j  0.33183303+0.j  0.84809499+0.j -0.41083747+0.j]</span>
<span class="go"> [ 0.00626025+0.j  0.07418172+0.j  0.41083747+0.j  0.90866411+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.jmat">
<tt class="descname">jmat</tt><big>(</big><em>j</em>, <em>*args</em><big>)</big><a class="headerlink" href="#qutip.operators.jmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Higher-order spin operators:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j</strong> : float</p>
<blockquote>
<div><p>Spin of operator</p>
</div></blockquote>
<p><strong>args</strong> : str</p>
<blockquote>
<div><p>Which operator to return &#8216;x&#8217;,&#8217;y&#8217;,&#8217;z&#8217;,&#8217;+&#8217;,&#8217;-&#8216;.
If no args given, then output is [&#8216;x&#8217;,&#8217;y&#8217;,&#8217;z&#8217;]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>jmat</strong> : qobj/list</p>
<blockquote class="last">
<div><p><tt class="docutils literal"><span class="pre">qobj</span></tt> for requested spin operator(s).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If no &#8216;args&#8217; input, then returns array of [&#8216;x&#8217;,&#8217;y&#8217;,&#8217;z&#8217;] operators.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">jmat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.          0.70710678  0.        ]</span>
<span class="go"> [ 0.70710678  0.          0.70710678]</span>
<span class="go"> [ 0.          0.70710678  0.        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j          0.+0.70710678j  0.+0.j        ]</span>
<span class="go"> [ 0.-0.70710678j  0.+0.j          0.+0.70710678j]</span>
<span class="go"> [ 0.+0.j          0.-0.70710678j  0.+0.j        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  0.  0.]</span>
<span class="go"> [ 0.  0. -1.]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.num">
<tt class="descname">num</tt><big>(</big><em>N</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#qutip.operators.num" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object for number operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>The dimension of the Hilbert space.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper: qobj</strong> :</p>
<blockquote class="last">
<div><p>Qobj for number operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[0 0 0 0]</span>
<span class="go"> [0 1 0 0]</span>
<span class="go"> [0 0 2 0]</span>
<span class="go"> [0 0 0 3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qeye">
<tt class="descname">qeye</tt><big>(</big><em>N</em><big>)</big><a class="headerlink" href="#qutip.operators.qeye" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of Hilbert space.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Identity operator Qobj.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  1.  0.]</span>
<span class="go"> [ 0.  0.  1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.identity">
<tt class="descname">identity</tt><big>(</big><em>N</em><big>)</big><a class="headerlink" href="#qutip.operators.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator. Alternative name to <a class="reference internal" href="#qutip.operators.qeye" title="qutip.operators.qeye"><tt class="xref py py-func docutils literal"><span class="pre">qeye</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of Hilbert space.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Identity operator Qobj.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qutrit_ops">
<tt class="descname">qutrit_ops</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.operators.qutrit_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators for a three level system (qutrit).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>opers: array</strong> :</p>
<blockquote class="last">
<div><p><cite>array</cite> of qutrit operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmam">
<tt class="descname">sigmam</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.operators.sigmam" title="Permalink to this definition">¶</a></dt>
<dd><p>Annihilation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmam</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmap">
<tt class="descname">sigmap</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.operators.sigmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmam</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 0.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmax">
<tt class="descname">sigmax</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.operators.sigmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-x operator</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmax</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmay">
<tt class="descname">sigmay</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.operators.sigmay" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-y operator.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmay</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.-1.j]</span>
<span class="go"> [ 0.+1.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmaz">
<tt class="descname">sigmaz</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.operators.sigmaz" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-z operator.</p>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.]</span>
<span class="go"> [ 0. -1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.squeeze">
<tt class="descname">squeeze</tt><big>(</big><em>N</em>, <em>sp</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#qutip.operators.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode Squeezing operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Dimension of hilbert space.</p>
</div></blockquote>
<p><strong>sp</strong> : float/complex</p>
<blockquote>
<div><p>Squeezing parameter.</p>
</div></blockquote>
<p><strong>offset</strong> : int (default 0)</p>
<blockquote>
<div><p>The lowest number state that is included in the finite number state
representation of the operator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote class="last">
<div><p>Squeezing operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">squeeze</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.98441565+0.j  0.00000000+0.j  0.17585742+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.95349007+0.j  0.00000000+0.j  0.30142443+0.j]</span>
<span class="go"> [-0.17585742+0.j  0.00000000+0.j  0.98441565+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.30142443+0.j  0.00000000+0.j  0.95349007+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.squeezing">
<tt class="descname">squeezing</tt><big>(</big><em>a1</em>, <em>a2</em>, <em>z</em><big>)</big><a class="headerlink" href="#qutip.operators.squeezing" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized squeezing operator.</p>
<div class="math">
\[S(z) = \exp\left(\frac{1}{2}\left(z^*a_1a_2
- za_1^\dagger a_2^\dagger\right)\right)\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Operator 1.</p>
</div></blockquote>
<p><strong>a2</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Operator 2.</p>
</div></blockquote>
<p><strong>z</strong> : float/complex</p>
<blockquote>
<div><p>Squeezing parameter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote class="last">
<div><p>Squeezing operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.phase">
<tt class="descname">phase</tt><big>(</big><em>N</em>, <em>phi0=0</em><big>)</big><a class="headerlink" href="#qutip.operators.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode Pegg-Barnett phase operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of basis states in Hilbert space.</p>
</div></blockquote>
<p><strong>phi0</strong> : float</p>
<blockquote>
<div><p>Reference phase.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Phase operator with respect to reference phase.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space.</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.random_objects">
<span id="random-operators-and-states"></span><span id="functions-rand"></span><h3>Random Operators and States<a class="headerlink" href="#module-qutip.random_objects" title="Permalink to this headline">¶</a></h3>
<p>This module is a collection of random state and operator generators.
The sparsity of the ouput Qobj&#8217;s is controlled by varing the
<cite>density</cite> parameter.</p>
<dl class="function">
<dt id="qutip.random_objects.rand_dm">
<tt class="descname">rand_dm</tt><big>(</big><em>N</em>, <em>density=0.75</em>, <em>pure=False</em>, <em>dims=None</em><big>)</big><a class="headerlink" href="#qutip.random_objects.rand_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Shape of output density matrix.</p>
</div></blockquote>
<p><strong>density</strong> : float</p>
<blockquote>
<div><p>Density between [0,1] of output density matrix.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>NxN density matrix quantum operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For small density matrices., choosing a low density will result in an error
as no diagonal elements will be generated such that <span class="math">\(Tr(\rho)=1\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_herm">
<tt class="descname">rand_herm</tt><big>(</big><em>N</em>, <em>density=0.75</em>, <em>dims=None</em><big>)</big><a class="headerlink" href="#qutip.random_objects.rand_herm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN sparse Hermitian quantum object.</p>
<p>Uses <span class="math">\(H=X+X^{+}\)</span> where <span class="math">\(X\)</span> is
a randomly generated quantum operator with a given <cite>density</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Shape of output quantum operator.</p>
</div></blockquote>
<p><strong>density</strong> : float</p>
<blockquote>
<div><p>Density between [0,1] of output Hermitian operator.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>NxN Hermitian quantum operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_ket">
<tt class="descname">rand_ket</tt><big>(</big><em>N</em>, <em>density=1</em>, <em>dims=None</em><big>)</big><a class="headerlink" href="#qutip.random_objects.rand_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random Nx1 sparse ket vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of rows for output quantum operator.</p>
</div></blockquote>
<p><strong>density</strong> : float</p>
<blockquote>
<div><p>Density between [0,1] of output ket state.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[1]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>Nx1 ket state quantum operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_unitary">
<tt class="descname">rand_unitary</tt><big>(</big><em>N</em>, <em>density=0.75</em>, <em>dims=None</em><big>)</big><a class="headerlink" href="#qutip.random_objects.rand_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN sparse unitary quantum object.</p>
<p>Uses <span class="math">\(\exp(-iH)\)</span> where H is a randomly generated
Hermitian operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Shape of output quantum operator.</p>
</div></blockquote>
<p><strong>density</strong> : float</p>
<blockquote>
<div><p>Density between [0,1] of output Unitary operator.</p>
</div></blockquote>
<p><strong>dims</strong> : list</p>
<blockquote>
<div><p>Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote class="last">
<div><p>NxN Unitary quantum operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.three_level_atom">
<span id="three-level-atoms"></span><h3>Three-Level Atoms<a class="headerlink" href="#module-qutip.three_level_atom" title="Permalink to this headline">¶</a></h3>
<p>This module provides functions that are useful for simulating the
three level atom with QuTiP.  A three level atom (qutrit) has three states,
which are linked by dipole transitions so that 1 &lt;-&gt; 2 &lt;-&gt; 3.
Depending on there relative energies they are in the ladder, lambda or
vee configuration. The structure of the relevant operators is the same
for any of the three configurations:</p>
<div class="highlight-python"><div class="highlight"><pre>Ladder:          Lambda:                 Vee:
                            |two&gt;                       |three&gt;
  -------|three&gt;           -------                      -------
     |                       / \             |one&gt;         /
     |                      /   \           -------       /
     |                     /     \             \         /
  -------|two&gt;            /       \             \       /
     |                   /         \             \     /
     |                  /           \             \   /
     |                 /        --------           \ /
  -------|one&gt;      -------      |three&gt;         -------
                     |one&gt;                       |two&gt;
</pre></div>
</div>
<div class="section" id="references">
<h4>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h4>
<p>The naming of qutip operators follows the convention in <a class="reference internal" href="#r1" id="id2">[R1]</a> .</p>
<table class="docutils citation" frame="void" id="r1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R1]</a></td><td>Shore, B. W., &#8220;The Theory of Coherent Atomic Excitation&#8221;,
Wiley, 1990.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="notes">
<h4>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h4>
<p>Contributed by Markus Baden, Oct. 07, 2011</p>
<dl class="function">
<dt id="qutip.three_level_atom.three_level_basis">
<tt class="descname">three_level_basis</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.three_level_atom.three_level_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis states for a three level atom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>states</strong> : array</p>
<blockquote class="last">
<div><p><cite>array</cite> of three level atom basis vectors.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.three_level_atom.three_level_ops">
<tt class="descname">three_level_ops</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.three_level_atom.three_level_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators for a three level system (qutrit)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ops</strong> : array</p>
<blockquote class="last">
<div><p><cite>array</cite> of three level operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-qutip.superoperator">
<span id="superoperators-and-liouvillians"></span><h3>Superoperators and Liouvillians<a class="headerlink" href="#module-qutip.superoperator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.superoperator.operator_to_vector">
<tt class="descname">operator_to_vector</tt><big>(</big><em>op</em><big>)</big><a class="headerlink" href="#qutip.superoperator.operator_to_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a vector representation of a quantum operator given
the matrix representation.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.vector_to_operator">
<tt class="descname">vector_to_operator</tt><big>(</big><em>op</em><big>)</big><a class="headerlink" href="#qutip.superoperator.vector_to_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a matrix representation given a quantum operator in
vector form.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.liouvillian">
<tt class="descname">liouvillian</tt><big>(</big><em>H</em>, <em>c_ops=</em>, <span class="optional">[</span><span class="optional">]</span><em>data_only=False</em><big>)</big><a class="headerlink" href="#qutip.superoperator.liouvillian" title="Permalink to this definition">¶</a></dt>
<dd><p>Assembles the Liouvillian superoperator from a Hamiltonian
and a <tt class="docutils literal"><span class="pre">list</span></tt> of collapse operators. Like liouvillian, but with an
experimental implementation which avoids creating extra Qobj instances,
which can be advantageous for large systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj</p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>c_ops</strong> : array_like</p>
<blockquote>
<div><p>A <tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of collapse operators.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>L</strong> : qobj</p>
<blockquote class="last">
<div><p>Liouvillian superoperator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.spost">
<tt class="descname">spost</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#qutip.superoperator.spost" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from post-multiplication by operator A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Quantum operator for post multiplication.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>super</strong> : qobj</p>
<blockquote class="last">
<div><p>Superoperator formed from input qauntum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.spre">
<tt class="descname">spre</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#qutip.superoperator.spre" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from pre-multiplication by operator A.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Quantum operator for pre-multiplication.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>super :qobj</strong> :</p>
<blockquote class="last">
<div><p>Superoperator formed from input quantum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.lindblad_dissipator">
<tt class="descname">lindblad_dissipator</tt><big>(</big><em>a</em>, <em>b=None</em>, <em>data_only=False</em><big>)</big><a class="headerlink" href="#qutip.superoperator.lindblad_dissipator" title="Permalink to this definition">¶</a></dt>
<dd><p>Lindblad dissipator (generalized) for a single pair of collapse operators
(a, b), or for a single collapse operator (a) when b is not specified:</p>
<div class="math">
\[\mathcal{D}[a,b]\rho = a \rho b^\dagger -
\frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> : qobj</p>
<blockquote>
<div><p>Left part of collapse operator.</p>
</div></blockquote>
<p><strong>b</strong> : qobj (optional)</p>
<blockquote>
<div><p>Right part of collapse operator. If not specified, b defaults to a.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>D</strong> : qobj</p>
<blockquote class="last">
<div><p>Lindblad dissipator superoperator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.superop_reps">
<span id="superoperator-representations"></span><h3>Superoperator Representations<a class="headerlink" href="#module-qutip.superop_reps" title="Permalink to this headline">¶</a></h3>
<p>This module implements transformations between superoperator representations,
including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.</p>
<dl class="function">
<dt id="qutip.superop_reps.to_choi">
<tt class="descname">to_choi</tt><big>(</big><em>q_oper</em><big>)</big><a class="headerlink" href="#qutip.superop_reps.to_choi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to the Choi representation,
such that the trace of the returned operator is equal to the dimension
of the system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_oper</strong> : Qobj</p>
<blockquote>
<div><p>Superoperator to be converted to Choi representation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>choi</strong> : Qobj</p>
<blockquote>
<div><p>A quantum object representing the same map as <tt class="docutils literal"><span class="pre">q_oper</span></tt>, such that
<tt class="docutils literal"><span class="pre">choi.superrep</span> <span class="pre">==</span> <span class="pre">&quot;choi&quot;</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError: if the given quantum object is not a map, or cannot be converted</strong> :</p>
<blockquote class="last">
<div><p>to Choi representation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superop_reps.to_super">
<tt class="descname">to_super</tt><big>(</big><em>q_oper</em><big>)</big><a class="headerlink" href="#qutip.superop_reps.to_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to the supermatrix (Liouville)
representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_oper</strong> : Qobj</p>
<blockquote>
<div><p>Superoperator to be converted to supermatrix representation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>superop</strong> : Qobj</p>
<blockquote>
<div><p>A quantum object representing the same map as <tt class="docutils literal"><span class="pre">q_oper</span></tt>, such that
<tt class="docutils literal"><span class="pre">superop.superrep</span> <span class="pre">==</span> <span class="pre">&quot;super&quot;</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError: if the given quantum object is not a map, or cannot be converted</strong> :</p>
<blockquote class="last">
<div><p>to supermatrix representation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superop_reps.to_kraus">
<tt class="descname">to_kraus</tt><big>(</big><em>q_oper</em><big>)</big><a class="headerlink" href="#qutip.superop_reps.to_kraus" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to a list of quantum objects,
each representing an operator in the Kraus decomposition of the given map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q_oper</strong> : Qobj</p>
<blockquote>
<div><p>Superoperator to be converted to Kraus representation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>kraus_ops</strong> : list of Qobj</p>
<blockquote>
<div><p>A list of quantum objects, each representing a Kraus operator in the
decomposition of <tt class="docutils literal"><span class="pre">q_oper</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError: if the given quantum object is not a map, or cannot be</strong> :</p>
<blockquote class="last">
<div><p>decomposed into Kraus operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="functions-acting-on-states-and-operators">
<h2>Functions acting on states and operators<a class="headerlink" href="#functions-acting-on-states-and-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.tensor">
<span id="tensor"></span><h3>Tensor<a class="headerlink" href="#module-qutip.tensor" title="Permalink to this headline">¶</a></h3>
<p>Module for the creation of composite quantum objects via the tensor product.</p>
<dl class="function">
<dt id="qutip.tensor.tensor">
<tt class="descname">tensor</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#qutip.tensor.tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tensor product of input operators.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>args</strong> : array_like</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of quantum objects for tensor product.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>obj</strong> : qobj</p>
<blockquote class="last">
<div><p>A composite quantum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor</span><span class="p">([</span><span class="n">sigmax</span><span class="p">(),</span> <span class="n">sigmax</span><span class="p">()])</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.expect">
<span id="expectation-values"></span><h3>Expectation Values<a class="headerlink" href="#module-qutip.expect" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.expect.expect">
<tt class="descname">expect</tt><big>(</big><em>oper</em>, <em>state</em><big>)</big><a class="headerlink" href="#qutip.expect.expect" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value for operator(s) and state(s).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj/array-like</p>
<blockquote>
<div><p>A single or a <cite>list</cite> or operators for expectation value.</p>
</div></blockquote>
<p><strong>state</strong> : qobj/array-like</p>
<blockquote>
<div><p>A single or a <cite>list</cite> of quantum states or density matrices.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>expt</strong> : float/complex/array-like</p>
<blockquote class="last">
<div><p>Expectation value.  <tt class="docutils literal"><span class="pre">real</span></tt> if <cite>oper</cite> is Hermitian, <tt class="docutils literal"><span class="pre">complex</span></tt>
otherwise. A (nested) array of expectaction values of state or operator
are arrays.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">expect</span><span class="p">(</span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">basis</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.expect.variance">
<tt class="descname">variance</tt><big>(</big><em>oper</em>, <em>state</em><big>)</big><a class="headerlink" href="#qutip.expect.variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Variance of an operator for the given state vector or density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>oper</strong> : qobj</p>
<blockquote>
<div><p>Operator for expectation value.</p>
</div></blockquote>
<p><strong>state</strong> : qobj/list</p>
<blockquote>
<div><p>A single or <cite>list</cite> of quantum states or density matrices..</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>var</strong> : float</p>
<blockquote class="last">
<div><p>Variance of operator &#8216;oper&#8217; for given state.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.partial_transpose">
<span id="partial-transpose"></span><h3>Partial Transpose<a class="headerlink" href="#module-qutip.partial_transpose" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.partial_transpose.partial_transpose">
<tt class="descname">partial_transpose</tt><big>(</big><em>rho</em>, <em>mask</em>, <em>method='dense'</em><big>)</big><a class="headerlink" href="#qutip.partial_transpose.partial_transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the partial transpose of a Qobj instance <cite>rho</cite>,
where <cite>mask</cite> is an array/list with length that equals
the number of components of <cite>rho</cite> (that is, the length of
<cite>rho.dims[0]</cite>), and the values in <cite>mask</cite> indicates whether
or not the corresponding subsystem is to be transposed.
The elements in <cite>mask</cite> can be boolean or integers <cite>0</cite> or <cite>1</cite>,
where <cite>True</cite>/<cite>1</cite> indicates that the corresponding subsystem
should be tranposed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>A density matrix.</p>
</div></blockquote>
<p><strong>mask</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>A mask that selects which subsystems should be transposed.</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>choice of method, <cite>dense</cite> or <cite>sparse</cite>. The default method
is <cite>dense</cite>. The <cite>sparse</cite> implementation can be faster for
large and sparse systems (hundreds of quantum states).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rho_pr: :class:`qutip.qobj`</strong> :</p>
<blockquote class="last">
<div><p>A density matrix with the selected subsystems transposed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.entropy">
<span id="entropy-functions"></span><span id="functions-entropy"></span><h3>Entropy Functions<a class="headerlink" href="#module-qutip.entropy" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.entropy.concurrence">
<tt class="descname">concurrence</tt><big>(</big><em>rho</em><big>)</big><a class="headerlink" href="#qutip.entropy.concurrence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the concurrence entanglement measure for a two-qubit state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote>
<div><p>Ket, bra, or density matrix for a two-qubit state.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>concur</strong> : float</p>
<blockquote class="last">
<div><p>Concurrence</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[R2]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Concurrence_(quantum_computing">http://en.wikipedia.org/wiki/Concurrence_(quantum_computing</a>)</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_conditional">
<tt class="descname">entropy_conditional</tt><big>(</big><em>rho</em>, <em>selB</em>, <em>base=2.718281828459045</em>, <em>sparse=False</em><big>)</big><a class="headerlink" href="#qutip.entropy.entropy_conditional" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the conditional entropy <span class="math">\(S(A|B)=S(A,B)-S(B)\)</span>
of a slected density matrix component.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>Density matrix of composite object</p>
</div></blockquote>
<p><strong>selB</strong> : int/list</p>
<blockquote>
<div><p>Selected components for density matrix B</p>
</div></blockquote>
<p><strong>base</strong> : {e,2}</p>
<blockquote>
<div><p>Base of logarithm.</p>
</div></blockquote>
<p><strong>sparse</strong> : {False,True}</p>
<blockquote>
<div><p>Use sparse eigensolver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ent_cond</strong> : float</p>
<blockquote class="last">
<div><p>Value of conditional entropy</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_linear">
<tt class="descname">entropy_linear</tt><big>(</big><em>rho</em><big>)</big><a class="headerlink" href="#qutip.entropy.entropy_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear entropy of a density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>sensity matrix or ket/bra vector.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>entropy</strong> : float</p>
<blockquote class="last">
<div><p>Linear entropy of rho.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_linear</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_mutual">
<tt class="descname">entropy_mutual</tt><big>(</big><em>rho</em>, <em>selA</em>, <em>selB</em>, <em>base=2.718281828459045</em>, <em>sparse=False</em><big>)</big><a class="headerlink" href="#qutip.entropy.entropy_mutual" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mutual information S(A:B) between selection
components of a system density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>Density matrix for composite quantum systems</p>
</div></blockquote>
<p><strong>selA</strong> : int/list</p>
<blockquote>
<div><p><cite>int</cite> or <cite>list</cite> of first selected density matrix components.</p>
</div></blockquote>
<p><strong>selB</strong> : int/list</p>
<blockquote>
<div><p><cite>int</cite> or <cite>list</cite> of second selected density matrix components.</p>
</div></blockquote>
<p><strong>base</strong> : {e,2}</p>
<blockquote>
<div><p>Base of logarithm.</p>
</div></blockquote>
<p><strong>sparse</strong> : {False,True}</p>
<blockquote>
<div><p>Use sparse eigensolver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ent_mut</strong> : float</p>
<blockquote class="last">
<div><p>Mutual information between selected components.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_vn">
<tt class="descname">entropy_vn</tt><big>(</big><em>rho</em>, <em>base=2.718281828459045</em>, <em>sparse=False</em><big>)</big><a class="headerlink" href="#qutip.entropy.entropy_vn" title="Permalink to this definition">¶</a></dt>
<dd><p>Von-Neumann entropy of density matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>Density matrix.</p>
</div></blockquote>
<p><strong>base</strong> : {e,2}</p>
<blockquote>
<div><p>Base of logarithm.</p>
</div></blockquote>
<p><strong>sparse</strong> : {False,True}</p>
<blockquote>
<div><p>Use sparse eigensolver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>entropy</strong> : float</p>
<blockquote class="last">
<div><p>Von-Neumann entropy of <cite>rho</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_vn</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.metrics">
<span id="density-matrix-metrics"></span><h3>Density Matrix Metrics<a class="headerlink" href="#module-qutip.metrics" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection of functions for calculating metrics
(distance measures) between states and operators.</p>
<dl class="function">
<dt id="qutip.metrics.fidelity">
<tt class="descname">fidelity</tt><big>(</big><em>A</em>, <em>B</em><big>)</big><a class="headerlink" href="#qutip.metrics.fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the fidelity (pseudo-metric) between two density matrices.
See: Nielsen &amp; Chuang, &#8220;Quantum Computation and Quantum Information&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector.</p>
</div></blockquote>
<p><strong>B</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector with same dimensions as A.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fid</strong> : float</p>
<blockquote class="last">
<div><p>Fidelity pseudo-metric between A and B.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">0.24104350624628332</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.tracedist">
<tt class="descname">tracedist</tt><big>(</big><em>A</em>, <em>B</em>, <em>sparse=False</em>, <em>tol=0</em><big>)</big><a class="headerlink" href="#qutip.metrics.tracedist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the trace distance between two density matrices..
See: Nielsen &amp; Chuang, &#8220;Quantum Computation and Quantum Information&#8221;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector.</p>
</div></blockquote>
<p><strong>B</strong> : qobj</p>
<blockquote>
<div><p>Density matrix or state vector with same dimensions as A.</p>
</div></blockquote>
<p><strong>tol</strong> : float</p>
<blockquote>
<div><p>Tolerance used by sparse eigensolver, if used. (0=Machine precision)</p>
</div></blockquote>
<p><strong>sparse</strong> : {False, True}</p>
<blockquote>
<div><p>Use sparse eigensolver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>tracedist</strong> : float</p>
<blockquote class="last">
<div><p>Trace distance between A and B.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tracedist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">0.9705143161472971</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.continuous_variables">
<span id="continous-variables"></span><h3>Continous Variables<a class="headerlink" href="#module-qutip.continuous_variables" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection functions for calculating continuous variable
quantities from fock-basis representation of the state of multi-mode fields.</p>
<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix">
<tt class="descname">correlation_matrix</tt><big>(</big><em>basis</em>, <em>rho=None</em><big>)</big><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a basis set of operators <span class="math">\(\{a\}_n\)</span>, calculate the correlation
matrix:</p>
<div class="math">
\[C_{mn} = \langle a_m a_n \rangle\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>basis</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>List of operators that defines the basis for the correlation matrix.</p>
</div></blockquote>
<p><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Density matrix for which to calculate the correlation matrix. If
<cite>rho</cite> is <cite>None</cite>, then a matrix of correlation matrix operators is
returned instead of expectation values of those operators.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat: *array*</strong> :</p>
<blockquote class="last">
<div><p>A 2-dimensional <em>array</em> of correlation values or operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.covariance_matrix">
<tt class="descname">covariance_matrix</tt><big>(</big><em>basis</em>, <em>rho</em>, <em>symmetrized=True</em><big>)</big><a class="headerlink" href="#qutip.continuous_variables.covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a basis set of operators <span class="math">\(\{a\}_n\)</span>, calculate the covariance
matrix:</p>
<div class="math">
\[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<p>or, if of the optional argument <cite>symmetrized=False</cite>,</p>
<div class="math">
\[V_{mn} = \langle a_m a_n\rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>basis</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>List of operators that defines the basis for the covariance matrix.</p>
</div></blockquote>
<p><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Density matrix for which to calculate the covariance matrix.</p>
</div></blockquote>
<p><strong>symmetrized</strong> : <em>bool</em></p>
<blockquote>
<div><p>Flag indicating whether the symmetrized (default) or non-symmetrized
correlation matrix is to be calculated.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat: *array*</strong> :</p>
<blockquote class="last">
<div><p>A 2-dimensional <em>array</em> of covariance values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix_field">
<tt class="descname">correlation_matrix_field</tt><big>(</big><em>a1</em>, <em>a2</em>, <em>rho=None</em><big>)</big><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the correlation matrix for given field operators <span class="math">\(a_1\)</span> and
<span class="math">\(a_2\)</span>. If a density matrix is given the expectation values are
calculated, otherwise a matrix with operators is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Field operator for mode 1.</p>
</div></blockquote>
<p><strong>a2</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Field operator for mode 2.</p>
</div></blockquote>
<p><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Density matrix for which to calculate the covariance matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cov_mat: *array* of complex numbers or :class:`qutip.qobj.Qobj`</strong> :</p>
<blockquote class="last">
<div><p>A 2-dimensional <em>array</em> of covariance values, or, if rho=0, a matrix
of operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix_quadrature">
<tt class="descname">correlation_matrix_quadrature</tt><big>(</big><em>a1</em>, <em>a2</em>, <em>rho=None</em><big>)</big><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_quadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the quadrature correlation matrix with given field operators
<span class="math">\(a_1\)</span> and <span class="math">\(a_2\)</span>. If a density matrix is given the expectation
values are calculated, otherwise a matrix with operators is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Field operator for mode 1.</p>
</div></blockquote>
<p><strong>a2</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Field operator for mode 2.</p>
</div></blockquote>
<p><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Density matrix for which to calculate the covariance matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat: *array* of complex numbers or :class:`qutip.qobj.Qobj`</strong> :</p>
<blockquote class="last">
<div><p>A 2-dimensional <em>array</em> of covariance values for the field quadratures,
or, if rho=0, a matrix of operators.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.wigner_covariance_matrix">
<tt class="descname">wigner_covariance_matrix</tt><big>(</big><em>a1=None</em>, <em>a2=None</em>, <em>R=None</em>, <em>rho=None</em><big>)</big><a class="headerlink" href="#qutip.continuous_variables.wigner_covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Wigner covariance matrix
<span class="math">\(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\)</span>, given
the quadrature correlation matrix
<span class="math">\(R_{ij} = \langle R_{i} R_{j}\rangle -
\langle R_{i}\rangle \langle R_{j}\rangle\)</span>, where
<span class="math">\(R = (q_1, p_1, q_2, p_2)^T\)</span> is the vector with quadrature operators
for the two modes.</p>
<p>Alternatively, if <cite>R = None</cite>, and if annihilation operators <cite>a1</cite> and <cite>a2</cite>
for the two modes are supplied instead, the quadrature correlation matrix
is constructed from the annihilation operators before then the covariance
matrix is calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a1</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Field operator for mode 1.</p>
</div></blockquote>
<p><strong>a2</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Field operator for mode 2.</p>
</div></blockquote>
<p><strong>R</strong> : <em>array</em></p>
<blockquote>
<div><p>The quadrature correlation matrix.</p>
</div></blockquote>
<p><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Density matrix for which to calculate the covariance matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cov_mat: *array*</strong> :</p>
<blockquote class="last">
<div><p>A 2-dimensional <em>array</em> of covariance values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.logarithmic_negativity">
<tt class="descname">logarithmic_negativity</tt><big>(</big><em>V</em><big>)</big><a class="headerlink" href="#qutip.continuous_variables.logarithmic_negativity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the logarithmic negativity given the symmetrized covariance
matrix, see <tt class="xref py py-func docutils literal"><span class="pre">qutip.continous_variables.covariance_matrix</span></tt>. Note that
the two-mode field state that is described by <cite>V</cite> must be Gaussian for this
function to applicable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>V</strong> : <em>2d array</em></p>
<blockquote>
<div><p>The covariance matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>N: *float*, the logarithmic negativity for the two-mode Gaussian state</strong> :</p>
<p class="last"><strong>that is described by the the Wigner covariance matrix V.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="dynamics-and-time-evolution">
<h2>Dynamics and Time-Evolution<a class="headerlink" href="#dynamics-and-time-evolution" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.sesolve">
<span id="schrodinger-equation"></span><h3>Schrödinger Equation<a class="headerlink" href="#module-qutip.sesolve" title="Permalink to this headline">¶</a></h3>
<p>This module provides solvers for the unitary Schrodinger equation.</p>
<dl class="function">
<dt id="qutip.sesolve.sesolve">
<tt class="descname">sesolve</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>e_ops</em>, <em>args={}</em>, <em>options=None</em>, <em>progress_bar=&lt;qutip.ui.progressbar.BaseProgressBar object at 0x2b11f65d3a90&gt;</em><big>)</big><a class="headerlink" href="#qutip.sesolve.sesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Schrodinger equation evolution of a state vector for a given Hamiltonian.</p>
<p>Evolve the state vector or density matrix (<cite>rho0</cite>) using a given
Hamiltonian (<cite>H</cite>), by integrating the set of ordinary differential
equations that define the system.</p>
<p>The output is either the state vector at arbitrary points in time
(<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian, or a callback function for time-dependent
Hamiltonians.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>args</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
</div></blockquote>
<p><strong>options</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.Qdeoptions</span></tt></p>
<blockquote>
<div><p>with options for the ODE solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output: :class:`qutip.solver`</strong> :</p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>, or
an <em>array</em> or state vectors or density matrices corresponding to the
times in <cite>tlist</cite> [if <cite>e_ops</cite> is an empty list], or
nothing if a callback function was given inplace of operators for
which to calculate the expectation values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.mesolve">
<span id="master-equation"></span><h3>Master Equation<a class="headerlink" href="#module-qutip.mesolve" title="Permalink to this headline">¶</a></h3>
<p>This module provides solvers for the Lindblad master equation and von Neumann
equation.</p>
<dl class="function">
<dt id="qutip.mesolve.mesolve">
<tt class="descname">mesolve</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>c_ops</em>, <em>e_ops</em>, <em>args={}</em>, <em>options=None</em>, <em>progress_bar=&lt;qutip.ui.progressbar.BaseProgressBar object at 0x2b11f65d3b10&gt;</em><big>)</big><a class="headerlink" href="#qutip.mesolve.mesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Master equation evolution of a density matrix for a given Hamiltonian.</p>
<p>Evolve the state vector or density matrix (<cite>rho0</cite>) using a given
Hamiltonian (<cite>H</cite>) and an [optional] set of collapse operators
(<cite>c_op_list</cite>), by integrating the set of ordinary differential equations
that define the system. In the absence of collapse operators the system is
evolved according to the unitary evolution of the Hamiltonian.</p>
<p>The output is either the state vector at arbitrary points in time
(<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values.</p>
<p><strong>Time-dependent operators</strong></p>
<p>For problems with time-dependent problems <cite>H</cite> and <cite>c_ops</cite> can be callback
functions that takes two arguments, time and <cite>args</cite>, and returns the
Hamiltonian or Liouvillian for the system at that point in time
(<em>callback format</em>).</p>
<p>Alternatively, <cite>H</cite> and <cite>c_ops</cite> can be a specified in a nested-list format
where each element in the list is a list of length 2, containing an
operator (<tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt>) at the first element and where the
second element is either a string (<em>list string format</em>), a callback
function (<em>list callback format</em>) that evaluates to the time-dependent
coefficient for the corresponding operator, or a numpy array (<em>list
array format</em>) which specifies the value of the coefficient to the
corresponding operator for each value of t in tlist.</p>
<p><em>Examples</em></p>
<blockquote>
<div><p>H = [[H0, &#8216;sin(w*t)&#8217;], [H1, &#8216;sin(2*w*t)&#8217;]]</p>
<p>H = [[H0, sin(w*tlist)], [H1, sin(2*w*tlist)]]</p>
<p>H = [[H0, f0_t], [H1, f1_t]]</p>
<p>where f0_t and f1_t are python functions with signature f_t(t, args).</p>
</div></blockquote>
<p>In the <em>list string format</em> and <em>list callback format</em>, the string
expression and the callback function must evaluate to a real or complex
number (coefficient for the corresponding operator).</p>
<p>In all cases of time-dependent operators, <cite>args</cite> is a dictionary of
parameters that is used when evaluating operators. It is passed to the
callback functions as second argument</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If an element in the list-specification of the Hamiltonian or
the list of collapse operators are in super-operator for it will be
added to the total Liouvillian of the problem with out further
transformation. This allows for using mesolve for solving master
equations that are not on standard Lindblad form.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On using callback function: mesolve transforms all <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt>
objects to sparse matrices before handing the problem to the integrator
function. In order for your callback function to work correctly, pass
all <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> objects that are used in constructing the
Hamiltonian via args. mesolve will check for <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> in
<cite>args</cite> and handle the conversion to sparse matrices. All other
<tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> objects that are not passed via <cite>args</cite> will be
passed on to the integrator in scipy which will raise an NotImplemented
exception.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>system Hamiltonian, or a callback function for time-dependent
Hamiltonians.</p>
</div></blockquote>
<p><strong>rho0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>single collapse operator, or list of collapse operators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>args</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
</div></blockquote>
<p><strong>options</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.Options</span></tt></p>
<blockquote>
<div><p>with options for the ODE solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output: :class:`qutip.solver`</strong> :</p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>, or
an <em>array</em> or state vectors or density matrices corresponding to the
times in <cite>tlist</cite> [if <cite>e_ops</cite> is an empty list], or
nothing if a callback function was given in place of operators for
which to calculate the expectation values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.mcsolve">
<span id="monte-carlo-evolution"></span><h3>Monte Carlo Evolution<a class="headerlink" href="#module-qutip.mcsolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.mcsolve.mcsolve">
<tt class="descname">mcsolve</tt><big>(</big><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>c_ops</em>, <em>e_ops</em>, <em>ntraj=None</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f5a5ccf8&gt;</em><big>)</big><a class="headerlink" href="#qutip.mcsolve.mcsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte-Carlo evolution of a state vector <span class="math">\(|\psi \rangle\)</span> for a
given Hamiltonian and sets of collapse operators, and possibly, operators
for calculating expectation values. Options for the underlying ODE solver
are given by the Options class.</p>
<p>mcsolve supports time-dependent Hamiltonians and collapse operators using
either Python functions of strings to represent time-dependent
coefficients. Note that, the system Hamiltonian MUST have at least one
constant term.</p>
<p>As an example of a time-dependent problem, consider a Hamiltonian with two
terms <tt class="docutils literal"><span class="pre">H0</span></tt> and <tt class="docutils literal"><span class="pre">H1</span></tt>, where <tt class="docutils literal"><span class="pre">H1</span></tt> is time-dependent with coefficient
<tt class="docutils literal"><span class="pre">sin(w*t)</span></tt>, and collapse operators <tt class="docutils literal"><span class="pre">C0</span></tt> and <tt class="docutils literal"><span class="pre">C1</span></tt>, where <tt class="docutils literal"><span class="pre">C1</span></tt> is
time-dependent with coeffcient <tt class="docutils literal"><span class="pre">exp(-a*t)</span></tt>.  Here, w and a are constant
arguments with values <tt class="docutils literal"><span class="pre">W</span></tt> and <tt class="docutils literal"><span class="pre">A</span></tt>.</p>
<p>Using the Python function time-dependent format requires two Python
functions, one for each collapse coefficient. Therefore, this problem could
be expressed as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">C1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">args</span><span class="p">[</span><span class="s">&#39;a&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">H</span><span class="o">=</span><span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="n">H1_coeff</span><span class="p">]]</span>

<span class="n">c_op_list</span><span class="o">=</span><span class="p">[</span><span class="n">C0</span><span class="p">,[</span><span class="n">C1</span><span class="p">,</span><span class="n">C1_coeff</span><span class="p">]]</span>

<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span><span class="n">A</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">:</span><span class="n">W</span><span class="p">}</span>
</pre></div>
</div>
<p>or in String (Cython) format we could write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">H</span><span class="o">=</span><span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="s">&#39;sin(w*t)&#39;</span><span class="p">]]</span>

<span class="n">c_op_list</span><span class="o">=</span><span class="p">[</span><span class="n">C0</span><span class="p">,[</span><span class="n">C1</span><span class="p">,</span><span class="s">&#39;exp(-a*t)&#39;</span><span class="p">]]</span>

<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;a&#39;</span><span class="p">:</span><span class="n">A</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">:</span><span class="n">W</span><span class="p">}</span>
</pre></div>
</div>
<p>Constant terms are preferably placed first in the Hamiltonian and collapse
operator lists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj</p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>psi0</strong> : qobj</p>
<blockquote>
<div><p>Initial state vector</p>
</div></blockquote>
<p><strong>tlist</strong> : array_like</p>
<blockquote>
<div><p>Times at which results are recorded.</p>
</div></blockquote>
<p><strong>ntraj</strong> : int</p>
<blockquote>
<div><p>Number of trajectories to run.</p>
</div></blockquote>
<p><strong>c_ops</strong> : array_like</p>
<blockquote>
<div><p>single collapse operator or <tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of collapse
operators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : array_like</p>
<blockquote>
<div><p>single operator or <tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of operators for calculating
expectation values.</p>
</div></blockquote>
<p><strong>args</strong> : dict</p>
<blockquote>
<div><p>Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>Instance of ODE solver options.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>results</strong> : Result</p>
<blockquote class="last">
<div><p>Object storing all results from simulation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-qutip.fortran.mcsolve_f90"></span><dl class="function">
<dt id="qutip.fortran.mcsolve_f90.mcsolve_f90">
<tt class="descname">mcsolve_f90</tt><big>(</big><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>c_ops</em>, <em>e_ops</em>, <em>ntraj=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f5a5cd40&gt;</em>, <em>sparse_dms=True</em>, <em>serial=False</em>, <em>ptrace_sel=</em>, <span class="optional">[</span><span class="optional">]</span><em>calc_entropy=False</em><big>)</big><a class="headerlink" href="#qutip.fortran.mcsolve_f90.mcsolve_f90" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte-Carlo wave function solver with fortran 90 backend.
Usage is identical to qutip.mcsolve, for problems without explicit
time-dependence, and with some optional input:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj</p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>psi0</strong> : qobj</p>
<blockquote>
<div><p>Initial state vector</p>
</div></blockquote>
<p><strong>tlist</strong> : array_like</p>
<blockquote>
<div><p>Times at which results are recorded.</p>
</div></blockquote>
<p><strong>ntraj</strong> : int</p>
<blockquote>
<div><p>Number of trajectories to run.</p>
</div></blockquote>
<p><strong>c_ops</strong> : array_like</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of collapse operators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : array_like</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of operators for calculating expectation values.</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>Instance of solver options.</p>
</div></blockquote>
<p><strong>sparse_dms</strong> : boolean</p>
<blockquote>
<div><p>If averaged density matrices are returned, they will be stored as
sparse (Compressed Row Format) matrices during computation if
sparse_dms = True (default), and dense matrices otherwise. Dense
matrices might be preferable for smaller systems.</p>
</div></blockquote>
<p><strong>serial</strong> : boolean</p>
<blockquote>
<div><p>If True (default is False) the solver will not make use of the
multiprocessing module, and simply run in serial.</p>
</div></blockquote>
<p><strong>ptrace_sel: list</strong> :</p>
<blockquote>
<div><p>This optional argument specifies a list of components to keep when
returning a partially traced density matrix. This can be convenient for
large systems where memory becomes a problem, but you are only
interested in parts of the density matrix.</p>
</div></blockquote>
<p><strong>calc_entropy</strong> : boolean</p>
<blockquote>
<div><p>If ptrace_sel is specified, calc_entropy=True will have the solver
return the averaged entropy over trajectories in results.entropy. This
can be interpreted as a measure of entanglement. See Phys. Rev. Lett.
93, 120408 (2004), Phys. Rev. A 86, 022310 (2012).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>results</strong> : Result</p>
<blockquote class="last">
<div><p>Object storing all results from simulation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.essolve">
<span id="exponential-series"></span><h3>Exponential Series<a class="headerlink" href="#module-qutip.essolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.essolve.essolve">
<tt class="descname">essolve</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>c_op_list</em>, <em>e_ops</em><big>)</big><a class="headerlink" href="#qutip.essolve.essolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolution of a state vector or density matrix (<cite>rho0</cite>) for a given
Hamiltonian (<cite>H</cite>) and set of collapse operators (<cite>c_op_list</cite>), by
expressing the ODE as an exponential series. The output is either
the state vector at arbitrary points in time (<cite>tlist</cite>), or the
expectation values of the supplied operators (<cite>e_ops</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj/function_type</p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix.</p>
</div></blockquote>
<p><strong>tlist</strong> : list/array</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>c_op_list</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> collapse operators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> operators for which to evaluate
expectation values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>expt_array</strong> : array</p>
<blockquote>
<div><p>Expectation values of wavefunctions/density matrices for the
times specified in <tt class="docutils literal"><span class="pre">tlist</span></tt>.</p>
</div></blockquote>
<p class="last"><strong>.. note:: This solver does not support time-dependent Hamiltonians.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.essolve.ode2es">
<tt class="descname">ode2es</tt><big>(</big><em>L</em>, <em>rho0</em><big>)</big><a class="headerlink" href="#qutip.essolve.ode2es" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an exponential series that describes the time evolution for the
initial density matrix (or state vector) <cite>rho0</cite>, given the Liouvillian
(or Hamiltonian) <cite>L</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>L</strong> : qobj</p>
<blockquote>
<div><p>Liouvillian of the system.</p>
</div></blockquote>
<p><strong>rho0</strong> : qobj</p>
<blockquote>
<div><p>Initial state vector or density matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eseries</strong> : <a class="reference internal" href="classes.html#qutip.eseries" title="qutip.eseries"><tt class="xref py py-class docutils literal"><span class="pre">qutip.eseries</span></tt></a></p>
<blockquote class="last">
<div><p><tt class="docutils literal"><span class="pre">eseries</span></tt> represention of the system dynamics.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.bloch_redfield">
<span id="bloch-redfield-master-equation"></span><h3>Bloch-Redfield Master Equation<a class="headerlink" href="#module-qutip.bloch_redfield" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.bloch_redfield.brmesolve">
<tt class="descname">brmesolve</tt><big>(</big><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>a_ops</em>, <em>e_ops=</em>, <span class="optional">[</span><span class="optional">]</span><em>spectra_cb=</em>, <span class="optional">[</span><span class="optional">]</span><em>args={}</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f6845680&gt;</em><big>)</big><a class="headerlink" href="#qutip.bloch_redfield.brmesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the dynamics for the system using the Bloch-Redfeild master equation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This solver does not currently support time-dependent Hamiltonian or
collapse operators.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0 / psi0: :class:`qutip.qobj`</strong> :</p>
<blockquote>
<div><p>Initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>a_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>List of system operators that couple to bath degrees of freedom.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> / callback function</p>
<blockquote>
<div><p>List of operators for which to evaluate expectation values.</p>
</div></blockquote>
<p><strong>args</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Dictionary of parameters for time-dependent Hamiltonians and collapse
operators.</p>
</div></blockquote>
<p><strong>options</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.Qdeoptions</span></tt></p>
<blockquote>
<div><p>Options for the ODE solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output: :class:`qutip.solver`</strong> :</p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt>, which contains either
a list of expectation values, for operators given in e_ops, or a list
of states for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.bloch_redfield.bloch_redfield_tensor">
<tt class="descname">bloch_redfield_tensor</tt><big>(</big><em>H</em>, <em>a_ops</em>, <em>spectra_cb</em>, <em>use_secular=True</em><big>)</big><a class="headerlink" href="#qutip.bloch_redfield.bloch_redfield_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Bloch-Redfield tensor for a system given a set of operators
and corresponding spectral functions that describes the system&#8217;s coupling
to its environment.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>a_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>List of system operators that couple to the environment.</p>
</div></blockquote>
<p><strong>spectra_cb</strong> : list of callback functions</p>
<blockquote>
<div><p>List of callback functions that evaluate the noise power spectrum
at a given frequency.</p>
</div></blockquote>
<p><strong>use_secular</strong> : bool</p>
<blockquote>
<div><p>Flag (True of False) that indicates if the secular approximation should
be used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>R, kets: :class:`qutip.qobj`, list of :class:`qutip.qobj`</strong> :</p>
<blockquote class="last">
<div><p>R is the Bloch-Redfield tensor and kets is a list eigenstates of the
Hamiltonian.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.bloch_redfield.bloch_redfield_solve">
<tt class="descname">bloch_redfield_solve</tt><big>(</big><em>R</em>, <em>ekets</em>, <em>rho0</em>, <em>tlist</em>, <em>e_ops=</em>, <span class="optional">[</span><span class="optional">]</span><em>options=None</em><big>)</big><a class="headerlink" href="#qutip.bloch_redfield.bloch_redfield_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolve the ODEs defined by Bloch-Redfield master equation. The
Bloch-Redfield tensor can be calculated by the function
<a class="reference internal" href="#qutip.bloch_redfield.bloch_redfield_tensor" title="qutip.bloch_redfield.bloch_redfield_tensor"><tt class="xref py py-func docutils literal"><span class="pre">bloch_redfield_tensor</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>R</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>Bloch-Redfield tensor.</p>
</div></blockquote>
<p><strong>ekets</strong> : array of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>Array of kets that make up a basis tranformation for the eigenbasis.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>Initial density matrix.</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> / callback function</p>
<blockquote>
<div><p>List of operators for which to evaluate expectation values.</p>
</div></blockquote>
<p><strong>options</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.Qdeoptions</span></tt></p>
<blockquote>
<div><p>Options for the ODE solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output: :class:`qutip.solver`</strong> :</p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.floquet">
<span id="floquet-states-and-floquet-markov-master-equation"></span><h3>Floquet States and Floquet-Markov Master Equation<a class="headerlink" href="#module-qutip.floquet" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.floquet.fmmesolve">
<tt class="descname">fmmesolve</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>c_ops</em>, <em>e_ops=</em>, <span class="optional">[</span><span class="optional">]</span><em>spectra_cb=</em>, <span class="optional">[</span><span class="optional">]</span><em>T=None</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f68454d0&gt;</em>, <em>floquet_basis=True</em>, <em>kmax=5</em><big>)</big><a class="headerlink" href="#qutip.floquet.fmmesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the dynamics for the system using the Floquet-Markov master equation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This solver currently does not support multiple collapse operators.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0 / psi0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> / callback function</p>
<blockquote>
<div><p>list of operators for which to evaluate expectation values.</p>
</div></blockquote>
<p><strong>spectra_cb</strong> : list callback functions</p>
<blockquote>
<div><p>List of callback functions that compute the noise power spectrum as
a function of frequency for the collapse operators in <cite>c_ops</cite>.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian. The default value
&#8216;None&#8217; indicates that the &#8216;tlist&#8217; spans a single period of the driving.</p>
</div></blockquote>
<p><strong>args</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
<p>This dictionary should also contain an entry &#8216;w_th&#8217;, which is
the temperature of the environment (if finite) in the
energy/frequency units of the Hamiltonian.  For example, if
the Hamiltonian written in units of 2pi GHz, and the
temperature is given in K, use the following conversion</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">temperature</span> <span class="o">=</span> <span class="mf">25e-3</span> <span class="c"># unit K</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="mf">6.626e-34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kB</span> <span class="o">=</span> <span class="mf">1.38e-23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">[</span><span class="s">&#39;w_th&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temperature</span> <span class="o">*</span> <span class="p">(</span><span class="n">kB</span> <span class="o">/</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="mf">1e-9</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>options</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt></p>
<blockquote>
<div><p>options for the ODE solver.</p>
</div></blockquote>
<p><strong>k_max</strong> : int</p>
<blockquote>
<div><p>The truncation of the number of sidebands (default 5).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt></p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver</span></tt>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes">
<tt class="descname">floquet_modes</tt><big>(</big><em>H</em>, <em>T</em>, <em>args=None</em>, <em>sort=False</em>, <em>U=None</em><big>)</big><a class="headerlink" href="#qutip.floquet.floquet_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the initial Floquet modes Phi_alpha(0) for a driven system with
period T.</p>
<p>Returns a list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> instances representing the Floquet
modes and a list of corresponding quasienergies, sorted by increasing
quasienergy in the interval [-pi/T, pi/T]. The optional parameter <cite>sort</cite>
decides if the output is to be sorted in increasing quasienergies or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>dictionary with variables required to evaluate H</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian. The default value
&#8216;None&#8217; indicates that the &#8216;tlist&#8217; spans a single period of the driving.</p>
</div></blockquote>
<p><strong>U</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>The propagator for the time-dependent Hamiltonian with period <cite>T</cite>.
If U is <cite>None</cite> (default), it will be calculated from the Hamiltonian
<cite>H</cite> using <a class="reference internal" href="#qutip.propagator.propagator" title="qutip.propagator.propagator"><tt class="xref py py-func docutils literal"><span class="pre">qutip.propagator.propagator</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : list of kets, list of quasi energies</p>
<blockquote class="last">
<div><p>Two lists: the Floquet modes as kets and the quasi energies.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_t">
<tt class="descname">floquet_modes_t</tt><big>(</big><em>f_modes_0</em>, <em>f_energies</em>, <em>t</em>, <em>H</em>, <em>T</em>, <em>args=None</em><big>)</big><a class="headerlink" href="#qutip.floquet.floquet_modes_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the
initial Floquet modes Phi_alpha(0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_0</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> (kets)</p>
<blockquote>
<div><p>Floquet modes at <span class="math">\(t\)</span></p>
</div></blockquote>
<p><strong>f_energies</strong> : list</p>
<blockquote>
<div><p>Floquet energies.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>The time at which to evaluate the floquet modes.</p>
</div></blockquote>
<p><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>dictionary with variables required to evaluate H</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : list of kets</p>
<blockquote class="last">
<div><p>The Floquet modes as kets at time <span class="math">\(t\)</span></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_table">
<tt class="descname">floquet_modes_table</tt><big>(</big><em>f_modes_0</em>, <em>f_energies</em>, <em>tlist</em>, <em>H</em>, <em>T</em>, <em>args=None</em><big>)</big><a class="headerlink" href="#qutip.floquet.floquet_modes_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-calculate the Floquet modes for a range of times spanning the floquet
period. Can later be used as a table to look up the floquet modes for
any time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_0</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> (kets)</p>
<blockquote>
<div><p>Floquet modes at <span class="math">\(t\)</span></p>
</div></blockquote>
<p><strong>f_energies</strong> : list</p>
<blockquote>
<div><p>Floquet energies.</p>
</div></blockquote>
<p><strong>tlist</strong> : array</p>
<blockquote>
<div><p>The list of times at which to evaluate the floquet modes.</p>
</div></blockquote>
<p><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian, time-dependent with period <cite>T</cite></p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>dictionary with variables required to evaluate H</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : nested list</p>
<blockquote class="last">
<div><p>A nested list of Floquet modes as kets for each time in <cite>tlist</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_t_lookup">
<tt class="descname">floquet_modes_t_lookup</tt><big>(</big><em>f_modes_table_t</em>, <em>t</em>, <em>T</em><big>)</big><a class="headerlink" href="#qutip.floquet.floquet_modes_t_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Lookup the floquet mode at time t in the pre-calculated table of floquet
modes in the first period of the time-dependence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_table_t</strong> : nested list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> (kets)</p>
<blockquote>
<div><p>A lookup-table of Floquet modes at times precalculated by
<a class="reference internal" href="#qutip.floquet.floquet_modes_table" title="qutip.floquet.floquet_modes_table"><tt class="xref py py-func docutils literal"><span class="pre">qutip.floquet.floquet_modes_table</span></tt></a>.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>The time for which to evaluate the Floquet modes.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : nested list</p>
<blockquote class="last">
<div><p>A list of Floquet modes as kets for the time that most closely matching
the time <cite>t</cite> in the supplied table of Floquet modes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_states_t">
<tt class="descname">floquet_states_t</tt><big>(</big><em>f_modes_0</em>, <em>f_energies</em>, <em>t</em>, <em>H</em>, <em>T</em>, <em>args=None</em><big>)</big><a class="headerlink" href="#qutip.floquet.floquet_states_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the floquet states at time t given the initial Floquet modes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_t</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> (kets)</p>
<blockquote>
<div><p>A list of initial Floquet modes (for time <span class="math">\(t=0\)</span>).</p>
</div></blockquote>
<p><strong>f_energies</strong> : array</p>
<blockquote>
<div><p>The Floquet energies.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>The time for which to evaluate the Floquet states.</p>
</div></blockquote>
<p><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>Dictionary with variables required to evaluate H.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : list</p>
<blockquote class="last">
<div><p>A list of Floquet states for the time <span class="math">\(t\)</span>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_wavefunction_t">
<tt class="descname">floquet_wavefunction_t</tt><big>(</big><em>f_modes_0</em>, <em>f_energies</em>, <em>f_coeff</em>, <em>t</em>, <em>H</em>, <em>T</em>, <em>args=None</em><big>)</big><a class="headerlink" href="#qutip.floquet.floquet_wavefunction_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the wavefunction for a time t using the Floquet state
decompositon, given the initial Floquet modes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_modes_t</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> (kets)</p>
<blockquote>
<div><p>A list of initial Floquet modes (for time <span class="math">\(t=0\)</span>).</p>
</div></blockquote>
<p><strong>f_energies</strong> : array</p>
<blockquote>
<div><p>The Floquet energies.</p>
</div></blockquote>
<p><strong>f_coeff</strong> : array</p>
<blockquote>
<div><p>The coefficients for Floquet decomposition of the initial wavefunction.</p>
</div></blockquote>
<p><strong>t</strong> : float</p>
<blockquote>
<div><p>The time for which to evaluate the Floquet states.</p>
</div></blockquote>
<p><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>Dictionary with variables required to evaluate H.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote class="last">
<div><p>The wavefunction for the time <span class="math">\(t\)</span>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_state_decomposition">
<tt class="descname">floquet_state_decomposition</tt><big>(</big><em>f_states</em>, <em>f_energies</em>, <em>psi</em><big>)</big><a class="headerlink" href="#qutip.floquet.floquet_state_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose the wavefunction <cite>psi</cite> (typically an initial state) in terms of
the Floquet states, <span class="math">\(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>f_states</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> (kets)</p>
<blockquote>
<div><p>A list of Floquet modes.</p>
</div></blockquote>
<p><strong>f_energies</strong> : array</p>
<blockquote>
<div><p>The Floquet energies.</p>
</div></blockquote>
<p><strong>psi</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>The wavefunction to decompose in the Floquet state basis.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : array</p>
<blockquote class="last">
<div><p>The coefficients <span class="math">\(c_\alpha\)</span> in the Floquet state decomposition.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.fsesolve">
<tt class="descname">fsesolve</tt><big>(</big><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>e_ops=</em>, <span class="optional">[</span><span class="optional">]</span><em>T=None</em>, <em>args={}</em>, <em>Tsteps=100</em><big>)</big><a class="headerlink" href="#qutip.floquet.fsesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the Schrodinger equation using the Floquet formalism.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</div></blockquote>
<p><strong>psi0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>Initial state vector (ket).</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt> / callback function</p>
<blockquote>
<div><p>list of operators for which to evaluate expectation values. If this
list is empty, the state vectors for each time in <cite>tlist</cite> will be
returned instead of expectation values.</p>
</div></blockquote>
<p><strong>T</strong> : float</p>
<blockquote>
<div><p>The period of the time-dependence of the hamiltonian.</p>
</div></blockquote>
<p><strong>args</strong> : dictionary</p>
<blockquote>
<div><p>Dictionary with variables required to evaluate H.</p>
</div></blockquote>
<p><strong>Tsteps</strong> : integer</p>
<blockquote>
<div><p>The number of time steps in one driving period for which to
precalculate the Floquet modes. <cite>Tsteps</cite> should be an even number.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></tt></a></p>
<blockquote class="last">
<div><p>An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></tt></a>, which
contains either an <em>array</em> of expectation values or an array of
state vectors, for the times specified by <cite>tlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.stochastic">
<span id="stochastic-schrodinger-equation-and-master-equation"></span><h3>Stochastic Schrödinger Equation and Master Equation<a class="headerlink" href="#module-qutip.stochastic" title="Permalink to this headline">¶</a></h3>
<p>This module contains experimental functions for solving stochastic schrodinger
and master equations. The API should not be considered stable, and is subject
to change when we work more on optimizing this module for performance and
features.</p>
<p>Todo:</p>
<blockquote>
<div><ul class="simple">
<li>parallelize</li>
</ul>
</div></blockquote>
<dl class="function">
<dt id="qutip.stochastic.smesolve">
<tt class="descname">smesolve</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>times</em>, <em>c_ops</em>, <em>sc_ops</em>, <em>e_ops</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#qutip.stochastic.smesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic master equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Initial density matrix or state vector (ket).</p>
</div></blockquote>
<p><strong>times</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>. Must be uniformly spaced.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</div></blockquote>
<p><strong>sc_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>kwargs</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><tt class="xref py py-class docutils literal"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output: :class:`qutip.solver.SolverResult`</strong> :</p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.ssesolve">
<tt class="descname">ssesolve</tt><big>(</big><em>H</em>, <em>psi0</em>, <em>times</em>, <em>sc_ops</em>, <em>e_ops</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#qutip.stochastic.ssesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic Schrödinger equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>psi0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Initial state vector (ket).</p>
</div></blockquote>
<p><strong>times</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>. Must be uniformly spaced.</p>
</div></blockquote>
<p><strong>sc_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the equation of motion according to how the d1 and d2 functions
are defined.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>kwargs</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><tt class="xref py py-class docutils literal"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output: :class:`qutip.solver.SolverResult`</strong> :</p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.smepdpsolve">
<tt class="descname">smepdpsolve</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>times</em>, <em>c_ops</em>, <em>e_ops</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#qutip.stochastic.smepdpsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>A stochastic (piecewse deterministic process) PDP solver for density matrix
evolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Initial density matrix.</p>
</div></blockquote>
<p><strong>times</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>. Must be uniformly spaced.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</div></blockquote>
<p><strong>sc_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>kwargs</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><tt class="xref py py-class docutils literal"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output: :class:`qutip.solver.SolverResult`</strong> :</p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.ssepdpsolve">
<tt class="descname">ssepdpsolve</tt><big>(</big><em>H</em>, <em>psi0</em>, <em>times</em>, <em>c_ops</em>, <em>e_ops</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#qutip.stochastic.ssepdpsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>A stochastic (piecewse deterministic process) PDP solver for wavefunction
evolution. For most purposes, use <a class="reference internal" href="#module-qutip.mcsolve" title="qutip.mcsolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mcsolve</span></tt></a> instead for quantum
trajectory simulations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>psi0</strong> : <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Initial state vector (ket).</p>
</div></blockquote>
<p><strong>times</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>List of times for <span class="math">\(t\)</span>. Must be uniformly spaced.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a></p>
<blockquote>
<div><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</div></blockquote>
<p><strong>e_ops</strong> : list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><tt class="xref py py-class docutils literal"><span class="pre">qutip.Qobj</span></tt></a> / callback function single</p>
<blockquote>
<div><p>single operator or list of operators for which to evaluate
expectation values.</p>
</div></blockquote>
<p><strong>kwargs</strong> : <em>dictionary</em></p>
<blockquote>
<div><p>Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><tt class="xref py py-class docutils literal"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output: :class:`qutip.solver.SolverResult`</strong> :</p>
<blockquote class="last">
<div><p>An instance of the class <tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.SolverResult</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.correlation">
<span id="correlation-functions"></span><h3>Correlation Functions<a class="headerlink" href="#module-qutip.correlation" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.correlation.correlation">
<tt class="descname">correlation</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='me'</em>, <em>reverse=False</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f682fd88&gt;</em><big>)</big><a class="headerlink" href="#qutip.correlation.correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a two-operator two-time correlation function on the form
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span> or
<span class="math">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> (if <cite>reverse=True</cite>), using the
quantum regression theorem and the evolution solver indicated by the
<em>solver</em> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix (or state vector). If &#8216;rho0&#8217; is
&#8216;None&#8217;, then the steady state will be used as initial state.</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation,
<cite>es</cite> for exponential series and <cite>mc</cite> for Monte-carlo)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat: *array*</strong> :</p>
<blockquote class="last">
<div><p>An 2-dimensional <em>array</em> (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional <em>array</em> of correlation values
is returned instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_ss">
<tt class="descname">correlation_ss</tt><big>(</big><em>H</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>rho0=None</em>, <em>solver='me'</em>, <em>reverse=False</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f682fd40&gt;</em><big>)</big><a class="headerlink" href="#qutip.correlation.correlation_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a two-operator two-time correlation function
<span class="math">\(\left&lt;A(\tau)B(0)\right&gt;\)</span> or
<span class="math">\(\left&lt;A(0)B(\tau)\right&gt;\)</span> (if <cite>reverse=True</cite>),
using the quantum regression theorem and the evolution solver indicated by
the <em>solver</em> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix (or state vector). If &#8216;rho0&#8217; is
&#8216;None&#8217;, then the steady state will be used as initial state.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>reverse</strong> : bool</p>
<blockquote>
<div><p>If <cite>True</cite>, calculate <span class="math">\(\left&lt;A(0)B(\tau)\right&gt;\)</span> instead of
<span class="math">\(\left&lt;A(\tau)B(0)\right&gt;\)</span>.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation,
<cite>es</cite> for exponential series and <cite>mc</cite> for Monte-carlo)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_vec: *array*</strong> :</p>
<blockquote class="last">
<div><p>An <em>array</em> of correlation values for the times specified by <cite>tlist</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_2op_1t">
<tt class="descname">correlation_2op_1t</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='me'</em>, <em>reverse=False</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f682fb90&gt;</em><big>)</big><a class="headerlink" href="#qutip.correlation.correlation_2op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a two-operator two-time correlation function
<span class="math">\(\left&lt;A(\tau)B(0)\right&gt;\)</span> or
<span class="math">\(\left&lt;A(0)B(\tau)\right&gt;\)</span> (if <cite>reverse=True</cite>),
using the quantum regression theorem and the evolution solver indicated by
the <em>solver</em> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix (or state vector). If <cite>rho0</cite> is
<cite>None</cite>, then the steady state will be used as initial state.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>reverse</strong> : bool</p>
<blockquote>
<div><p>If <cite>True</cite>, calculate <span class="math">\(\left&lt;A(0)B(\tau)\right&gt;\)</span> instead of
<span class="math">\(\left&lt;A(\tau)B(0)\right&gt;\)</span>.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation,
<cite>es</cite> for exponential series and <cite>mc</cite> for Monte-carlo)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_vec: *array*</strong> :</p>
<blockquote class="last">
<div><p>An <em>array</em> of correlation values for the times specified by <cite>taulist</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_2op_2t">
<tt class="descname">correlation_2op_2t</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='me'</em>, <em>reverse=False</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f682fbd8&gt;</em><big>)</big><a class="headerlink" href="#qutip.correlation.correlation_2op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate a two-operator two-time correlation function on the form
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span> or
<span class="math">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> (if <cite>reverse=True</cite>), using the
quantum regression theorem and the evolution solver indicated by the
<em>solver</em> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix <span class="math">\(\rho(t_0)\)</span> (or state vector). If
&#8216;rho0&#8217; is &#8216;None&#8217;, then the steady state will be used as initial state.</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (<cite>me</cite> for master-equation,
<cite>es</cite> for exponential series and <cite>mc</cite> for Monte-carlo)</p>
</div></blockquote>
<p><strong>reverse</strong> : bool</p>
<blockquote>
<div><p>If <cite>True</cite>, calculate <span class="math">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat: *array*</strong> :</p>
<blockquote class="last">
<div><p>An 2-dimensional <em>array</em> (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional <em>array</em> of correlation values
is returned instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_4op_1t">
<tt class="descname">correlation_4op_1t</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>d_op</em>, <em>solver='me'</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f682fc20&gt;</em><big>)</big><a class="headerlink" href="#qutip.correlation.correlation_4op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the four-operator two-time correlation function on the from
<span class="math">\(\left&lt;A(0)B(\tau)C(\tau)D(0)\right&gt;\)</span> using the quantum regression
theorem and the solver indicated by the &#8216;solver&#8217; parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix (or state vector). If &#8216;rho0&#8217; is
&#8216;None&#8217;, then the steady state will be used as initial state.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>c_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator C.</p>
</div></blockquote>
<p><strong>d_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator D.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (currently only <cite>me</cite> for master-equation)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_vec: *array*</strong> :</p>
<blockquote class="last">
<div><p>An <em>array</em> of correlation values for the times specified by <cite>taulist</cite></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.1.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_4op_2t">
<tt class="descname">correlation_4op_2t</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>d_op</em>, <em>solver='me'</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f682fc68&gt;</em><big>)</big><a class="headerlink" href="#qutip.correlation.correlation_4op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the four-operator two-time correlation function on the from
<span class="math">\(\left&lt;A(t)B(t+\tau)C(t+\tau)D(t)\right&gt;\)</span> using the quantum
regression theorem and the solver indicated by the &#8216;solver&#8217; parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix (or state vector). If &#8216;rho0&#8217; is
&#8216;None&#8217;, then the steady state will be used as initial state.</p>
</div></blockquote>
<p><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(t\)</span>.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
<p><strong>c_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator C.</p>
</div></blockquote>
<p><strong>d_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>operator D.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (currently only <cite>me</cite> for master-equation)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>corr_mat: *array*</strong> :</p>
<blockquote class="last">
<div><p>An 2-dimensional <em>array</em> (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional <em>array</em> of correlation values
is returned instead.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.1.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_ss">
<tt class="descname">spectrum_ss</tt><big>(</big><em>H</em>, <em>wlist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em><big>)</big><a class="headerlink" href="#qutip.correlation.spectrum_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum corresponding to a correlation function
<span class="math">\(\left&lt;A(\tau)B(0)\right&gt;\)</span>, i.e., the Fourier transform of the
correlation function:</p>
<div class="math">
\[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left&lt;A(\tau)B(0)\right&gt;
e^{-i\omega\tau} d\tau.\end{split}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>wlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of frequencies for <span class="math">\(\omega\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>spectrum: *array*</strong> :</p>
<blockquote class="last">
<div><p>An <em>array</em> with spectrum <span class="math">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_pi">
<tt class="descname">spectrum_pi</tt><big>(</big><em>H</em>, <em>wlist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>use_pinv=False</em><big>)</big><a class="headerlink" href="#qutip.correlation.spectrum_pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum corresponding to a correlation function
<span class="math">\(\left&lt;A(\tau)B(0)\right&gt;\)</span>, i.e., the Fourier transform of the
correlation function:</p>
<div class="math">
\[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left&lt;A(\tau)B(0)\right&gt;
e^{-i\omega\tau} d\tau.\end{split}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>wlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of frequencies for <span class="math">\(\omega\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>operator A.</p>
</div></blockquote>
<p><strong>b_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj</span></tt></p>
<blockquote>
<div><p>operator B.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>s_vec: *array*</strong> :</p>
<blockquote class="last">
<div><p>An <em>array</em> with spectrum <span class="math">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_correlation_fft">
<tt class="descname">spectrum_correlation_fft</tt><big>(</big><em>tlist</em>, <em>y</em><big>)</big><a class="headerlink" href="#qutip.correlation.spectrum_correlation_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the power spectrum corresponding to a two-time correlation
function using FFT.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tlist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list/array of times <span class="math">\(t\)</span> which the correlation function is given.</p>
</div></blockquote>
<p><strong>y</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list/array of correlations corresponding to time delays <span class="math">\(t\)</span>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>w, S</strong> : <em>tuple</em></p>
<blockquote class="last">
<div><p>Returns an array of angular frequencies &#8216;w&#8217; and the corresponding
one-sided power spectrum &#8216;S(w)&#8217;.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.coherence_function_g1">
<tt class="descname">coherence_function_g1</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>solver='me'</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f682fcb0&gt;</em><big>)</big><a class="headerlink" href="#qutip.correlation.coherence_function_g1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the first-order quantum coherence function:</p>
<div class="math">
\[g^{(1)}(\tau) = \frac{\langle a^\dagger(\tau)a(0)\rangle}
{\sqrt{\langle a^\dagger(\tau)a(\tau)\rangle
\langle a^\dagger(0)a(0)\rangle}}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix (or state vector). If &#8216;rho0&#8217; is
&#8216;None&#8217;, then the steady state will be used as initial state.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>The annihilation operator of the mode.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (&#8216;me&#8217;, &#8216;mc&#8217;, &#8216;es&#8217;)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>g1, G2: tuble of *array*</strong> :</p>
<blockquote class="last">
<div><p>The normalized and unnormalized first-order coherence function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.coherence_function_g2">
<tt class="descname">coherence_function_g2</tt><big>(</big><em>H</em>, <em>rho0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>solver='me'</em>, <em>args=None</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f682fcf8&gt;</em><big>)</big><a class="headerlink" href="#qutip.correlation.coherence_function_g2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the second-order quantum coherence function:</p>
<div class="math">
\[g^{(2)}(\tau) =
\frac{\langle a^\dagger(0)a^\dagger(\tau)a(\tau)a(0)\rangle}
{\langle a^\dagger(\tau)a(\tau)\rangle
 \langle a^\dagger(0)a(0)\rangle}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>system Hamiltonian.</p>
</div></blockquote>
<p><strong>rho0</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>Initial state density matrix (or state vector). If &#8216;rho0&#8217; is
&#8216;None&#8217;, then the steady state will be used as initial state.</p>
</div></blockquote>
<p><strong>taulist</strong> : <em>list</em> / <em>array</em></p>
<blockquote>
<div><p>list of times for <span class="math">\(\tau\)</span>.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list of <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>list of collapse operators.</p>
</div></blockquote>
<p><strong>a_op</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>The annihilation operator of the mode.</p>
</div></blockquote>
<p><strong>solver</strong> : str</p>
<blockquote>
<div><p>choice of solver (currently only &#8216;me&#8217;)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>g2, G2: tuble of *array*</strong> :</p>
<blockquote class="last">
<div><p>The normalized and unnormalized second-order coherence function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.steadystate">
<span id="steady-state-solvers"></span><h3>Steady-state Solvers<a class="headerlink" href="#module-qutip.steadystate" title="Permalink to this headline">¶</a></h3>
<p>Module contains functions for solving for the steady state density matrix of
open quantum systems defined by a Liouvillian or Hamiltonian and a list of
collapse operators.</p>
<dl class="function">
<dt id="qutip.steadystate.steadystate">
<tt class="descname">steadystate</tt><big>(</big><em>A</em>, <em>c_op_list=</em>, <span class="optional">[</span><span class="optional">]</span><em>**kwargs</em><big>)</big><a class="headerlink" href="#qutip.steadystate.steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the steady state for quantum evolution subject to the
supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a
list of collapse operators.</p>
<p>If the user passes a Hamiltonian then it, along with the list of collapse
operators, will be converted into a Liouvillian operator in Lindblad form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj</p>
<blockquote>
<div><p>A Hamiltonian or Liouvillian operator.</p>
</div></blockquote>
<p><strong>c_op_list</strong> : list</p>
<blockquote>
<div><p>A list of collapse operators.</p>
</div></blockquote>
<p><strong>method</strong> : str {&#8216;direct&#8217;, &#8216;eigen&#8217;, &#8216;iterative-bicg&#8217;,</p>
<blockquote>
<div><blockquote>
<div><p>&#8216;iterative-gmres&#8217;, &#8216;svd&#8217;, &#8216;power&#8217;}</p>
</div></blockquote>
<p>Method for solving the underlying linear equation. Direct LU solver
&#8216;direct&#8217; (default), sparse eigenvalue problem &#8216;eigen&#8217;,
iterative GMRES method &#8216;iterative-gmres&#8217;, iterative LGMRES method
&#8216;iterative-lgmres&#8217;, SVD &#8216;svd&#8217; (dense), or inverse-power method &#8216;power&#8217;.</p>
</div></blockquote>
<p><strong>sparse</strong> : bool, optional, default=True</p>
<blockquote>
<div><p>Solve for the steady state using sparse algorithms. If set to False,
the underlying Liouvillian operator will be converted into a dense
matrix. Use only for &#8216;smaller&#8217; systems.</p>
</div></blockquote>
<p><strong>use_rcm</strong> : bool, optional, default=True</p>
<blockquote>
<div><p>Use reverse Cuthill-Mckee reordering to minimize fill-in in the
LU factorization of the Liouvillian.</p>
</div></blockquote>
<p><strong>use_wbm</strong> : bool, optional, default=False</p>
<blockquote>
<div><p>Use Weighted Bipartite Matching reordering to make the Liouvillian
diagonally dominant.  This is useful for iterative preconditioners
only, and is set to <tt class="docutils literal"><span class="pre">True</span></tt> by default when finding a preconditioner.</p>
</div></blockquote>
<p><strong>weight</strong> : float, optional</p>
<blockquote>
<div><p>Sets the size of the elements used for adding the unity trace condition
to the linear solvers.  This is set to the average abs value of the
Liouvillian elements if not specified by the user.</p>
</div></blockquote>
<p><strong>use_umfpack</strong> : bool {False, True}</p>
<blockquote>
<div><p>Use umfpack solver instead of SuperLU.  For SciPy 0.14+, this option
requires installing scikits.umfpack.</p>
</div></blockquote>
<p><strong>maxiter</strong> : int, optional, default=10000</p>
<blockquote>
<div><p>Maximum number of iterations to perform if using an iterative method.</p>
</div></blockquote>
<p><strong>tol</strong> : float, optional, default=1e-9</p>
<blockquote>
<div><p>Tolerance used for terminating solver solution when using iterative
solvers.</p>
</div></blockquote>
<p><strong>permc_spec</strong> : str, optional, default=&#8217;COLAMD&#8217;</p>
<blockquote>
<div><p>Column ordering used internally by superLU for the &#8216;direct&#8217; LU
decomposition method. Options include &#8216;COLAMD&#8217; and &#8216;NATURAL&#8217;.
If using RCM then this is set to &#8216;NATURAL&#8217; automatically unless
explicitly specified.</p>
</div></blockquote>
<p><strong>use_precond</strong> : bool optional, default = True</p>
<blockquote>
<div><p>ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a
preconditioner for the &#8216;iterative&#8217; GMRES and BICG solvers.
Speeds up convergence time by orders of magnitude in many cases.</p>
</div></blockquote>
<p><strong>M</strong> : {sparse matrix, dense matrix, LinearOperator}, optional</p>
<blockquote>
<div><p>Preconditioner for A. The preconditioner should approximate the inverse
of A. Effective preconditioning dramatically improves the rate of
convergence, for iterative methods only .  If no preconditioner is
given and <tt class="docutils literal"><span class="pre">use_precond=True</span></tt>, then one is generated automatically.</p>
</div></blockquote>
<p><strong>fill_factor</strong> : float, optional, default=10</p>
<blockquote>
<div><p>ITERATIVE ONLY. Specifies the fill ratio upper bound (&gt;=1) of the iLU
preconditioner.  Lower values save memory at the cost of longer
execution times and a possible singular factorization.</p>
</div></blockquote>
<p><strong>drop_tol</strong> : float, optional, default=1e-3</p>
<blockquote>
<div><p>ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner
elements that should be dropped.  Can be reduced for a courser
factorization at the cost of an increased number of iterations, and a
possible singular factorization.</p>
</div></blockquote>
<p><strong>diag_pivot_thresh</strong> : float, optional, default=None</p>
<blockquote>
<div><p>ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal
elements are considered acceptable pivot points when using a
preconditioner.  A value of zero forces the pivot to be the diagonal
element.</p>
</div></blockquote>
<p><strong>ILU_MILU</strong> : str, optional, default=&#8217;smilu_2&#8217;</p>
<blockquote>
<div><p>Selects the incomplete LU decomposition method algoithm used in
creating the preconditoner. Should only be used by advanced users.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dm</strong> : qobj</p>
<blockquote class="last">
<div><p>Steady state density matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The SVD method works only for dense operators (i.e. small systems).</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.propagator">
<span id="propagators"></span><h3>Propagators<a class="headerlink" href="#module-qutip.propagator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.propagator.propagator">
<tt class="descname">propagator</tt><big>(</big><em>H</em>, <em>t</em>, <em>c_op_list</em>, <em>args=None</em>, <em>options=None</em>, <em>sparse=False</em><big>)</big><a class="headerlink" href="#qutip.propagator.propagator" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator U(t) for the density matrix or wave function such
that <span class="math">\(\psi(t) = U(t)\psi(0)\)</span> or
<span class="math">\(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\)</span>
where <span class="math">\(\rho_{\mathrm vec}\)</span> is the vector representation of the
density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj or list</p>
<blockquote>
<div><p>Hamiltonian as a Qobj instance of a nested list of Qobjs and
coefficients in the list-string or list-function format for
time-dependent Hamiltonians (see description in <a class="reference internal" href="#module-qutip.mesolve" title="qutip.mesolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mesolve</span></tt></a>).</p>
</div></blockquote>
<p><strong>t</strong> : float or array-like</p>
<blockquote>
<div><p>Time or list of times for which to evaluate the propagator.</p>
</div></blockquote>
<p><strong>c_op_list</strong> : list</p>
<blockquote>
<div><p>List of qobj collapse operators.</p>
</div></blockquote>
<p><strong>args</strong> : list/array/dictionary</p>
<blockquote>
<div><p>Parameters to callback functions for time-dependent Hamiltonians and
collapse operators.</p>
</div></blockquote>
<p><strong>options</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.Options</span></tt></p>
<blockquote>
<div><p>with options for the ODE solver.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>a</strong> : qobj</p>
<blockquote class="last">
<div><p>Instance representing the propagator <span class="math">\(U(t)\)</span>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.propagator.propagator_steadystate">
<tt class="descname">propagator_steadystate</tt><big>(</big><em>U</em><big>)</big><a class="headerlink" href="#qutip.propagator.propagator_steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the steady state for successive applications of the propagator
<span class="math">\(U\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : qobj</p>
<blockquote>
<div><p>Operator representing the propagator.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>a</strong> : qobj</p>
<blockquote class="last">
<div><p>Instance representing the steady-state density matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip">
<span id="time-dependent-problems"></span><h3>Time-dependent problems<a class="headerlink" href="#module-qutip" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.rhs_generate">
<tt class="descname">rhs_generate</tt><big>(</big><em>H</em>, <em>c_ops</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options instance at 0x2b11f5a5c950&gt;</em>, <em>name=None</em>, <em>cleanup=True</em><big>)</big><a class="headerlink" href="#qutip.rhs_generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the Cython functions needed for solving the dynamics of a
given system using the mesolve function inside a parfor loop.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H</strong> : qobj</p>
<blockquote>
<div><p>System Hamiltonian.</p>
</div></blockquote>
<p><strong>c_ops</strong> : list</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> of collapse operators.</p>
</div></blockquote>
<p><strong>args</strong> : dict</p>
<blockquote>
<div><p>Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</div></blockquote>
<p><strong>options</strong> : Options</p>
<blockquote>
<div><p>Instance of ODE solver options.</p>
</div></blockquote>
<p><strong>name: str</strong> :</p>
<blockquote>
<div><p>Name of generated RHS</p>
</div></blockquote>
<p><strong>cleanup: bool</strong> :</p>
<blockquote class="last">
<div><p>Whether the generated cython file should be automatically removed or
not.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Using this function with any solver other than the mesolve function
will result in an error.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.rhs_clear">
<tt class="descname">rhs_clear</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.rhs_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the string-format time-dependent Hamiltonian parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>Nothing, just clears data from internal config module.</strong> :</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.wigner">
<span id="pseudoprobability-functions"></span><h3>Pseudoprobability Functions<a class="headerlink" href="#module-qutip.wigner" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.wigner.qfunc">
<tt class="descname">qfunc</tt><big>(</big><em>state</em>, <em>xvec</em>, <em>yvec</em>, <em>g=1.4142135623730951</em><big>)</big><a class="headerlink" href="#qutip.wigner.qfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Q-function of a given state vector or density matrix
at points <cite>xvec + i * yvec</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote>
<div><p>A state vector or density matrix.</p>
</div></blockquote>
<p><strong>xvec</strong> : array_like</p>
<blockquote>
<div><p>x-coordinates at which to calculate the Wigner function.</p>
</div></blockquote>
<p><strong>yvec</strong> : array_like</p>
<blockquote>
<div><p>y-coordinates at which to calculate the Wigner function.</p>
</div></blockquote>
<p><strong>g</strong> : float</p>
<blockquote>
<div><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Q</strong> : array</p>
<blockquote class="last">
<div><p>Values representing the Q-function calculated over the specified range
[xvec,yvec].</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.wigner.wigner">
<tt class="descname">wigner</tt><big>(</big><em>psi</em>, <em>xvec</em>, <em>yvec</em>, <em>method='iterative'</em>, <em>g=1.4142135623730951</em>, <em>parfor=False</em><big>)</big><a class="headerlink" href="#qutip.wigner.wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Wigner function for a state vector or density matrix at points
<cite>xvec + i * yvec</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>state</strong> : qobj</p>
<blockquote>
<div><p>A state vector or density matrix.</p>
</div></blockquote>
<p><strong>xvec</strong> : array_like</p>
<blockquote>
<div><p>x-coordinates at which to calculate the Wigner function.</p>
</div></blockquote>
<p><strong>yvec</strong> : array_like</p>
<blockquote>
<div><p>y-coordinates at which to calculate the Wigner function.  Does not
apply to the &#8216;fft&#8217; method.</p>
</div></blockquote>
<p><strong>g</strong> : float</p>
<blockquote>
<div><p>Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.</p>
</div></blockquote>
<p><strong>method</strong> : string {&#8216;iterative&#8217;, &#8216;laguerre&#8217;, &#8216;fft&#8217;}</p>
<blockquote>
<div><p>Select method &#8216;iterative&#8217;, &#8216;laguerre&#8217;, or &#8216;fft&#8217;, where &#8216;iterative&#8217; uses
an iterative method to evaluate the Wigner functions for density
matrices <span class="math">\(|m&gt;&lt;n|\)</span>, while &#8216;laguerre&#8217; uses the Laguerre polynomials
in scipy for the same task. The &#8216;fft&#8217; method evaluates the Fourier
transform of the density matrix. The &#8216;iterative&#8217; method is default, and
in general recommended, but the &#8216;laguerre&#8217; method is more efficient for
very sparse density matrices (e.g., superpositions of Fock states in a
large Hilbert space). The &#8216;fft&#8217; method is the preferred method for
dealing with density matrices that have a large number of excitations
(&gt;~50).</p>
</div></blockquote>
<p><strong>parfor</strong> : bool {False, True}</p>
<blockquote>
<div><p>Flag for calculating the Laguerre polynomial based Wigner function
method=&#8217;laguerre&#8217; in parallel using the parfor function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>W</strong> : array</p>
<blockquote>
<div><p>Values representing the Wigner function calculated over the specified
range [xvec,yvec].</p>
</div></blockquote>
<p><strong>yvex</strong> : array</p>
<blockquote class="last">
<div><p>FFT ONLY. Returns the y-coordinate values calculated via the Fourier
transform.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The &#8216;fft&#8217; method accepts only an xvec input for the x-coordinate.
The y-coordinates are calculated internally.</p>
<p class="rubric">References</p>
<p>Ulf Leonhardt,
Measuring the Quantum State of Light, (Cambridge University Press, 1997)</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.visualization">
<span id="graphs-and-visualization"></span><h3>Graphs and Visualization<a class="headerlink" href="#module-qutip.visualization" title="Permalink to this headline">¶</a></h3>
<p>Functions for visualizing results of quantum dynamics simulations,
visualizations of quantum states and processes.</p>
<dl class="function">
<dt id="qutip.visualization.hinton">
<tt class="descname">hinton</tt><big>(</big><em>rho</em>, <em>xlabels=None</em>, <em>ylabels=None</em>, <em>title=None</em>, <em>ax=None</em><big>)</big><a class="headerlink" href="#qutip.visualization.hinton" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a Hinton diagram for visualizing a density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : qobj</p>
<blockquote>
<div><p>Input density matrix.</p>
</div></blockquote>
<p><strong>xlabels</strong> : list of strings</p>
<blockquote>
<div><p>list of x labels</p>
</div></blockquote>
<p><strong>ylabels</strong> : list of strings</p>
<blockquote>
<div><p>list of y labels</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>title of the plot (optional)</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote>
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>Input argument is not a quantum object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.matrix_histogram">
<tt class="descname">matrix_histogram</tt><big>(</big><em>M</em>, <em>xlabels=None</em>, <em>ylabels=None</em>, <em>title=None</em>, <em>limits=None</em>, <em>colorbar=True</em>, <em>fig=None</em>, <em>ax=None</em><big>)</big><a class="headerlink" href="#qutip.visualization.matrix_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram for the matrix M, with the given x and y labels and title.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>M</strong> : Matrix of Qobj</p>
<blockquote>
<div><p>The matrix to visualize</p>
</div></blockquote>
<p><strong>xlabels</strong> : list of strings</p>
<blockquote>
<div><p>list of x labels</p>
</div></blockquote>
<p><strong>ylabels</strong> : list of strings</p>
<blockquote>
<div><p>list of y labels</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>title of the plot (optional)</p>
</div></blockquote>
<p><strong>limits</strong> : list/array with two float numbers</p>
<blockquote>
<div><p>The z-axis limits [min, max] (optional)</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote>
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>Input argument is not valid.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.matrix_histogram_complex">
<tt class="descname">matrix_histogram_complex</tt><big>(</big><em>M</em>, <em>xlabels=None</em>, <em>ylabels=None</em>, <em>title=None</em>, <em>limits=None</em>, <em>phase_limits=None</em>, <em>colorbar=True</em>, <em>fig=None</em>, <em>ax=None</em>, <em>threshold=None</em><big>)</big><a class="headerlink" href="#qutip.visualization.matrix_histogram_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram for the amplitudes of matrix M, using the argument
of each element for coloring the bars, with the given x and y labels
and title.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>M</strong> : Matrix of Qobj</p>
<blockquote>
<div><p>The matrix to visualize</p>
</div></blockquote>
<p><strong>xlabels</strong> : list of strings</p>
<blockquote>
<div><p>list of x labels</p>
</div></blockquote>
<p><strong>ylabels</strong> : list of strings</p>
<blockquote>
<div><p>list of y labels</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>title of the plot (optional)</p>
</div></blockquote>
<p><strong>limits</strong> : list/array with two float numbers</p>
<blockquote>
<div><p>The z-axis limits [min, max] (optional)</p>
</div></blockquote>
<p><strong>phase_limits</strong> : list/array with two float numbers</p>
<blockquote>
<div><p>The phase-axis (colorbar) limits [min, max] (optional)</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>threshold: float (None)</strong> :</p>
<blockquote>
<div><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote>
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>Input argument is not valid.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_energy_levels">
<tt class="descname">plot_energy_levels</tt><big>(</big><em>H_list</em>, <em>N=0</em>, <em>labels=None</em>, <em>show_ylabels=False</em>, <em>figsize=(8</em>, <em>12)</em>, <em>fig=None</em>, <em>ax=None</em><big>)</big><a class="headerlink" href="#qutip.visualization.plot_energy_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the energy level diagrams for a list of Hamiltonians. Include
up to N energy levels. For each element in H_list, the energy
levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,
where n is the index of an element in H_list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>H_list</strong> : List of Qobj</p>
<blockquote>
<div><blockquote>
<div><p>A list of Hamiltonians.</p>
</div></blockquote>
<dl class="docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">List of string</span></dt>
<dd><p class="first last">A list of labels for each Hamiltonian</p>
</dd>
<dt>show_ylabels <span class="classifier-delimiter">:</span> <span class="classifier">Bool (default False)</span></dt>
<dd><p class="first last">Show y labels to the left of energy levels of the initial
Hamiltonian.</p>
</dd>
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of energy levels to plot</p>
</dd>
<dt>figsize <span class="classifier-delimiter">:</span> <span class="classifier">tuple (int,int)</span></dt>
<dd><p class="first last">The size of the figure (width, height).</p>
</dd>
<dt>fig <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib Figure instance</span></dt>
<dd><p class="first last">The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt>ax <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axes instance</span></dt>
<dd><p class="first last">The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote>
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>Input argument is not valid.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.wigner_cmap">
<tt class="descname">wigner_cmap</tt><big>(</big><em>W</em>, <em>levels=1024</em>, <em>shift=0</em>, <em>invert=False</em><big>)</big><a class="headerlink" href="#qutip.visualization.wigner_cmap" title="Permalink to this definition">¶</a></dt>
<dd><p>A custom colormap that emphasizes negative values by creating a
nonlinear colormap.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>W</strong> : array</p>
<blockquote>
<div><p>Wigner function array, or any array.</p>
</div></blockquote>
<p><strong>levels</strong> : int</p>
<blockquote>
<div><p>Number of color levels to create.</p>
</div></blockquote>
<p><strong>shift</strong> : float</p>
<blockquote>
<div><p>Shifts the value at which Wigner elements are emphasized.
This parameter should typically be negative and small (i.e -5e-3).</p>
</div></blockquote>
<p><strong>invert</strong> : bool</p>
<blockquote>
<div><p>Invert the color scheme for negative values so that smaller negative
values have darker color.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>Returns a Matplotlib colormap instance for use in plotting.</strong> :</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The &#8216;shift&#8217; parameter allows you to vary where the colormap begins
to highlight negative colors. This is beneficial in cases where there
are small negative Wigner elements due to numerical round-off and/or
truncation.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_fock_distribution">
<tt class="descname">plot_fock_distribution</tt><big>(</big><em>rho</em>, <em>offset=0</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>6)</em>, <em>title=None</em>, <em>unit_y_range=True</em><big>)</big><a class="headerlink" href="#qutip.visualization.plot_fock_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Fock distribution for a density matrix (or ket) that describes
an oscillator mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>The density matrix (or ket) of the state to visualize.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>An optional title for the figure.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_wigner_fock_distribution">
<tt class="descname">plot_wigner_fock_distribution</tt><big>(</big><em>rho</em>, <em>fig=None</em>, <em>axes=None</em>, <em>figsize=(8</em>, <em>4)</em>, <em>cmap=None</em>, <em>alpha_max=7.5</em>, <em>colorbar=False</em>, <em>method='iterative'</em>, <em>projection='2d'</em><big>)</big><a class="headerlink" href="#qutip.visualization.plot_wigner_fock_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Fock distribution and the Wigner function for a density matrix
(or ket) that describes an oscillator mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>The density matrix (or ket) of the state to visualize.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>axes</strong> : a list of two matplotlib axes instances</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
<p><strong>cmap</strong> : a matplotlib cmap instance</p>
<blockquote>
<div><p>The colormap.</p>
</div></blockquote>
<p><strong>alpha_max</strong> : float</p>
<blockquote>
<div><p>The span of the x and y coordinates (both [-alpha_max, alpha_max]).</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</div></blockquote>
<p><strong>method</strong> : string {&#8216;iterative&#8217;, &#8216;laguerre&#8217;, &#8216;fft&#8217;}</p>
<blockquote>
<div><p>The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</div></blockquote>
<p><strong>projection: string {&#8216;2d&#8217;, &#8216;3d&#8217;}</strong> :</p>
<blockquote>
<div><p>Specify whether the Wigner function is to be plotted as a
contour graph (&#8216;2d&#8217;) or surface plot (&#8216;3d&#8217;).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_wigner">
<tt class="descname">plot_wigner</tt><big>(</big><em>rho</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>4)</em>, <em>cmap=None</em>, <em>alpha_max=7.5</em>, <em>colorbar=False</em>, <em>method='iterative'</em>, <em>projection='2d'</em><big>)</big><a class="headerlink" href="#qutip.visualization.plot_wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the the Wigner function for a density matrix (or ket) that describes
an oscillator mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rho</strong> : <tt class="xref py py-class docutils literal"><span class="pre">qutip.qobj.Qobj</span></tt></p>
<blockquote>
<div><p>The density matrix (or ket) of the state to visualize.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
<p><strong>cmap</strong> : a matplotlib cmap instance</p>
<blockquote>
<div><p>The colormap.</p>
</div></blockquote>
<p><strong>alpha_max</strong> : float</p>
<blockquote>
<div><p>The span of the x and y coordinates (both [-alpha_max, alpha_max]).</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</div></blockquote>
<p><strong>method</strong> : string {&#8216;iterative&#8217;, &#8216;laguerre&#8217;, &#8216;fft&#8217;}</p>
<blockquote>
<div><p>The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</div></blockquote>
<p><strong>projection: string {&#8216;2d&#8217;, &#8216;3d&#8217;}</strong> :</p>
<blockquote>
<div><p>Specify whether the Wigner function is to be plotted as a
contour graph (&#8216;2d&#8217;) or surface plot (&#8216;3d&#8217;).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.sphereplot">
<tt class="descname">sphereplot</tt><big>(</big><em>theta</em>, <em>phi</em>, <em>values</em>, <em>fig=None</em>, <em>ax=None</em>, <em>save=False</em><big>)</big><a class="headerlink" href="#qutip.visualization.sphereplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a matrix of values on a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : float</p>
<blockquote>
<div><p>Angle with respect to z-axis</p>
</div></blockquote>
<p><strong>phi</strong> : float</p>
<blockquote>
<div><p>Angle in x-y plane</p>
</div></blockquote>
<p><strong>values</strong> : array</p>
<blockquote>
<div><p>Data set to be plotted</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>save</strong> : bool {False , True}</p>
<blockquote>
<div><p>Whether to save the figure or not</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_schmidt">
<tt class="descname">plot_schmidt</tt><big>(</big><em>ket</em>, <em>splitting=None</em>, <em>labels_iteration=(3</em>, <em>2)</em>, <em>theme='light'</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(6</em>, <em>6)</em><big>)</big><a class="headerlink" href="#qutip.visualization.plot_schmidt" title="Permalink to this definition">¶</a></dt>
<dd><p>Plotting scheme related to Schmidt decomposition.
Converts a state into a matrix (A_ij -&gt; A_i^j),
where rows are first particles and columns - last.</p>
<p>See also: plot_qubism with how=&#8217;before_after&#8217; for a similar plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ket</strong> : Qobj</p>
<blockquote>
<div><p>Pure state for plotting.</p>
</div></blockquote>
<p><strong>splitting</strong> : int</p>
<blockquote>
<div><p>Plot for a number of first particles versus the rest.
If not given, it is (number of particles + 1) // 2.</p>
</div></blockquote>
<p><strong>theme</strong> : &#8216;light&#8217; (default) or &#8216;dark&#8217;</p>
<blockquote>
<div><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</div></blockquote>
<p><strong>labels_iteration</strong> : int or pair of ints (default (3,2))</p>
<blockquote>
<div><p>Number of particles to be shown as tick labels,
for first (vertical) and last (horizontal) particles, respectively.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib figure instance</p>
<blockquote>
<div><p>The figure canvas on which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axis instance</p>
<blockquote>
<div><p>The axis context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_qubism">
<tt class="descname">plot_qubism</tt><big>(</big><em>ket</em>, <em>theme='light'</em>, <em>how='pairs'</em>, <em>grid_iteration=1</em>, <em>legend_iteration=0</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(6</em>, <em>6)</em><big>)</big><a class="headerlink" href="#qutip.visualization.plot_qubism" title="Permalink to this definition">¶</a></dt>
<dd><p>Qubism plot for pure states of many qudits.
Works best for spin chains, especially with even number of particles
of the same dimension.
Allows to see entanglement between first 2*k particles and the rest.</p>
<dl class="docutils">
<dt>More information:</dt>
<dd>J. Rodriguez-Laguna, P. Migdal,
M. Ibanez Berganza, M. Lewenstein, G. Sierra,
&#8220;Qubism: self-similar visualization of many-body wavefunctions&#8221;,
New J. Phys. 14 053028 (2012), arXiv:1112.3560,
http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ket</strong> : Qobj</p>
<blockquote>
<div><p>Pure state for plotting.</p>
</div></blockquote>
<p><strong>theme</strong> : &#8216;light&#8217; (default) or &#8216;dark&#8217;</p>
<blockquote>
<div><p>Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</div></blockquote>
<p><strong>how</strong> : &#8216;pairs&#8217; (default), &#8216;pairs_skewed&#8217; or &#8216;before_after&#8217;</p>
<blockquote>
<div><p>Type of Qubism plotting.
Options:</p>
<blockquote>
<div><p>&#8216;pairs&#8217; - typical coordinates,
&#8216;pairs_skewed&#8217; - for ferromagnetic/antriferromagnetic plots,
&#8216;before_after&#8217; - related to Schmidt plot (see also: plot_schmidt).</p>
</div></blockquote>
</div></blockquote>
<p><strong>grid_iteration</strong> : int (default 1)</p>
<blockquote>
<div><p>Helper lines to be drawn on plot.
Show tiles for 2*grid_iteration particles vs all others.</p>
</div></blockquote>
<p><strong>legend_iteration</strong> : int (default 0) or &#8216;grid_iteration&#8217; or &#8216;all&#8217;</p>
<blockquote>
<div><p>Show labels for first 2*legend_iteration particles.
Option &#8216;grid_iteration&#8217; sets the same number of particles</p>
<blockquote>
<div><p>as for grid_iteration.</p>
</div></blockquote>
<p>Option &#8216;all&#8217; makes label for all particles.
Typically it should be 0, 1, 2 or perhaps 3.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib figure instance</p>
<blockquote>
<div><p>The figure canvas on which the plot will be drawn.</p>
</div></blockquote>
<p><strong>ax</strong> : a matplotlib axis instance</p>
<blockquote>
<div><p>The axis context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_expectation_values">
<tt class="descname">plot_expectation_values</tt><big>(</big><em>results</em>, <em>ylabels=</em>, <span class="optional">[</span><span class="optional">]</span><em>title=None</em>, <em>show_legend=False</em>, <em>fig=None</em>, <em>axes=None</em>, <em>figsize=(8</em>, <em>4)</em><big>)</big><a class="headerlink" href="#qutip.visualization.plot_expectation_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the results (expectation values) for an evolution solver.
<cite>results</cite> is assumed to be an instance of Result, or a list of Result
instances.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>results</strong> : (list of) <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><tt class="xref py py-class docutils literal"><span class="pre">qutip.solver.Result</span></tt></a></p>
<blockquote>
<div><p>List of results objects returned by any of the QuTiP evolution solvers.</p>
</div></blockquote>
<p><strong>ylabels</strong> : list of strings</p>
<blockquote>
<div><p>The y-axis labels. List should be of the same length as <cite>results</cite>.</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>The title of the figure.</p>
</div></blockquote>
<p><strong>show_legend</strong> : bool</p>
<blockquote>
<div><p>Whether or not to show the legend.</p>
</div></blockquote>
<p><strong>fig</strong> : a matplotlib Figure instance</p>
<blockquote>
<div><p>The Figure canvas in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>axes</strong> : a matplotlib axes instance</p>
<blockquote>
<div><p>The axes context in which the plot will be drawn.</p>
</div></blockquote>
<p><strong>figsize</strong> : (width, height)</p>
<blockquote>
<div><p>The size of the matplotlib figure (in inches) if it is to be created
(that is, if no &#8216;fig&#8217; and &#8216;ax&#8217; arguments are passed).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-qutip"></span><dl class="function">
<dt id="qutip.orbital">
<tt class="descname">orbital</tt><big>(</big><em>theta</em>, <em>phi</em>, <em>*args</em><big>)</big><a class="headerlink" href="#qutip.orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates an angular wave function on a sphere.
<tt class="docutils literal"><span class="pre">psi</span> <span class="pre">=</span> <span class="pre">orbital(theta,phi,ket1,ket2,...)</span></tt> calculates
the angular wave function on a sphere at the mesh of points
defined by theta and phi which is
<span class="math">\(\sum_{lm} c_{lm} Y_{lm}(theta,phi)\)</span> where <span class="math">\(C_{lm}\)</span> are the
coefficients specified by the list of kets. Each ket has 2l+1 components
for some integer l.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : list/array</p>
<blockquote>
<div><p>Polar angles</p>
</div></blockquote>
<p><strong>phi</strong> : list/array</p>
<blockquote>
<div><p>Azimuthal angles</p>
</div></blockquote>
<p><strong>args</strong> : list/array</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> of ket vectors.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>``array`` for angular wave function</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.tomography">
<span id="quantum-process-tomography"></span><h3>Quantum Process Tomography<a class="headerlink" href="#module-qutip.tomography" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.tomography.qpt">
<tt class="descname">qpt</tt><big>(</big><em>U</em>, <em>op_basis_list</em><big>)</big><a class="headerlink" href="#qutip.tomography.qpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the quantum process tomography chi matrix for a given (possibly
nonunitary) transformation matrix U, which transforms a density matrix in
vector form according to:</p>
<blockquote>
<div><p>vec(rho) = U * vec(rho0)</p>
<p>or</p>
<p>rho = vec2mat(U * mat2vec(rho0))</p>
</div></blockquote>
<p>U can be calculated for an open quantum system using the QuTiP propagator
function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>Transformation operator. Can be calculated using QuTiP propagator
function.</p>
</div></blockquote>
<p><strong>op_basis_list</strong> : list</p>
<blockquote>
<div><p>A list of Qobj&#8217;s representing the basis states.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>chi</strong> : array</p>
<blockquote class="last">
<div><p>QPT chi matrix</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.tomography.qpt_plot">
<tt class="descname">qpt_plot</tt><big>(</big><em>chi</em>, <em>lbls_list</em>, <em>title=None</em>, <em>fig=None</em>, <em>axes=None</em><big>)</big><a class="headerlink" href="#qutip.tomography.qpt_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot the real and
imaginary parts separately.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chi</strong> : array</p>
<blockquote>
<div><p>Input QPT chi matrix.</p>
</div></blockquote>
<p><strong>lbls_list</strong> : list</p>
<blockquote>
<div><p>List of labels for QPT plot axes.</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>Plot title.</p>
</div></blockquote>
<p><strong>fig</strong> : figure instance</p>
<blockquote>
<div><p>User defined figure instance used for generating QPT plot.</p>
</div></blockquote>
<p><strong>axes</strong> : list of figure axis instance</p>
<blockquote>
<div><p>User defined figure axis instance (list of two axes) used for
generating QPT plot.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.tomography.qpt_plot_combined">
<tt class="descname">qpt_plot_combined</tt><big>(</big><em>chi</em>, <em>lbls_list</em>, <em>title=None</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>6)</em>, <em>threshold=None</em><big>)</big><a class="headerlink" href="#qutip.tomography.qpt_plot_combined" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot bars with
height and color corresponding to the absolute value and phase,
respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>chi</strong> : array</p>
<blockquote>
<div><p>Input QPT chi matrix.</p>
</div></blockquote>
<p><strong>lbls_list</strong> : list</p>
<blockquote>
<div><p>List of labels for QPT plot axes.</p>
</div></blockquote>
<p><strong>title</strong> : string</p>
<blockquote>
<div><p>Plot title.</p>
</div></blockquote>
<p><strong>fig</strong> : figure instance</p>
<blockquote>
<div><p>User defined figure instance used for generating QPT plot.</p>
</div></blockquote>
<p><strong>ax</strong> : figure axis instance</p>
<blockquote>
<div><p>User defined figure axis instance used for generating QPT plot
(alternative to the fig argument).</p>
</div></blockquote>
<p><strong>threshold: float (None)</strong> :</p>
<blockquote>
<div><p>Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig, ax</strong> : tuple</p>
<blockquote class="last">
<div><p>A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="quantum-information-processing">
<span id="functions-qip"></span><h2>Quantum Information Processing<a class="headerlink" href="#quantum-information-processing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.qip.gates">
<span id="gates"></span><h3>Gates<a class="headerlink" href="#module-qutip.qip.gates" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.qip.gates.rx">
<tt class="descname">rx</tt><big>(</big><em>phi</em>, <em>N=None</em>, <em>target=0</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmax with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the rotation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.ry">
<tt class="descname">ry</tt><big>(</big><em>phi</em>, <em>N=None</em>, <em>target=0</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.ry" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmay with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the rotation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.rz">
<tt class="descname">rz</tt><big>(</big><em>phi</em>, <em>N=None</em>, <em>target=0</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.rz" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmaz with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the rotation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtnot">
<tt class="descname">sqrtnot</tt><big>(</big><em>N=None</em>, <em>target=0</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.sqrtnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit square root NOT gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the square root NOT gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.snot">
<tt class="descname">snot</tt><big>(</big><em>N=None</em>, <em>target=0</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.snot" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SNOT (Hadamard) gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>snot_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of SNOT gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snot</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678+0.j  0.70710678+0.j]</span>
<span class="go"> [ 0.70710678+0.j -0.70710678+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.phasegate">
<tt class="descname">phasegate</tt><big>(</big><em>theta</em>, <em>N=None</em>, <em>target=0</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.phasegate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the phase shift gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : float</p>
<blockquote>
<div><p>Phase rotation angle.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>phase_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of phase shift gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">phasegate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.00000000+0.j          0.00000000+0.j        ]</span>
<span class="go"> [ 0.00000000+0.j          0.70710678+0.70710678j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.cphase">
<tt class="descname">cphase</tt><big>(</big><em>theta</em>, <em>N=2</em>, <em>control=0</em>, <em>target=1</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.cphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the phase shift gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : float</p>
<blockquote>
<div><p>Phase rotation angle.</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>control</strong> : integer</p>
<blockquote>
<div><p>The index of the control qubit.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>U</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of controlled phase gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.cnot">
<tt class="descname">cnot</tt><big>(</big><em>N=None</em>, <em>control=0</em>, <em>target=1</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.cnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the CNOT gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cnot_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of CNOT gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cnot</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.csign">
<tt class="descname">csign</tt><big>(</big><em>N=None</em>, <em>control=0</em>, <em>target=1</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.csign" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the CSIGN gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>csign_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of CSIGN gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">csign</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  -1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.berkeley">
<tt class="descname">berkeley</tt><big>(</big><em>N=None, targets=[0, 1]</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.berkeley" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Berkeley gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>berkeley_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of Berkeley gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">berkeley</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ cos(pi/8).+0.j  0.+0.j           0.+0.j           0.+sin(pi/8).j]</span>
<span class="go">     [ 0.+0.j          cos(3pi/8).+0.j  0.+sin(3pi/8).j  0.+0.j]</span>
<span class="go">     [ 0.+0.j          0.+sin(3pi/8).j  cos(3pi/8).+0.j  0.+0.j]</span>
<span class="go">     [ 0.+sin(pi/8).j  0.+0.j           0.+0.j           cos(pi/8).+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.swapalpha">
<tt class="descname">swapalpha</tt><big>(</big><em>alpha, N=None, targets=[0, 1]</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.swapalpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SWAPalpha gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>swapalpha_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of SWAPalpha gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">swapalpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j                    0.+0.j                    0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.5*(1 + exp(j*pi*alpha)  0.5*(1 - exp(j*pi*alpha)  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.5*(1 - exp(j*pi*alpha)  0.5*(1 + exp(j*pi*alpha)  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j                    0.+0.j                    1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.swap">
<tt class="descname">swap</tt><big>(</big><em>N=None, targets=[0, 1]</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>swap_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of SWAP gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">swap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.iswap">
<tt class="descname">iswap</tt><big>(</big><em>N=None, targets=[0, 1]</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.iswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the iSWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>iswap_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of iSWAP gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">iswap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+1.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+1.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtswap">
<tt class="descname">sqrtswap</tt><big>(</big><em>N=None, targets=[0, 1]</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.sqrtswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the square root SWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sqrtswap_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of square root SWAP gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtiswap">
<tt class="descname">sqrtiswap</tt><big>(</big><em>N=None, targets=[0, 1]</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.sqrtiswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the square root iSWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>sqrtiswap_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of square root iSWAP gate</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sqrtiswap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.00000000+0.j   0.00000000+0.j          0.00000000+0.j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.70710678+0.j          0.00000000-0.70710678j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.00000000-0.70710678j       0.70710678+0.j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.00000000+0.j          0.00000000+0.j          1.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.fredkin">
<tt class="descname">fredkin</tt><big>(</big><em>N=None, control=0, targets=[1, 2]</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.fredkin" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Fredkin gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fredkin_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of Fredkin gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fredkin</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.toffoli">
<tt class="descname">toffoli</tt><big>(</big><em>N=None, controls=[0, 1], target=2</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.toffoli" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Toffoli gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>toff_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of Toffoli gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">toffoli</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.rotation">
<tt class="descname">rotation</tt><big>(</big><em>op</em>, <em>phi</em>, <em>N=None</em>, <em>target=0</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator op with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object for operator describing the rotation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.controlled_gate">
<tt class="descname">controlled_gate</tt><big>(</big><em>U</em>, <em>N=2</em>, <em>control=0</em>, <em>target=1</em>, <em>control_value=1</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.controlled_gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an N-qubit controlled gate from a single-qubit gate U with the given
control and target qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>Arbitrary single-qubit gate.</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>control</strong> : integer</p>
<blockquote>
<div><p>The index of the first control qubit.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
<p><strong>control_value</strong> : integer (1)</p>
<blockquote>
<div><p>The state of the control qubit that activates the gate U.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representing the controlled-U gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.globalphase">
<tt class="descname">globalphase</tt><big>(</big><em>theta</em>, <em>N=1</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.globalphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the global phase shift gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>theta</strong> : float</p>
<blockquote>
<div><p>Phase rotation angle.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>phase_gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of global phase shift gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">phasegate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678+0.70710678j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j          0.70710678+0.70710678j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.hadamard_transform">
<tt class="descname">hadamard_transform</tt><big>(</big><em>N=1</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.hadamard_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the N-qubit Hadamard gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>q</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of the N-qubit Hadamard gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_sequence_product">
<tt class="descname">gate_sequence_product</tt><big>(</big><em>U_list</em>, <em>left_to_right=True</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.gate_sequence_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the overall unitary matrix for a given list of unitary operations</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U_list</strong> : list</p>
<blockquote>
<div><p>List of gates implementing the quantum circuit.</p>
</div></blockquote>
<p><strong>left_to_right: Boolean</strong> :</p>
<blockquote>
<div><p>Check if multiplication is to be done from left to right.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>U_overall: qobj</strong> :</p>
<blockquote class="last">
<div><p>Overall unitary matrix of a given quantum circuit.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_1toN">
<tt class="descname">gate_expand_1toN</tt><big>(</big><em>U</em>, <em>N</em>, <em>target</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.gate_expand_1toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a one-qubit gate that act on a system with N
qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>The one-qubit gate</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of N-qubit gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_2toN">
<tt class="descname">gate_expand_2toN</tt><big>(</big><em>U</em>, <em>N</em>, <em>control=None</em>, <em>target=None</em>, <em>targets=None</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.gate_expand_2toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a two-qubit gate that act on a system with N
qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>The two-qubit gate</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>control</strong> : integer</p>
<blockquote>
<div><p>The index of the control qubit.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
<p><strong>targets</strong> : list</p>
<blockquote>
<div><p>List of target qubits.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of N-qubit gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_3toN">
<tt class="descname">gate_expand_3toN</tt><big>(</big><em>U, N, controls=[0, 1], target=2</em><big>)</big><a class="headerlink" href="#qutip.qip.gates.gate_expand_3toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a three-qubit gate that act on a system with N
qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>U</strong> : Qobj</p>
<blockquote>
<div><p>The three-qubit gate</p>
</div></blockquote>
<p><strong>N</strong> : integer</p>
<blockquote>
<div><p>The number of qubits in the target space.</p>
</div></blockquote>
<p><strong>controls</strong> : list</p>
<blockquote>
<div><p>The list of the control qubits.</p>
</div></blockquote>
<p><strong>target</strong> : integer</p>
<blockquote>
<div><p>The index of the target qubit.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>gate</strong> : qobj</p>
<blockquote class="last">
<div><p>Quantum object representation of N-qubit gate.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.qubits">
<span id="qubits"></span><h3>Qubits<a class="headerlink" href="#module-qutip.qip.qubits" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.qip.qubits.qubit_states">
<tt class="descname">qubit_states</tt><big>(</big><em>N=1, states=[0]</em><big>)</big><a class="headerlink" href="#qutip.qip.qubits.qubit_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to define initial state of the qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N: Integer</strong> :</p>
<blockquote>
<div><p>Number of qubits in the register.</p>
</div></blockquote>
<p><strong>states: List</strong> :</p>
<blockquote>
<div><p>Initial state of each qubit.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>qstates: Qobj</strong> :</p>
<blockquote class="last">
<div><p>List of qubits.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.algorithms.qft">
<span id="algorithms"></span><h3>Algorithms<a class="headerlink" href="#module-qutip.qip.algorithms.qft" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft">
<tt class="descname">qft</tt><big>(</big><em>N=1</em><big>)</big><a class="headerlink" href="#qutip.qip.algorithms.qft.qft" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N</strong> : int</p>
<blockquote>
<div><p>Number of qubits.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>QFT: qobj</strong> :</p>
<blockquote class="last">
<div><p>Quantum Fourier transform operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft_steps">
<tt class="descname">qft_steps</tt><big>(</big><em>N=1</em>, <em>swapping=True</em><big>)</big><a class="headerlink" href="#qutip.qip.algorithms.qft.qft_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits returning the individual
steps as unitary matrices operating from left to right.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N: int</strong> :</p>
<blockquote>
<div><p>Number of qubits.</p>
</div></blockquote>
<p><strong>swap: boolean</strong> :</p>
<blockquote>
<div><p>Flag indicating sequence of swap gates to be applied at the end or not.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>U_step_list: list of qobj</strong> :</p>
<blockquote class="last">
<div><p>List of Hadamard and controlled rotation gates implementing QFT.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft_gate_sequence">
<tt class="descname">qft_gate_sequence</tt><big>(</big><em>N=1</em>, <em>swapping=True</em><big>)</big><a class="headerlink" href="#qutip.qip.algorithms.qft.qft_gate_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits returning the gate sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>N: int</strong> :</p>
<blockquote>
<div><p>Number of qubits.</p>
</div></blockquote>
<p><strong>swap: boolean</strong> :</p>
<blockquote>
<div><p>Flag indicating sequence of swap gates to be applied at the end or not.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>qc: instance of QubitCircuit</strong> :</p>
<blockquote class="last">
<div><p>Gate sequence of Hadamard and controlled rotation gates implementing
QFT.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="utilitiy-functions">
<span id="functions-metrics"></span><h2>Utilitiy Functions<a class="headerlink" href="#utilitiy-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="graph-theory-routines">
<h3>Graph Theory Routines<a class="headerlink" href="#graph-theory-routines" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-qutip.graph"></span><p>This module contains a collection of graph theory routines used mainly
to reorder matrices for iterative steady state solvers.</p>
<dl class="function">
<dt id="qutip.graph.breadth_first_search">
<tt class="descname">breadth_first_search</tt><big>(</big><em>A</em>, <em>start</em><big>)</big><a class="headerlink" href="#qutip.graph.breadth_first_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting
from a given node (row).  Takes Qobjs and CSR or CSC matrices as inputs.</p>
<p>This function requires a matrix with symmetric structure.
Use A+trans(A) if original matrix is not symmetric or not sure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : csc_matrix, csr_matrix</p>
<blockquote>
<div><p>Input graph in CSC or CSR matrix format</p>
</div></blockquote>
<p><strong>start</strong> : int</p>
<blockquote>
<div><p>Staring node for BFS traversal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>order</strong> : array</p>
<blockquote>
<div><p>Order in which nodes are traversed from starting node.</p>
</div></blockquote>
<p><strong>levels</strong> : array</p>
<blockquote class="last">
<div><p>Level of the nodes in the order that they are traversed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.graph_degree">
<tt class="descname">graph_degree</tt><big>(</big><em>A</em><big>)</big><a class="headerlink" href="#qutip.graph.graph_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the degree for the nodes (rows) of a symmetric
graph in sparse CSR or CSC format, or a qobj.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>A</strong> : qobj, csr_matrix, csc_matrix</p>
<blockquote>
<div><p>Input quantum object or csr_matrix.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>degree</strong> : array</p>
<blockquote class="last">
<div><p>Array of integers giving the degree for each node (row).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.utilities">
<span id="utility-functions"></span><span id="functions-utilities"></span><h3>Utility Functions<a class="headerlink" href="#module-qutip.utilities" title="Permalink to this headline">¶</a></h3>
<p>This module contains utility functions that are commonly needed in other
qutip modules.</p>
<dl class="function">
<dt id="qutip.utilities.n_thermal">
<tt class="descname">n_thermal</tt><big>(</big><em>w</em>, <em>w_th</em><big>)</big><a class="headerlink" href="#qutip.utilities.n_thermal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of photons in thermal equilibrium for an harmonic
oscillator mode with frequency &#8216;w&#8217;, at the temperature described by
&#8216;w_th&#8217; where <span class="math">\(\omega_{\rm th} = k_BT/\hbar\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>w</strong> : <em>float</em> or <em>array</em></p>
<blockquote>
<div><p>Frequency of the oscillator.</p>
</div></blockquote>
<p><strong>w_th</strong> : <em>float</em></p>
<blockquote>
<div><p>The temperature in units of frequency (or the same units as <cite>w</cite>).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>n_avg</strong> : <em>float</em> or <em>array</em></p>
<blockquote class="last">
<div><p>Return the number of average photons in thermal equilibrium for a
an oscillator with the given frequency and temperature.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.linspace_with">
<tt class="descname">linspace_with</tt><big>(</big><em>start</em>, <em>stop</em>, <em>num=50</em>, <em>elems=</em><span class="optional">[</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#qutip.utilities.linspace_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of numbers sampled over specified interval
with additional elements added.</p>
<p>Returns <cite>num</cite> spaced array with elements from <cite>elems</cite> inserted
if not already included in set.</p>
<p>Returned sample array is not evenly spaced if addtional elements
are added.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>start</strong> : int</p>
<blockquote>
<div><p>The starting value of the sequence.</p>
</div></blockquote>
<p><strong>stop</strong> : int</p>
<blockquote>
<div><p>The stoping values of the sequence.</p>
</div></blockquote>
<p><strong>num</strong> : int, optional</p>
<blockquote>
<div><p>Number of samples to generate.</p>
</div></blockquote>
<p><strong>elems</strong> : list/ndarray, optional</p>
<blockquote>
<div><p>Requested elements to include in array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>samples</strong> : ndadrray</p>
<blockquote class="last">
<div><p>Original equally spaced sample array with additional
elements added.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.clebsch">
<tt class="descname">clebsch</tt><big>(</big><em>j1</em>, <em>j2</em>, <em>j3</em>, <em>m1</em>, <em>m2</em>, <em>m3</em><big>)</big><a class="headerlink" href="#qutip.utilities.clebsch" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Clebsch-Gordon coefficient
for coupling (j1,m1) and (j2,m2) to give (j3,m3).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>j1</strong> : float</p>
<blockquote>
<div><p>Total angular momentum 1.</p>
</div></blockquote>
<p><strong>j2</strong> : float</p>
<blockquote>
<div><p>Total angular momentum 2.</p>
</div></blockquote>
<p><strong>j3</strong> : float</p>
<blockquote>
<div><p>Total angular momentum 3.</p>
</div></blockquote>
<p><strong>m1</strong> : float</p>
<blockquote>
<div><p>z-component of angular momentum 1.</p>
</div></blockquote>
<p><strong>m2</strong> : float</p>
<blockquote>
<div><p>z-component of angular momentum 2.</p>
</div></blockquote>
<p><strong>m3</strong> : float</p>
<blockquote>
<div><p>z-component of angular momentum 3.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cg_coeff</strong> : float</p>
<blockquote class="last">
<div><p>Requested Clebsch-Gordan coefficient.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.convert_unit">
<tt class="descname">convert_unit</tt><big>(</big><em>value</em>, <em>orig='meV'</em>, <em>to='GHz'</em><big>)</big><a class="headerlink" href="#qutip.utilities.convert_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an energy from unit <cite>orig</cite> to unit <cite>to</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>value</strong> : float / array</p>
<blockquote>
<div><p>The energy in the old unit.</p>
</div></blockquote>
<p><strong>orig</strong> : string</p>
<blockquote>
<div><p>The name of the original unit (&#8220;J&#8221;, &#8220;eV&#8221;, &#8220;meV&#8221;, &#8220;GHz&#8221;, &#8220;mK&#8221;)</p>
</div></blockquote>
<p><strong>to</strong> : string</p>
<blockquote>
<div><p>The name of the new unit (&#8220;J&#8221;, &#8220;eV&#8221;, &#8220;meV&#8221;, &#8220;GHz&#8221;, &#8220;mK&#8221;)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>value_new_unit</strong> : float / array</p>
<blockquote class="last">
<div><p>The energy in the new unit.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.fileio">
<span id="file-i-o-functions"></span><span id="functions-fileio"></span><h3>File I/O Functions<a class="headerlink" href="#module-qutip.fileio" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.fileio.file_data_read">
<tt class="descname">file_data_read</tt><big>(</big><em>filename</em>, <em>sep=None</em><big>)</big><a class="headerlink" href="#qutip.fileio.file_data_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves an array of data from the requested file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Name of file containing reqested data.</p>
</div></blockquote>
<p><strong>sep</strong> : str</p>
<blockquote>
<div><p>Seperator used to store data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>data</strong> : array_like</p>
<blockquote class="last">
<div><p>Data from selected file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.file_data_store">
<tt class="descname">file_data_store</tt><big>(</big><em>filename</em>, <em>data</em>, <em>numtype='complex'</em>, <em>numformat='decimal'</em>, <em>sep='</em>, <em>'</em><big>)</big><a class="headerlink" href="#qutip.fileio.file_data_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores a matrix of data to a file to be read by an external program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>filename</strong> : str</p>
<blockquote>
<div><p>Name of data file to be stored, including extension.</p>
</div></blockquote>
<p><strong>data: array_like</strong> :</p>
<blockquote>
<div><p>Data to be written to file.</p>
</div></blockquote>
<p><strong>numtype</strong> : str {&#8216;complex, &#8216;real&#8217;}</p>
<blockquote>
<div><p>Type of numerical data.</p>
</div></blockquote>
<p><strong>numformat</strong> : str {&#8216;decimal&#8217;,&#8217;exp&#8217;}</p>
<blockquote>
<div><p>Format for written data.</p>
</div></blockquote>
<p><strong>sep</strong> : str</p>
<blockquote class="last">
<div><p>Single-character field seperator.  Usually a tab, space, comma,
or semicolon.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.qload">
<tt class="descname">qload</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#qutip.fileio.qload" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads data file from file named &#8216;filename.qu&#8217; in current directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> : str</p>
<blockquote>
<div><p>Name of data file to be loaded.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>qobject</strong> : instance / array_like</p>
<blockquote class="last">
<div><p>Object retrieved from requested file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.qsave">
<tt class="descname">qsave</tt><big>(</big><em>data</em>, <em>name='qutip_data'</em><big>)</big><a class="headerlink" href="#qutip.fileio.qsave" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves given data to file named &#8216;filename.qu&#8217; in current directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : instance/array_like</p>
<blockquote>
<div><p>Input Python object to be stored.</p>
</div></blockquote>
<p><strong>filename</strong> : str</p>
<blockquote class="last">
<div><p>Name of output data file.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.ipynbtools">
<span id="ipython-notebook-tools"></span><span id="functions-misc"></span><h3>IPython Notebook Tools<a class="headerlink" href="#module-qutip.ipynbtools" title="Permalink to this headline">¶</a></h3>
<p>This module contains utility functions for using QuTiP with IPython notebooks.</p>
<dl class="function">
<dt id="qutip.ipynbtools.parfor">
<tt class="descname">parfor</tt><big>(</big><em>task</em>, <em>task_vec</em>, <em>args=None</em>, <em>client=None</em>, <em>view=None</em>, <em>show_scheduling=False</em>, <em>show_progressbar=False</em><big>)</big><a class="headerlink" href="#qutip.ipynbtools.parfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the function <tt class="docutils literal"><span class="pre">tast</span></tt> for each value in <tt class="docutils literal"><span class="pre">task_vec</span></tt> using a cluster
of IPython engines. The function <tt class="docutils literal"><span class="pre">task</span></tt> should have the signature
<tt class="docutils literal"><span class="pre">task(value,</span> <span class="pre">args)</span></tt> or <tt class="docutils literal"><span class="pre">task(value)</span></tt> if <tt class="docutils literal"><span class="pre">args=None</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">client</span></tt> and <tt class="docutils literal"><span class="pre">view</span></tt> are the IPython.parallel client and
load-balanced view that will be used in the parfor execution. If these
are <tt class="docutils literal"><span class="pre">None</span></tt>, new instances will be created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>task: a Python function</strong> :</p>
<blockquote>
<div><p>The function that is to be called for each value in <tt class="docutils literal"><span class="pre">task_vec</span></tt>.</p>
</div></blockquote>
<p><strong>task_vec: array / list</strong> :</p>
<blockquote>
<div><p>The list or array of values for which the <tt class="docutils literal"><span class="pre">task</span></tt> function is to be
evaluated.</p>
</div></blockquote>
<p><strong>args: list / dictionary</strong> :</p>
<blockquote>
<div><p>The optional additional argument to the <tt class="docutils literal"><span class="pre">task</span></tt> function. For example
a dictionary with parameter values.</p>
</div></blockquote>
<p><strong>client: IPython.parallel.Client</strong> :</p>
<blockquote>
<div><p>The IPython.parallel Client instance that will be used in the
parfor execution.</p>
</div></blockquote>
<p><strong>view: a IPython.parallel.Client view</strong> :</p>
<blockquote>
<div><p>The view that is to be used in scheduling the tasks on the IPython
cluster. Preferably a load-balanced view, which is obtained from the
IPython.parallel.Client instance client by calling,
view = client.load_balanced_view().</p>
</div></blockquote>
<p><strong>show_scheduling: bool {False, True}, default False</strong> :</p>
<blockquote>
<div><p>Display a graph showing how the tasks (the evaluation of <tt class="docutils literal"><span class="pre">task</span></tt> for
for the value in <tt class="docutils literal"><span class="pre">task_vec1</span></tt>) was scheduled on the IPython engine
cluster.</p>
</div></blockquote>
<p><strong>show_progressbar: bool {False, True}, default False</strong> :</p>
<blockquote>
<div><p>Display a HTML-based progress bar duing the execution of the parfor
loop.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : list</p>
<blockquote class="last">
<div><p>The result list contains the value of <tt class="docutils literal"><span class="pre">task(value,</span> <span class="pre">args)</span></tt> for each
value in <tt class="docutils literal"><span class="pre">task_vec</span></tt>, that is, it should be equivalent to
<tt class="docutils literal"><span class="pre">[task(v,</span> <span class="pre">args)</span> <span class="pre">for</span> <span class="pre">v</span> <span class="pre">in</span> <span class="pre">task_vec]</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.ipynbtools.version_table">
<tt class="descname">version_table</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.ipynbtools.version_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Print an HTML-formatted table with version numbers for QuTiP and its
dependencies. Use it in a IPython notebook to show which versions of
different packages that were used to run the notebook. This should make it
possible to reproduce the environment and the calculation later on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>version_table: string</strong> :</p>
<blockquote class="last">
<div><p>Return an HTML-formatted string containing version information for
QuTiP dependencies.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip">
<span id="miscellaneous"></span><h3>Miscellaneous<a class="headerlink" href="#module-qutip" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.parfor">
<tt class="descname">parfor</tt><big>(</big><em>func</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#qutip.parfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes a multi-variable function in parallel on the local machine.</p>
<p>Parallel execution of a for-loop over function <cite>func</cite> for multiple input
arguments and keyword arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func</strong> : function_type</p>
<blockquote>
<div><p>A function to run in parallel on the local machine. The function &#8216;func&#8217;
accepts a series of arguments that are passed to the function as
variables. In general, the function can have multiple input variables,
and these arguments must be passed in the same order as they are
defined in the function definition.  In addition, the user can pass
multiple keyword arguments to the function.</p>
</div></blockquote>
<p><strong>The following keyword argument is reserved:</strong> :</p>
<p><strong>num_cpus</strong> : int</p>
<blockquote>
<div><p>Number of CPU&#8217;s to use.  Default uses maximum number of CPU&#8217;s.
Performance degrades if num_cpus is larger than the physical CPU
count of your machine.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : list</p>
<blockquote class="last">
<div><p>A <tt class="docutils literal"><span class="pre">list</span></tt> with length equal to number of input parameters
containing the output from <cite>func</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.about">
<tt class="descname">about</tt><big>(</big><big>)</big><a class="headerlink" href="#qutip.about" title="Permalink to this definition">¶</a></dt>
<dd><p>About box for qutip. Gives version numbers for
QuTiP, NumPy, SciPy, Cython, and MatPlotLib.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.simdiag">
<tt class="descname">simdiag</tt><big>(</big><em>ops</em>, <em>evals=True</em><big>)</big><a class="headerlink" href="#qutip.simdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulateous diagonalization of communting Hermitian matrices..</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ops</strong> : list/array</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">list</span></tt> or <tt class="docutils literal"><span class="pre">array</span></tt> of qobjs representing commuting Hermitian
operators.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>eigs</strong> : tuple</p>
<blockquote class="last">
<div><p>Tuple of arrays representing eigvecs and eigvals of quantum objects
corresponding to simultaneous eigenvectors and eigenvalues for each
operator.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2011 and later, P.D. Nation, J.R. Johansson.<br/>
      Last updated on Aug 05, 2014.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>