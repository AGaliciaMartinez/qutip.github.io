
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Solving Problems with Time-dependent Hamiltonians &mdash; QuTiP 3.1.0 Documentation</title>
    
    <link rel="stylesheet" href="../../static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../static/bootswatch-3.2.0/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../static/site.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '3.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../static/jquery.js"></script>
    <script type="text/javascript" src="../../static/underscore.js"></script>
    <script type="text/javascript" src="../../static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../static/bootstrap-3.2.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../static/favicon.ico"/>
    <link rel="top" title="QuTiP 3.1.0 Documentation" href="../../index.html" />
    <link rel="up" title="Time Evolution and Quantum System Dynamics" href="../guide-dynamics.html" />
    <link rel="next" title="Floquet Formalism" href="dynamics-floquet.html" />
    <link rel="prev" title="Bloch-Redfield master equation" href="dynamics-bloch-redfield.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          QuTiP</a>
        <span class="navbar-text navbar-version pull-left"><b>3.1.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="http://qutip.org">qutip.org</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Docs <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../frontmatter.html">Frontmatter</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../frontmatter.html#about-this-documentation">About This Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../frontmatter.html#citing-this-project">Citing This Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../frontmatter.html#funding">Funding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../frontmatter.html#about-qutip">About QuTiP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../frontmatter.html#contributing-to-qutip">Contributing to QuTiP</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#general-requirements">General Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#platform-independent-installation">Platform-independent installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#get-the-source-code">Get the source code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installing-from-source">Installing from source</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installation-on-ubuntu-linux">Installation on Ubuntu Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installation-on-mac-os-x-10-8">Installation on Mac OS X (10.8+)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installation-on-windows">Installation on Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#optional-installation-options">Optional Installation Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#verifying-the-installation">Verifying the Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#checking-version-information-using-the-about-function">Checking Version Information using the About Function</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../guide.html">Users Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../guide-overview.html">Guide Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-basics.html">Basic Operations on Quantum Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-states.html">Manipulating States and Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-tensor.html">Using Tensor Products and Partial Traces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../guide-dynamics.html">Time Evolution and Quantum System Dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-steady.html">Solving for Steady-State Solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-eseries.html">An Overview of the Eseries Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-correlation.html">Two-time correlation functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-bloch.html">Plotting on the Bloch Sphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-visualization.html">Visualization of quantum states and processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-parfor.html">Parallel computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-saving.html">Saving QuTiP Objects and Data Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-random.html">Generating Random Quantum States &amp; Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-settings.html">Modifying Internal QuTiP Settings</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/apidoc.html">API documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../apidoc/classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../apidoc/functions.html">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Change Log</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-3-1-0-january-1-2015">Version 3.1.0 (January 1, 2015):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-3-0-1-aug-5-2014">Version 3.0.1 (Aug 5, 2014):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-3-0-0-july-17-2014">Version 3.0.0 (July 17, 2014):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-2-2-0-march-01-2013">Version 2.2.0 (March 01, 2013):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-2-1-0-october-05-2012">Version 2.1.0 (October 05, 2012):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-2-0-0-june-01-2012">Version 2.0.0 (June 01, 2012):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-1-1-4-may-28-2012">Version 1.1.4 (May 28, 2012):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-1-1-3-november-21-2011">Version 1.1.3 (November 21, 2011):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-1-1-2-october-27-2011">Version 1.1.2 (October 27, 2011)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-1-1-1-october-25-2011">Version 1.1.1 (October 25, 2011)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-1-1-0-october-04-2011">Version 1.1.0 (October 04, 2011)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-1-0-0-july-29-2011">Version 1.0.0 (July 29, 2011)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Developers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../contributors.html#lead-developers">Lead Developers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributors.html#contributors">Contributors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../biblio.html">Bibliography</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Solving Problems with Time-dependent Hamiltonians</a><ul>
<li><a class="reference internal" href="#methods-for-writing-time-dependent-operators">Methods for Writing Time-Dependent Operators</a></li>
<li><a class="reference internal" href="#function-based-time-dependence">Function Based Time Dependence</a><ul>
<li><a class="reference internal" href="#using-the-args-variable">Using the args variable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#string-format-method">String Format Method</a></li>
<li><a class="reference internal" href="#reusing-time-dependent-hamiltonian-data">Reusing Time-Dependent Hamiltonian Data</a></li>
<li><a class="reference internal" href="#running-string-based-time-dependent-problems-using-parfor">Running String-Based Time-Dependent Problems using Parfor</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="dynamics-bloch-redfield.html" title="Previous Chapter: Bloch-Redfield master equation"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Bloch-Redfield m...</span>
    </a>
  </li>
  <li>
    <a href="dynamics-floquet.html" title="Next Chapter: Floquet Formalism"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Floquet Formalis... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="solving-problems-with-time-dependent-hamiltonians">
<span id="time"></span><h1>Solving Problems with Time-dependent Hamiltonians<a class="headerlink" href="#solving-problems-with-time-dependent-hamiltonians" title="Permalink to this headline">¶</a></h1>
<div class="section" id="methods-for-writing-time-dependent-operators">
<h2>Methods for Writing Time-Dependent Operators<a class="headerlink" href="#methods-for-writing-time-dependent-operators" title="Permalink to this headline">¶</a></h2>
<p>In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians.  However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.  The two main evolution solvers in QuTiP, <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mesolve" title="qutip.mesolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mesolve</span></tt></a> and <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mcsolve</span></tt></a>, discussed in <a class="reference internal" href="dynamics-master.html#master"><em>Lindblad Master Equation Solver</em></a> and <a class="reference internal" href="dynamics-monte.html#monte"><em>Monte Carlo Solver</em></a> respectively, are capable of handling time-dependent Hamiltonians and collapse terms.  There are, in general, three different ways to implement time-dependent problems in QuTiP:</p>
<ol class="arabic simple">
<li><strong>Function based</strong>: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.</li>
<li><strong>String (Cython) based</strong>: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings.  The resulting Hamiltonian is then compiled into C code using Cython and executed.</li>
<li><strong>Hamiltonian function (outdated)</strong>: The Hamiltonian is itself a Python function with time-dependence.  Collapse operators must be time independent using this input format.</li>
</ol>
<p>Give the multiple choices of input style, the first question that arrises is which option to choose?  In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions.  However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster.  Of course, for small system sizes and evolution times, the difference will be minor.  Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter.  Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C-code:</p>
<div class="highlight-python"><div class="highlight"><pre>&#39;abs&#39;, &#39;acos&#39;, &#39;acosh&#39;, &#39;arg&#39;, &#39;asin&#39;, &#39;asinh&#39;, &#39;atan&#39;, &#39;atan2&#39;, &#39;atanh&#39;, &#39;conj&#39;,
&#39;cos&#39;, &#39;cosh&#39;,&#39;exp&#39;, &#39;imag&#39;, &#39;log&#39;, &#39;pow&#39;, &#39;proj, &#39;real&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;,
&#39;tan&#39;, &#39;tanh&#39;
</pre></div>
</div>
<p>If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix <tt class="docutils literal"><span class="pre">np.</span></tt> before the function name in the string, i.e <tt class="docutils literal"><span class="pre">'np.sin(t)'</span></tt>.  The available functions can be found using</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [1]: </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="gp">In [2]: </span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="p">)[</span><span class="mi">6</span><span class="p">:])</span>
<span class="gh">Out[2]: </span><span class="go"></span>
<span class="go">array([&#39;asin&#39;, &#39;asinh&#39;, &#39;atan&#39;, &#39;atan2&#39;, &#39;atanh&#39;, &#39;ceil&#39;, &#39;copysign&#39;,</span>
<span class="go">       &#39;cos&#39;, &#39;cosh&#39;, &#39;degrees&#39;, &#39;e&#39;, &#39;erf&#39;, &#39;erfc&#39;, &#39;exp&#39;, &#39;expm1&#39;,</span>
<span class="go">       &#39;fabs&#39;, &#39;factorial&#39;, &#39;floor&#39;, &#39;fmod&#39;, &#39;frexp&#39;, &#39;fsum&#39;, &#39;gamma&#39;,</span>
<span class="go">       &#39;hypot&#39;, &#39;isinf&#39;, &#39;isnan&#39;, &#39;ldexp&#39;, &#39;lgamma&#39;, &#39;log&#39;, &#39;log10&#39;,</span>
<span class="go">       &#39;log1p&#39;, &#39;modf&#39;, &#39;pi&#39;, &#39;pow&#39;, &#39;radians&#39;, &#39;sin&#39;, &#39;sinh&#39;, &#39;sqrt&#39;,</span>
<span class="go">       &#39;tan&#39;, &#39;tanh&#39;, &#39;trunc&#39;], </span>
<span class="go">      dtype=&#39;|S9&#39;)</span>
</pre></div>
</div>
<p>Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x.  However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.</p>
<p>A collection of examples demonstrating the simulation of time-dependent problems can be found on the <a class="reference external" href="http://qutip.org/tutorials.html">tutorials</a> web page.</p>
</div>
<div class="section" id="function-based-time-dependence">
<span id="time-function"></span><h2>Function Based Time Dependence<a class="headerlink" href="#function-based-time-dependence" title="Permalink to this headline">¶</a></h2>
<p>A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients.  To accomplish this, we need to write a Python function that returns the time-dependent coefficient.  Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function.  To do this, one needs to specify operator-function pairs in list format: <tt class="docutils literal"><span class="pre">[Op,</span> <span class="pre">py_coeff]</span></tt>, where <tt class="docutils literal"><span class="pre">Op</span></tt> is a given Hamiltonian or collapse operator and <tt class="docutils literal"><span class="pre">py_coeff</span></tt> is the name of the Python function representing the coefficient.  With this format, the form of the Hamiltonian for both <tt class="docutils literal"><span class="pre">mesolve</span></tt> and <tt class="docutils literal"><span class="pre">mcsolve</span></tt> is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">py_coeff1</span><span class="p">],</span> <span class="p">[</span><span class="n">H2</span><span class="p">,</span> <span class="n">py_coeff2</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">H0</span></tt> is a time-independent Hamiltonian, while <tt class="docutils literal"><span class="pre">H1</span></tt>,``H2``, are time dependent. The same format can be used for collapse operators:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">c_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">C0</span><span class="p">,</span> <span class="n">py_coeff0</span><span class="p">],</span> <span class="n">C1</span><span class="p">,</span> <span class="p">[</span><span class="n">C2</span><span class="p">,</span> <span class="n">py_coeff2</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
</pre></div>
</div>
<p>Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter.  In addition, any or all of the collapse operators may be time dependent.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first.</p>
</div>
<p>As an example, we will look at an example that has a time-dependent Hamiltonian of the form <span class="math">\(H=H_{0}-f(t)H_{1}\)</span> where <span class="math">\(f(t)\)</span> is the time-dependent driving strength given as <span class="math">\(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\)</span>.  The follow code sets up the problem</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [3]: </span><span class="n">ustate</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="gp">In [4]: </span><span class="n">excited</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="gp">In [5]: </span><span class="n">ground</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="gp">In [6]: </span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="c"># Set where to truncate Fock state for cavity</span>

<span class="gp">In [7]: </span><span class="n">sigma_ge</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">qeye</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">ground</span> <span class="o">*</span> <span class="n">excited</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>  <span class="c"># |g&gt;&lt;e|</span>

<span class="gp">In [8]: </span><span class="n">sigma_ue</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">qeye</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">ustate</span> <span class="o">*</span> <span class="n">excited</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>  <span class="c"># |u&gt;&lt;e|</span>

<span class="gp">In [9]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

<span class="gp">In [10]: </span><span class="n">ada</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">num</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

<span class="gp">In [11]: </span><span class="n">c_ops</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c"># Build collapse operators</span>

<span class="gp">In [12]: </span><span class="n">kappa</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="c"># Cavity decay rate</span>

<span class="gp">In [13]: </span><span class="n">c_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>

<span class="gp">In [14]: </span><span class="n">gamma</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c"># Atomic decay rate</span>

<span class="gp">In [15]: </span><span class="n">c_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">gamma</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma_ue</span><span class="p">)</span> <span class="c"># Use Rb branching ratio of 5/9 e-&gt;u</span>

<span class="gp">In [16]: </span><span class="n">c_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">gamma</span><span class="o">/</span><span class="mi">9</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma_ge</span><span class="p">)</span> <span class="c"># 4/9 e-&gt;g</span>

<span class="gp">In [17]: </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="c"># Define time vector</span>

<span class="gp">In [18]: </span><span class="n">psi0</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ustate</span><span class="p">)</span> <span class="c"># Define initial state</span>

<span class="gp">In [19]: </span><span class="n">state_GG</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ground</span><span class="p">)</span> <span class="c"># Define states onto which to project</span>

<span class="gp">In [20]: </span><span class="n">sigma_GG</span> <span class="o">=</span> <span class="n">state_GG</span> <span class="o">*</span> <span class="n">state_GG</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>

<span class="gp">In [21]: </span><span class="n">state_UU</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">(</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ustate</span><span class="p">)</span>

<span class="gp">In [22]: </span><span class="n">sigma_UU</span> <span class="o">=</span> <span class="n">state_UU</span> <span class="o">*</span> <span class="n">state_UU</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>

<span class="gp">In [23]: </span><span class="n">g</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c"># coupling strength</span>

<span class="gp">In [24]: </span><span class="n">H0</span> <span class="o">=</span> <span class="o">-</span><span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma_ge</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">sigma_ge</span><span class="p">)</span>  <span class="c"># time-independent term</span>

<span class="gp">In [25]: </span><span class="n">H1</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma_ue</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">+</span> <span class="n">sigma_ue</span><span class="p">)</span>  <span class="c"># time-dependent term</span>
</pre></div>
</div>
<p>Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient <span class="math">\(f(t)\)</span>.  In this case, one can simply do</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [26]: </span><span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="mf">5.</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>In this case, the return value dependents only on time.  However, when specifying Python functions for coefficients, <strong>the function must have (t,args) as the input variables, in that order</strong>.  Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mesolve" title="qutip.mesolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mesolve</span></tt></a>)</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [27]: </span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,[</span><span class="n">H1</span><span class="p">,</span><span class="n">H1_coeff</span><span class="p">]]</span>

<span class="gp">In [28]: </span><span class="n">output</span> <span class="o">=</span> <span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">ada</span><span class="p">,</span> <span class="n">sigma_UU</span><span class="p">,</span> <span class="n">sigma_GG</span><span class="p">])</span>
</pre></div>
</div>
<p>We can call the Monte Carlo solver in the exact same way (if using the default <tt class="docutils literal"><span class="pre">ntraj=500</span></tt>):</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [29]: </span><span class="n">output</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">ada</span><span class="p">,</span> <span class="n">sigma_UU</span><span class="p">,</span> <span class="n">sigma_GG</span><span class="p">])</span>
<span class="go">10.0%. Run time:   0.56s. Est. time left: 00:00:00:05</span>
<span class="go">20.0%. Run time:   1.08s. Est. time left: 00:00:00:04</span>
<span class="go">30.0%. Run time:   1.64s. Est. time left: 00:00:00:03</span>
<span class="go">40.0%. Run time:   2.31s. Est. time left: 00:00:00:03</span>
<span class="go">50.0%. Run time:   2.90s. Est. time left: 00:00:00:02</span>
<span class="go">60.0%. Run time:   3.49s. Est. time left: 00:00:00:02</span>
<span class="go">70.0%. Run time:   4.10s. Est. time left: 00:00:00:01</span>
<span class="go">80.0%. Run time:   4.65s. Est. time left: 00:00:00:01</span>
<span class="go">90.0%. Run time:   5.22s. Est. time left: 00:00:00:00</span>
<span class="go">100.0%. Run time:   5.80s. Est. time left: 00:00:00:00</span>
<span class="go">Total run time:   5.92s</span>
</pre></div>
</div>
<p>The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example.  In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [30]: </span><span class="n">kappa</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="gp">In [31]: </span><span class="k">def</span> <span class="nf">col_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>  <span class="c"># coefficient function</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">))</span>
<span class="gp">   ....: </span>

<span class="gp">In [32]: </span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c"># number of basis states</span>

<span class="gp">In [33]: </span><span class="n">a</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="gp">In [34]: </span><span class="n">H</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span>  <span class="c"># simple HO</span>

<span class="gp">In [35]: </span><span class="n">psi0</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>  <span class="c"># initial state</span>

<span class="gp">In [36]: </span><span class="n">c_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="n">col_coeff</span><span class="p">]]</span>  <span class="c"># time-dependent collapse term</span>

<span class="gp">In [37]: </span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="gp">In [38]: </span><span class="n">output</span> <span class="o">=</span> <span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">])</span>
</pre></div>
</div>
<div class="section" id="using-the-args-variable">
<h3>Using the args variable<a class="headerlink" href="#using-the-args-variable" title="Permalink to this headline">¶</a></h3>
<p>In the previous example we hardcoded all of the variables, driving amplitude <span class="math">\(A\)</span> and width <span class="math">\(\sigma\)</span>, with their numerical values.  This is fine for problems that are specialized, or that we only want to run once.  However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run.  QuTiP allows you to accomplish this using the keyword <tt class="docutils literal"><span class="pre">args</span></tt> as an input to the solvers.  For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make us of the args variable</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [39]: </span><span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">args</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>or equivalently,</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [40]: </span><span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">A</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">]</span>
<span class="gp">   ....: </span>    <span class="n">sig</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="s">&#39;sigma&#39;</span><span class="p">]</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="n">sig</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>where args is a Python dictionary of <tt class="docutils literal"><span class="pre">key:</span> <span class="pre">value</span></tt> pairs <tt class="docutils literal"><span class="pre">args</span> <span class="pre">=</span> <span class="pre">{'A':</span> <span class="pre">a,</span> <span class="pre">'sigma':</span> <span class="pre">b}</span></tt> where <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> are the two parameters for the amplitude and width, respectively.  Of course, we can always hardcode the values in the dictionary as well <tt class="docutils literal"><span class="pre">args</span> <span class="pre">=</span> <span class="pre">{'A':</span> <span class="pre">9,</span> <span class="pre">'sigma':</span> <span class="pre">5}</span></tt>, but there is much more flexibility by using variables in <tt class="docutils literal"><span class="pre">args</span></tt>.  To let the solvers know that we have a set of args to pass we append the <tt class="docutils literal"><span class="pre">args</span></tt> to the end of the solver input:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [41]: </span><span class="n">output</span> <span class="o">=</span> <span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&#39;sigma&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">})</span>
</pre></div>
</div>
<p>or to keep things looking pretty</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [42]: </span><span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&#39;sigma&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>

<span class="gp">In [43]: </span><span class="n">output</span> <span class="o">=</span> <span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>Once again, the Monte Carlo solver <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mcsolve</span></tt></a> works in an identical manner.</p>
</div>
</div>
<div class="section" id="string-format-method">
<span id="time-string"></span><h2>String Format Method<a class="headerlink" href="#string-format-method" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You must have Cython installed on your computer to use this format.  See <a class="reference internal" href="../../installation.html#install"><em>Installation</em></a> for instructions on installing Cython.</p>
</div>
<p>The string-based time-dependent format works in a similar manner as the previously discussed Python function method.  That being said, the underlying code does something completely different.  When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code.  The details of this meta-programming will be published in due course.  however, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.</p>
<p>Like the previous method, the string-based format uses a list pair format <tt class="docutils literal"><span class="pre">[Op,</span> <span class="pre">str]</span></tt> where <tt class="docutils literal"><span class="pre">str</span></tt> is now a string representing the time-dependent coefficient.  For our first example, this string would be <tt class="docutils literal"><span class="pre">'9</span> <span class="pre">*</span> <span class="pre">exp(-(t</span> <span class="pre">/</span> <span class="pre">5.)</span> <span class="pre">**</span> <span class="pre">2)'</span></tt>.  The Hamiltonian in this format would take the form:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [44]: </span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s">&#39;9 * exp(-(t / 5) ** 2)&#39;</span><span class="p">]]</span>
</pre></div>
</div>
<p>Notice that this is a valid Hamiltonian for the string-based format as <tt class="docutils literal"><span class="pre">exp</span></tt> is included in the above list of suitable functions. Calling the solvers is the same as before:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [45]: </span><span class="n">output</span> <span class="o">=</span> <span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">])</span>
</pre></div>
</div>
<p>We can also use the <tt class="docutils literal"><span class="pre">args</span></tt> variable in the same manner as before, however we must rewrite our string term to read: <tt class="docutils literal"><span class="pre">'A</span> <span class="pre">*</span> <span class="pre">exp(-(t</span> <span class="pre">/</span> <span class="pre">sig)</span> <span class="pre">**</span> <span class="pre">2)'</span></tt></p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [46]: </span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s">&#39;A * exp(-(t / sig) ** 2)&#39;</span><span class="p">]]</span>

<span class="gp">In [47]: </span><span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&#39;sig&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>

<span class="gp">In [48]: </span><span class="n">output</span> <span class="o">=</span> <span class="n">mesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Naming your <tt class="docutils literal"><span class="pre">args</span></tt> variables <tt class="docutils literal"><span class="pre">e</span></tt>, <tt class="docutils literal"><span class="pre">j</span></tt> or <tt class="docutils literal"><span class="pre">pi</span></tt> will cause errors when using the string-based format.</p>
</div>
<p>Collapse operators are handled in the exact same way.</p>
</div>
<div class="section" id="reusing-time-dependent-hamiltonian-data">
<h2>Reusing Time-Dependent Hamiltonian Data<a class="headerlink" href="#reusing-time-dependent-hamiltonian-data" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This section covers a specialized topic and may be skipped if you are new to QuTiP.</p>
</div>
<p>When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation.  To turn on the the reuse features, we must pass a <tt class="xref py py-class docutils literal"><span class="pre">qutip.Options</span></tt> object with the <tt class="docutils literal"><span class="pre">rhs_reuse</span></tt> flag turned on.  Instructions on setting flags are found in <a class="reference internal" href="dynamics-options.html#options"><em>Setting Options for the Dynamics Solvers</em></a>.  For example, we can do</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [49]: </span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s">&#39;A * exp(-(t / sig) ** 2)&#39;</span><span class="p">]]</span>

<span class="gp">In [50]: </span><span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&#39;sig&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>

<span class="gp">In [51]: </span><span class="n">output</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
<span class="go">10.0%. Run time:   0.36s. Est. time left: 00:00:00:03</span>
<span class="go">20.0%. Run time:   0.64s. Est. time left: 00:00:00:02</span>
<span class="go">30.0%. Run time:   0.93s. Est. time left: 00:00:00:02</span>
<span class="go">40.0%. Run time:   1.21s. Est. time left: 00:00:00:01</span>
<span class="go">50.0%. Run time:   1.48s. Est. time left: 00:00:00:01</span>
<span class="go">60.0%. Run time:   1.76s. Est. time left: 00:00:00:01</span>
<span class="go">70.0%. Run time:   2.00s. Est. time left: 00:00:00:00</span>
<span class="go">80.0%. Run time:   2.23s. Est. time left: 00:00:00:00</span>
<span class="go">90.0%. Run time:   2.46s. Est. time left: 00:00:00:00</span>
<span class="go">100.0%. Run time:   2.71s. Est. time left: 00:00:00:00</span>
<span class="go">Total run time:   2.81s</span>

<span class="gp">In [52]: </span><span class="n">opts</span> <span class="o">=</span> <span class="n">Options</span><span class="p">(</span><span class="n">rhs_reuse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="gp">In [53]: </span><span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&#39;sig&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>

<span class="gp">In [54]: </span><span class="n">output</span> <span class="o">=</span> <span class="n">mcsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span><span class="o">*</span><span class="n">a</span><span class="p">],</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">opts</span><span class="p">)</span>
<span class="go">10.0%. Run time:   0.28s. Est. time left: 00:00:00:02</span>
<span class="go">20.0%. Run time:   0.53s. Est. time left: 00:00:00:02</span>
<span class="go">30.0%. Run time:   0.78s. Est. time left: 00:00:00:01</span>
<span class="go">40.0%. Run time:   1.09s. Est. time left: 00:00:00:01</span>
<span class="go">50.0%. Run time:   1.37s. Est. time left: 00:00:00:01</span>
<span class="go">60.0%. Run time:   1.67s. Est. time left: 00:00:00:01</span>
<span class="go">70.0%. Run time:   1.96s. Est. time left: 00:00:00:00</span>
<span class="go">80.0%. Run time:   2.35s. Est. time left: 00:00:00:00</span>
<span class="go">90.0%. Run time:   2.72s. Est. time left: 00:00:00:00</span>
<span class="go">100.0%. Run time:   2.99s. Est. time left: 00:00:00:00</span>
<span class="go">Total run time:   3.03s</span>
</pre></div>
</div>
<p>The second call to <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mcsolve</span></tt></a> does not reorganize the data, and in the case of the string format, does not recompile the Cython code.  For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up.</p>
</div>
<div class="section" id="running-string-based-time-dependent-problems-using-parfor">
<span id="time-parallel"></span><h2>Running String-Based Time-Dependent Problems using Parfor<a class="headerlink" href="#running-string-based-time-dependent-problems-using-parfor" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This section covers a specialized topic and may be skipped if you are new to QuTiP.</p>
</div>
<p>In this section we discuss running string-based time-dependent problems using the <tt class="xref py py-func docutils literal"><span class="pre">qutip.parfor</span></tt> function.  As the <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mcsolve</span></tt></a> function is already parallelized, running string-based time dependent problems inside of parfor loops should be restricted to the <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mesolve" title="qutip.mesolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mesolve</span></tt></a> function only. When using the string-based format, the system Hamiltonian and collapse operators are converted into C code with a specific file name that is automatically genrated, or supplied by the user via the <tt class="docutils literal"><span class="pre">rhs_filename</span></tt> property of the <tt class="xref py py-class docutils literal"><span class="pre">qutip.Options</span></tt> class. Because the <tt class="xref py py-func docutils literal"><span class="pre">qutip.parfor</span></tt> function uses the built-in Python multiprocessing functionality, in calling the solver inside a parfor loop, each thread will try to generate compiled code with the same file name, leading to a crash.  To get around this problem you can call the <a class="reference internal" href="../../apidoc/functions.html#qutip.rhs_generate" title="qutip.rhs_generate"><tt class="xref py py-func docutils literal"><span class="pre">qutip.rhs_generate</span></tt></a> function to compile simulation into C code before calling parfor.  You <strong>must</strong> then set the <tt class="xref py py-class docutils literal"><span class="pre">qutip.Odedata</span></tt> object <tt class="docutils literal"><span class="pre">rhs_reuse=True</span></tt> for all solver calls inside the parfor loop that indicates that a valid C code file already exists and a new one should not be generated.  As an example, we will look at the Landau-Zener-Stuckelberg interferometry example that can be found in the notebook &#8220;Time-dependent master equation: Landau-Zener-Stuckelberg inteferometry&#8221; in the tutorials section of the QuTiP web site.</p>
<p>To set up the problem, we run the following code:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [55]: </span><span class="n">delta</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="c"># qubit sigma_x coefficient</span>

<span class="gp">In [56]: </span><span class="n">w</span> <span class="o">=</span> <span class="mf">2.0</span>  <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>      <span class="c"># driving frequency</span>

<span class="gp">In [57]: </span><span class="n">T</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">w</span>         <span class="c"># driving period</span>

<span class="gp">In [58]: </span><span class="n">gamma1</span> <span class="o">=</span> <span class="mf">0.00001</span>          <span class="c"># relaxation rate</span>

<span class="gp">In [59]: </span><span class="n">gamma2</span> <span class="o">=</span> <span class="mf">0.005</span>            <span class="c"># dephasing  rate</span>

<span class="gp">In [60]: </span><span class="n">eps_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>  <span class="c"># epsilon</span>

<span class="gp">In [61]: </span><span class="n">A_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>      <span class="c"># Amplitude</span>

<span class="gp">In [62]: </span><span class="n">sx</span> <span class="o">=</span> <span class="n">sigmax</span><span class="p">();</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">sigmaz</span><span class="p">();</span> <span class="n">sm</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">sn</span> <span class="o">=</span> <span class="n">num</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="gp">In [63]: </span><span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gamma1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gamma2</span><span class="p">)</span> <span class="o">*</span> <span class="n">sz</span><span class="p">]</span>  <span class="c"># relaxation and dephasing</span>

<span class="gp">In [64]: </span><span class="n">H0</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">sx</span>

<span class="gp">In [65]: </span><span class="n">H1</span> <span class="o">=</span> <span class="p">[</span><span class="n">sz</span><span class="p">,</span> <span class="s">&#39;-eps / 2.0 + A / 2.0 * sin(w * t)&#39;</span><span class="p">]</span>

<span class="gp">In [66]: </span><span class="n">H_td</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="n">H1</span><span class="p">]</span>

<span class="gp">In [67]: </span><span class="n">Hargs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;w&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">,</span> <span class="s">&#39;eps&#39;</span><span class="p">:</span> <span class="n">eps_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="n">A_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
</pre></div>
</div>
<p>where the last code block sets up the problem using a string-based Hamiltonian, and <tt class="docutils literal"><span class="pre">Hargs</span></tt> is a dictionary of arguments to be passed into the Hamiltonian.  In this example, we are going to use the <a class="reference internal" href="../../apidoc/functions.html#module-qutip.propagator" title="qutip.propagator"><tt class="xref py py-func docutils literal"><span class="pre">qutip.propagator</span></tt></a> and <a class="reference internal" href="../../apidoc/functions.html#qutip.propagator.propagator_steadystate" title="qutip.propagator.propagator_steadystate"><tt class="xref py py-func docutils literal"><span class="pre">qutip.propagator.propagator_steadystate</span></tt></a> to find expectation
values for different values of <span class="math">\(\epsilon\)</span> and <span class="math">\(A\)</span> in the
Hamiltonian <span class="math">\(H = -\frac{1}{2}\Delta\sigma_x -\frac{1}{2}\epsilon\sigma_z- \frac{1}{2}A\sin(\omega t)\)</span>.</p>
<p>We must now tell the <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mesolve" title="qutip.mesolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mesolve</span></tt></a> function, that is called by <a class="reference internal" href="../../apidoc/functions.html#module-qutip.propagator" title="qutip.propagator"><tt class="xref py py-func docutils literal"><span class="pre">qutip.propagator</span></tt></a> to reuse a
pre-generated Hamiltonian constructed using the <a class="reference internal" href="../../apidoc/functions.html#qutip.rhs_generate" title="qutip.rhs_generate"><tt class="xref py py-func docutils literal"><span class="pre">qutip.rhs_generate</span></tt></a> command:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [68]: </span><span class="n">opts</span> <span class="o">=</span> <span class="n">Options</span><span class="p">(</span><span class="n">rhs_reuse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="gp">In [69]: </span><span class="n">rhs_generate</span><span class="p">(</span><span class="n">H_td</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">Hargs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;lz_func&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, we have given the generated file a custom name <tt class="docutils literal"><span class="pre">lz_func</span></tt>, however this is not necessary as a generic name will automatically be given.  Now we define the function <tt class="docutils literal"><span class="pre">task</span></tt> that is called by <a class="reference internal" href="../../apidoc/functions.html#qutip.parallel.parfor" title="qutip.parallel.parfor"><tt class="xref py py-func docutils literal"><span class="pre">qutip.parallel.parfor</span></tt></a> with the m-index parallelized in loop over the elements of <tt class="docutils literal"><span class="pre">p_mat[m,n]</span></tt>:</p>
<div class="highlight-ipython"><div class="highlight"><pre><span class="gp">In [70]: </span><span class="k">def</span> <span class="nf">task</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">m</span><span class="p">,</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">args</span>
<span class="gp">   ....: </span>    <span class="n">p_mat_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A_list</span><span class="p">))</span>
<span class="gp">   ....: </span>    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">A</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_list</span><span class="p">):</span>
<span class="gp">   ....: </span>        <span class="c"># change args sent to solver, w is really a constant though.</span>
<span class="gp">   ....: </span>        <span class="n">Hargs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;w&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">,</span> <span class="s">&#39;eps&#39;</span><span class="p">:</span> <span class="n">eps</span><span class="p">,</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">}</span>
<span class="gp">   ....: </span>        <span class="n">U</span> <span class="o">=</span> <span class="n">propagator</span><span class="p">(</span><span class="n">H_td</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">Hargs</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span> <span class="c">#&lt;- IMPORTANT LINE</span>
<span class="gp">   ....: </span>        <span class="n">rho_ss</span> <span class="o">=</span> <span class="n">propagator_steadystate</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
<span class="gp">   ....: </span>        <span class="n">p_mat_m</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">expect</span><span class="p">(</span><span class="n">sn</span><span class="p">,</span> <span class="n">rho_ss</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">p_mat_m</span><span class="p">]</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<p>Notice the Options <tt class="docutils literal"><span class="pre">opts</span></tt> in the call to the <a class="reference internal" href="../../apidoc/functions.html#module-qutip.propagator" title="qutip.propagator"><tt class="xref py py-func docutils literal"><span class="pre">qutip.propagator</span></tt></a> function.  This is tells the <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mesolve" title="qutip.mesolve"><tt class="xref py py-func docutils literal"><span class="pre">qutip.mesolve</span></tt></a> function used in the propagator to call the pre-generated file <tt class="docutils literal"><span class="pre">lz_func</span></tt>. If this were missing then the routine would fail.</p>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2011 and later, P.D. Nation, J.R. Johansson.<br/>
      Last updated on Dec 31, 2014.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>