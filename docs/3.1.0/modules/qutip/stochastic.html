
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>qutip.stochastic &mdash; QuTiP 3.1.0 Documentation</title>
    
    <link rel="stylesheet" href="../../static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../static/bootswatch-3.2.0/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../../static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../static/site.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '3.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../static/jquery.js"></script>
    <script type="text/javascript" src="../../static/underscore.js"></script>
    <script type="text/javascript" src="../../static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../static/bootstrap-3.2.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../static/favicon.ico"/>
    <link rel="top" title="QuTiP 3.1.0 Documentation" href="../../index.html" />
    <link rel="up" title="qutip" href="../qutip.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          QuTiP</a>
        <span class="navbar-text navbar-version pull-left"><b>3.1.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="http://qutip.org">qutip.org</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Docs <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../frontmatter.html">Frontmatter</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../frontmatter.html#about-this-documentation">About This Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../frontmatter.html#citing-this-project">Citing This Project</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../frontmatter.html#funding">Funding</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../frontmatter.html#about-qutip">About QuTiP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../frontmatter.html#contributing-to-qutip">Contributing to QuTiP</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#general-requirements">General Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#platform-independent-installation">Platform-independent installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#get-the-source-code">Get the source code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installing-from-source">Installing from source</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installation-on-ubuntu-linux">Installation on Ubuntu Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installation-on-mac-os-x-10-8">Installation on Mac OS X (10.8+)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installation-on-windows">Installation on Windows</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#optional-installation-options">Optional Installation Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#verifying-the-installation">Verifying the Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#checking-version-information-using-the-about-function">Checking Version Information using the About Function</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../guide/guide.html">Users Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-overview.html">Guide Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-basics.html">Basic Operations on Quantum Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-states.html">Manipulating States and Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-tensor.html">Using Tensor Products and Partial Traces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-dynamics.html">Time Evolution and Quantum System Dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-steady.html">Solving for Steady-State Solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-eseries.html">An Overview of the Eseries Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-correlation.html">Two-time correlation functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-bloch.html">Plotting on the Bloch Sphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-visualization.html">Visualization of quantum states and processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-parfor.html">Parallel computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-saving.html">Saving QuTiP Objects and Data Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-random.html">Generating Random Quantum States &amp; Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../guide/guide-settings.html">Modifying Internal QuTiP Settings</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/apidoc.html">API documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../apidoc/classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../apidoc/functions.html">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Change Log</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-3-1-0-january-1-2015">Version 3.1.0 (January 1, 2015):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-3-0-1-aug-5-2014">Version 3.0.1 (Aug 5, 2014):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-3-0-0-july-17-2014">Version 3.0.0 (July 17, 2014):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-2-2-0-march-01-2013">Version 2.2.0 (March 01, 2013):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-2-1-0-october-05-2012">Version 2.1.0 (October 05, 2012):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-2-0-0-june-01-2012">Version 2.0.0 (June 01, 2012):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-1-1-4-may-28-2012">Version 1.1.4 (May 28, 2012):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-1-1-3-november-21-2011">Version 1.1.3 (November 21, 2011):</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-1-1-2-october-27-2011">Version 1.1.2 (October 27, 2011)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-1-1-1-october-25-2011">Version 1.1.1 (October 25, 2011)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-1-1-0-october-04-2011">Version 1.1.0 (October 04, 2011)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../changelog.html#version-1-0-0-july-29-2011">Version 1.0.0 (July 29, 2011)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Developers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../contributors.html#lead-developers">Lead Developers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributors.html#contributors">Contributors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../biblio.html">Bibliography</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <h1>Source code for qutip.stochastic</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c">#</span>
<span class="c"># This file is part of QuTiP: Quantum Toolbox in Python.</span>
<span class="c">#</span>
<span class="c">#    Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.</span>
<span class="c">#    All rights reserved.</span>
<span class="c">#</span>
<span class="c">#    Redistribution and use in source and binary forms, with or without</span>
<span class="c">#    modification, are permitted provided that the following conditions are</span>
<span class="c">#    met:</span>
<span class="c">#</span>
<span class="c">#    1. Redistributions of source code must retain the above copyright notice,</span>
<span class="c">#       this list of conditions and the following disclaimer.</span>
<span class="c">#</span>
<span class="c">#    2. Redistributions in binary form must reproduce the above copyright</span>
<span class="c">#       notice, this list of conditions and the following disclaimer in the</span>
<span class="c">#       documentation and/or other materials provided with the distribution.</span>
<span class="c">#</span>
<span class="c">#    3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names</span>
<span class="c">#       of its contributors may be used to endorse or promote products derived</span>
<span class="c">#       from this software without specific prior written permission.</span>
<span class="c">#</span>
<span class="c">#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="c">#    &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="c">#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A</span>
<span class="c">#    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<span class="c">#    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="c">#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="c">#    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="c">#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="c">#    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="c">#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="c">#    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c">#</span>
<span class="c">#    Significant parts of this code were contributed by Denis Vasilyev.</span>
<span class="c">#</span>
<span class="c">###############################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains functions for solving stochastic schrodinger and master</span>
<span class="sd">equations. The API should not be considered stable, and is subject to change</span>
<span class="sd">when we work more on optimizing this module for performance and features.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;ssesolve&#39;</span><span class="p">,</span> <span class="s">&#39;ssepdpsolve&#39;</span><span class="p">,</span> <span class="s">&#39;smesolve&#39;</span><span class="p">,</span> <span class="s">&#39;smepdpsolve&#39;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">scipy.linalg.blas</span> <span class="kn">import</span> <span class="n">get_blas_funcs</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">get_blas_funcs</span><span class="p">(</span><span class="s">&quot;znrm2&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>

<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">RandomState</span>

<span class="kn">from</span> <span class="nn">qutip.qobj</span> <span class="kn">import</span> <span class="n">Qobj</span><span class="p">,</span> <span class="n">isket</span>
<span class="kn">from</span> <span class="nn">qutip.states</span> <span class="kn">import</span> <span class="n">ket2dm</span>
<span class="kn">from</span> <span class="nn">qutip.solver</span> <span class="kn">import</span> <span class="n">Result</span>
<span class="kn">from</span> <span class="nn">qutip.expect</span> <span class="kn">import</span> <span class="n">expect</span><span class="p">,</span> <span class="n">expect_rho_vec</span>
<span class="kn">from</span> <span class="nn">qutip.superoperator</span> <span class="kn">import</span> <span class="p">(</span><span class="n">spre</span><span class="p">,</span> <span class="n">spost</span><span class="p">,</span> <span class="n">mat2vec</span><span class="p">,</span> <span class="n">vec2mat</span><span class="p">,</span>
                                 <span class="n">liouvillian</span><span class="p">,</span> <span class="n">lindblad_dissipator</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">qutip.cy.spmatfuncs</span> <span class="kn">import</span> <span class="n">cy_expect_psi_csr</span><span class="p">,</span> <span class="n">spmv</span><span class="p">,</span> <span class="n">cy_expect_rho_vec</span>
<span class="kn">from</span> <span class="nn">qutip.cy.stochastic</span> <span class="kn">import</span> <span class="p">(</span><span class="n">cy_d1_rho_photocurrent</span><span class="p">,</span>
                                 <span class="n">cy_d2_rho_photocurrent</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">qutip.parallel</span> <span class="kn">import</span> <span class="n">serial_map</span>
<span class="kn">from</span> <span class="nn">qutip.ui.progressbar</span> <span class="kn">import</span> <span class="n">TextProgressBar</span>
<span class="kn">from</span> <span class="nn">qutip.solver</span> <span class="kn">import</span> <span class="n">Options</span>
<span class="kn">from</span> <span class="nn">qutip.settings</span> <span class="kn">import</span> <span class="n">debug</span>


<span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">qutip.logging</span>
    <span class="kn">import</span> <span class="nn">inspect</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span>


<div class="viewcode-block" id="StochasticSolverOptions"><a class="viewcode-back" href="../../apidoc/classes.html#qutip.stochastic.StochasticSolverOptions">[docs]</a><span class="k">class</span> <span class="nc">StochasticSolverOptions</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Class of options for stochastic solvers such as</span>
<span class="sd">    :func:`qutip.stochastic.ssesolve`, :func:`qutip.stochastic.smesolve`, etc.</span>
<span class="sd">    Options can be specified either as arguments to the constructor::</span>

<span class="sd">        sso = StochasticSolverOptions(nsubsteps=100, ...)</span>

<span class="sd">    or by changing the class attributes after creation::</span>

<span class="sd">        sso = StochasticSolverOptions()</span>
<span class="sd">        sso.nsubsteps = 1000</span>

<span class="sd">    The stochastic solvers :func:`qutip.stochastic.ssesolve`,</span>
<span class="sd">    :func:`qutip.stochastic.smesolve`, :func:`qutip.stochastic.ssepdpsolve` and</span>
<span class="sd">    :func:`qutip.stochastic.smepdpsolve` all take the same keyword arguments as</span>
<span class="sd">    the constructor of these class, and internally they use these arguments to</span>
<span class="sd">    construct an instance of this class, so it is rarely needed to explicitly</span>
<span class="sd">    create an instance of this class.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    H : :class:`qutip.Qobj`</span>
<span class="sd">        System Hamiltonian.</span>

<span class="sd">    state0 : :class:`qutip.Qobj`</span>
<span class="sd">        Initial state vector (ket) or density matrix.</span>

<span class="sd">    times : *list* / *array*</span>
<span class="sd">        List of times for :math:`t`. Must be uniformly spaced.</span>

<span class="sd">    c_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        List of deterministic collapse operators.</span>

<span class="sd">    sc_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        List of stochastic collapse operators. Each stochastic collapse</span>
<span class="sd">        operator will give a deterministic and stochastic contribution</span>
<span class="sd">        to the equation of motion according to how the d1 and d2 functions</span>
<span class="sd">        are defined.</span>

<span class="sd">    e_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        Single operator or list of operators for which to evaluate</span>
<span class="sd">        expectation values.</span>

<span class="sd">    m_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        List of operators representing the measurement operators. The expected</span>
<span class="sd">        format is a nested list with one measurement operator for each</span>
<span class="sd">        stochastic increament, for each stochastic collapse operator.</span>

<span class="sd">    args : dict / list</span>
<span class="sd">        List of dictionary of additional problem-specific parameters.</span>

<span class="sd">    ntraj : int</span>
<span class="sd">        Number of trajectors.</span>

<span class="sd">    nsubsteps : int</span>
<span class="sd">        Number of sub steps between each time-spep given in `times`.</span>

<span class="sd">    d1 : function</span>
<span class="sd">        Function for calculating the operator-valued coefficient to the</span>
<span class="sd">        deterministic increment dt.</span>

<span class="sd">    d2 : function</span>
<span class="sd">        Function for calculating the operator-valued coefficient to the</span>
<span class="sd">        stochastic increment(s) dW_n, where n is in [0, d2_len[.</span>

<span class="sd">    d2_len : int (default 1)</span>
<span class="sd">        The number of stochastic increments in the process.</span>

<span class="sd">    dW_factors : array</span>
<span class="sd">        Array of length d2_len, containing scaling factors for each</span>
<span class="sd">        measurement operator in m_ops.</span>

<span class="sd">    rhs : function</span>
<span class="sd">        Function for calculating the deterministic and stochastic contributions</span>
<span class="sd">        to the right-hand side of the stochastic differential equation. This</span>
<span class="sd">        only needs to be specified when implementing a custom SDE solver.</span>

<span class="sd">    generate_A_ops : function</span>
<span class="sd">        Function that generates a list of pre-computed operators or super-</span>
<span class="sd">        operators. These precomputed operators are used in some d1 and d2</span>
<span class="sd">        functions.</span>

<span class="sd">    generate_noise : function</span>
<span class="sd">        Function for generate an array of pre-computed noise signal.</span>

<span class="sd">    homogeneous : bool (True)</span>
<span class="sd">        Wheter or not the stochastic process is homogenous. Inhomogenous</span>
<span class="sd">        processes are only supported for poisson distributions.</span>

<span class="sd">    solver : string</span>
<span class="sd">        Name of the solver method to use for solving the stochastic</span>
<span class="sd">        equations. Valid values are: &#39;euler-maruyama&#39;, &#39;fast-euler-maruyama&#39;,</span>
<span class="sd">        &#39;milstein&#39;, &#39;fast-milstein&#39;, &#39;platen&#39;.</span>

<span class="sd">    method : string (&#39;homodyne&#39;, &#39;heterodyne&#39;, &#39;photocurrent&#39;)</span>
<span class="sd">        The name of the type of measurement process that give rise to the</span>
<span class="sd">        stochastic equation to solve. Specifying a method with this keyword</span>
<span class="sd">        argument is a short-hand notation for using pre-defined d1 and d2</span>
<span class="sd">        functions for the corresponding stochastic processes.</span>

<span class="sd">    distribution : string (&#39;normal&#39;, &#39;poission&#39;)</span>
<span class="sd">        The name of the distribution used for the stochastic increments.</span>

<span class="sd">    store_measurements : bool (default False)</span>
<span class="sd">        Whether or not to store the measurement results in the</span>
<span class="sd">        :class:`qutip.solver.SolverResult` instance returned by the solver.</span>

<span class="sd">    noise : array</span>
<span class="sd">        Vector specifying the noise.</span>

<span class="sd">    normalize : bool (default True)</span>
<span class="sd">        Whether or not to normalize the wave function during the evolution.</span>

<span class="sd">    options : :class:`qutip.solver.Options`</span>
<span class="sd">        Generic solver options.</span>

<span class="sd">    map_func: function</span>
<span class="sd">        A map function or managing the calls to single-trajactory solvers.</span>

<span class="sd">    map_kwargs: dictionary</span>
<span class="sd">        Optional keyword arguments to the map_func function function.</span>

<span class="sd">    progress_bar : :class:`qutip.ui.BaseProgressBar`</span>
<span class="sd">        Optional progress bar class instance.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">state0</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">c_ops</span><span class="o">=</span><span class="p">[],</span> <span class="n">sc_ops</span><span class="o">=</span><span class="p">[],</span>
                 <span class="n">e_ops</span><span class="o">=</span><span class="p">[],</span> <span class="n">m_ops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ntraj</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsubsteps</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">d1</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">d2</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">d2_len</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dW_factors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rhs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">generate_A_ops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">generate_noise</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">homogeneous</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">solver</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">distribution</span><span class="o">=</span><span class="s">&#39;normal&#39;</span><span class="p">,</span>
                 <span class="n">store_measurement</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">options</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">map_func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">map_kwargs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">=</span> <span class="n">Options</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">progress_bar</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">progress_bar</span> <span class="o">=</span> <span class="n">TextProgressBar</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">H</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="n">d2_len</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">dW_factors</span> <span class="k">if</span> <span class="n">dW_factors</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">d2_len</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state0</span> <span class="o">=</span> <span class="n">state0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_ops</span> <span class="o">=</span> <span class="n">c_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sc_ops</span> <span class="o">=</span> <span class="n">sc_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_ops</span> <span class="o">=</span> <span class="n">e_ops</span>

        <span class="k">if</span> <span class="n">m_ops</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">c</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d2_len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc_ops</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="n">m_ops</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ntraj</span> <span class="o">=</span> <span class="n">ntraj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsubsteps</span> <span class="o">=</span> <span class="n">nsubsteps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="n">distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="n">homogeneous</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">rhs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress_bar</span> <span class="o">=</span> <span class="n">progress_bar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_measurement</span> <span class="o">=</span> <span class="n">store_measurement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_states</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">store_states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">generate_noise</span> <span class="o">=</span> <span class="n">generate_noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">generate_A_ops</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ntraj</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">map_func</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map_func</span> <span class="o">=</span> <span class="n">map_func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map_func</span> <span class="o">=</span> <span class="n">serial_map</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">map_kwargs</span> <span class="o">=</span> <span class="n">map_kwargs</span> <span class="k">if</span> <span class="n">map_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="p">{}</span>

</div>
<div class="viewcode-block" id="ssesolve"><a class="viewcode-back" href="../../apidoc/functions.html#qutip.stochastic.ssesolve">[docs]</a><span class="k">def</span> <span class="nf">ssesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">sc_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve the stochastic Schrödinger equation. Dispatch to specific solvers</span>
<span class="sd">    depending on the value of the `solver` keyword argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    H : :class:`qutip.Qobj`</span>
<span class="sd">        System Hamiltonian.</span>

<span class="sd">    psi0 : :class:`qutip.Qobj`</span>
<span class="sd">        Initial state vector (ket).</span>

<span class="sd">    times : *list* / *array*</span>
<span class="sd">        List of times for :math:`t`. Must be uniformly spaced.</span>

<span class="sd">    sc_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        List of stochastic collapse operators. Each stochastic collapse</span>
<span class="sd">        operator will give a deterministic and stochastic contribution</span>
<span class="sd">        to the equation of motion according to how the d1 and d2 functions</span>
<span class="sd">        are defined.</span>

<span class="sd">    e_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        Single operator or list of operators for which to evaluate</span>
<span class="sd">        expectation values.</span>

<span class="sd">    kwargs : *dictionary*</span>
<span class="sd">        Optional keyword arguments. See</span>
<span class="sd">        :class:`qutip.stochastic.StochasticSolverOptions`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    output: :class:`qutip.solver.SolverResult`</span>
<span class="sd">        An instance of the class :class:`qutip.solver.SolverResult`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_ops</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="n">e_ops</span>
        <span class="n">e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">e_ops</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">sso</span> <span class="o">=</span> <span class="n">StochasticSolverOptions</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">state0</span><span class="o">=</span><span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span>
                                  <span class="n">sc_ops</span><span class="o">=</span><span class="n">sc_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">_generate_psi_A_ops</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;homodyne&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1_psi_homodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2_psi_homodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s">&#39;normal&#39;</span>
            <span class="k">if</span> <span class="s">&quot;dW_factors&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s">&quot;m_ops&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;heterodyne&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1_psi_heterodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2_psi_heterodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s">&#39;normal&#39;</span>
            <span class="k">if</span> <span class="s">&quot;dW_factors&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
            <span class="k">if</span> <span class="s">&quot;m_ops&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())]</span>
                             <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;photocurrent&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1_psi_photocurrent</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2_psi_photocurrent</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s">&#39;poisson&#39;</span>

            <span class="k">if</span> <span class="s">&quot;dW_factors&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s">&quot;m_ops&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Unrecognized method &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s">&#39;poisson&#39;</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;euler-maruyama&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_psi_euler_maruyama</span>

    <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;platen&#39;</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_psi_platen</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Unrecognized solver &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_ssesolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">progress_bar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e_ops_dict</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())}</span>

    <span class="k">return</span> <span class="n">res</span>

</div>
<div class="viewcode-block" id="smesolve"><a class="viewcode-back" href="../../apidoc/functions.html#qutip.stochastic.smesolve">[docs]</a><span class="k">def</span> <span class="nf">smesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">rho0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">sc_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve stochastic master equation. Dispatch to specific solvers</span>
<span class="sd">    depending on the value of the `solver` keyword argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    H : :class:`qutip.Qobj`</span>
<span class="sd">        System Hamiltonian.</span>

<span class="sd">    rho0 : :class:`qutip.Qobj`</span>
<span class="sd">        Initial density matrix or state vector (ket).</span>

<span class="sd">    times : *list* / *array*</span>
<span class="sd">        List of times for :math:`t`. Must be uniformly spaced.</span>

<span class="sd">    c_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        Deterministic collapse operator which will contribute with a standard</span>
<span class="sd">        Lindblad type of dissipation.</span>

<span class="sd">    sc_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        List of stochastic collapse operators. Each stochastic collapse</span>
<span class="sd">        operator will give a deterministic and stochastic contribution</span>
<span class="sd">        to the eqaution of motion according to how the d1 and d2 functions</span>
<span class="sd">        are defined.</span>

<span class="sd">    e_ops : list of :class:`qutip.Qobj` / callback function single</span>
<span class="sd">        single operator or list of operators for which to evaluate</span>
<span class="sd">        expectation values.</span>

<span class="sd">    kwargs : *dictionary*</span>
<span class="sd">        Optional keyword arguments. See</span>
<span class="sd">        :class:`qutip.stochastic.StochasticSolverOptions`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    output: :class:`qutip.solver.SolverResult`</span>

<span class="sd">        An instance of the class :class:`qutip.solver.SolverResult`.</span>

<span class="sd">    TODO</span>
<span class="sd">    ----</span>
<span class="sd">        Add checks for commuting jump operators in Milstein method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">isket</span><span class="p">(</span><span class="n">rho0</span><span class="p">):</span>
        <span class="n">rho0</span> <span class="o">=</span> <span class="n">ket2dm</span><span class="p">(</span><span class="n">rho0</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_ops</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="n">e_ops</span>
        <span class="n">e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">e_ops</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">sso</span> <span class="o">=</span> <span class="n">StochasticSolverOptions</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">state0</span><span class="o">=</span><span class="n">rho0</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="o">=</span><span class="n">c_ops</span><span class="p">,</span>
                                  <span class="n">sc_ops</span><span class="o">=</span><span class="n">sc_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;homodyne&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1_rho_homodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2_rho_homodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s">&#39;normal&#39;</span>
            <span class="k">if</span> <span class="s">&quot;dW_factors&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
            <span class="k">if</span> <span class="s">&quot;m_ops&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;heterodyne&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">d1_rho_heterodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">d2_rho_heterodyne</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s">&#39;normal&#39;</span>
            <span class="k">if</span> <span class="s">&quot;dW_factors&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
            <span class="k">if</span> <span class="s">&quot;m_ops&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()),</span> <span class="o">-</span><span class="mi">1j</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())]</span>
                             <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;photocurrent&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d1</span> <span class="o">=</span> <span class="n">cy_d1_rho_photocurrent</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2</span> <span class="o">=</span> <span class="n">cy_d2_rho_photocurrent</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">=</span> <span class="s">&#39;poisson&#39;</span>

            <span class="k">if</span> <span class="s">&quot;dW_factors&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="s">&quot;m_ops&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">None</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Unrecognized method &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s">&#39;poisson&#39;</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">_generate_rho_A_ops</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;euler-maruyama&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_euler_maruyama</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;milstein&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;homodyne&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne_single</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne</span>

            <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;heterodyne&#39;</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">):</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0j</span> <span class="o">*</span> <span class="n">sc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;fast-euler-maruyama&#39;</span> <span class="ow">and</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;homodyne&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_euler_homodyne_fast</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">_generate_A_ops_Euler</span>

        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span> <span class="o">==</span> <span class="s">&#39;fast-milstein&#39;</span><span class="p">:</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span> <span class="o">=</span> <span class="n">_generate_A_ops_Milstein</span>
            <span class="n">sso</span><span class="o">.</span><span class="n">generate_noise</span> <span class="o">=</span> <span class="n">_generate_noise_Milstein</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;homodyne&#39;</span> <span class="ow">or</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne_single_fast</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne_two_fast</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne_fast</span>

            <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;heterodyne&#39;</span><span class="p">:</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">):</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">sc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0j</span> <span class="o">*</span> <span class="n">sc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne_two_fast</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span> <span class="o">=</span> <span class="n">_rhs_rho_milstein_homodyne_fast</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Unrecognized solver &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="n">sso</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_smesolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">progress_bar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e_ops_dict</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())}</span>

    <span class="k">return</span> <span class="n">res</span>

</div>
<div class="viewcode-block" id="ssepdpsolve"><a class="viewcode-back" href="../../apidoc/functions.html#qutip.stochastic.ssepdpsolve">[docs]</a><span class="k">def</span> <span class="nf">ssepdpsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A stochastic (piecewse deterministic process) PDP solver for wavefunction</span>
<span class="sd">    evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum</span>
<span class="sd">    trajectory simulations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    H : :class:`qutip.Qobj`</span>
<span class="sd">        System Hamiltonian.</span>

<span class="sd">    psi0 : :class:`qutip.Qobj`</span>
<span class="sd">        Initial state vector (ket).</span>

<span class="sd">    times : *list* / *array*</span>
<span class="sd">        List of times for :math:`t`. Must be uniformly spaced.</span>

<span class="sd">    c_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        Deterministic collapse operator which will contribute with a standard</span>
<span class="sd">        Lindblad type of dissipation.</span>

<span class="sd">    e_ops : list of :class:`qutip.Qobj` / callback function single</span>
<span class="sd">        single operator or list of operators for which to evaluate</span>
<span class="sd">        expectation values.</span>

<span class="sd">    kwargs : *dictionary*</span>
<span class="sd">        Optional keyword arguments. See</span>
<span class="sd">        :class:`qutip.stochastic.StochasticSolverOptions`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    output: :class:`qutip.solver.SolverResult`</span>

<span class="sd">        An instance of the class :class:`qutip.solver.SolverResult`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_ops</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="n">e_ops</span>
        <span class="n">e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">e_ops</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">sso</span> <span class="o">=</span> <span class="n">StochasticSolverOptions</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">state0</span><span class="o">=</span><span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="o">=</span><span class="n">c_ops</span><span class="p">,</span>
                                  <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_ssepdpsolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">progress_bar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e_ops_dict</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())}</span>
    <span class="k">return</span> <span class="n">res</span>

</div>
<div class="viewcode-block" id="smepdpsolve"><a class="viewcode-back" href="../../apidoc/functions.html#qutip.stochastic.smepdpsolve">[docs]</a><span class="k">def</span> <span class="nf">smepdpsolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">rho0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A stochastic (piecewse deterministic process) PDP solver for density matrix</span>
<span class="sd">    evolution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    H : :class:`qutip.Qobj`</span>
<span class="sd">        System Hamiltonian.</span>

<span class="sd">    rho0 : :class:`qutip.Qobj`</span>
<span class="sd">        Initial density matrix.</span>

<span class="sd">    times : *list* / *array*</span>
<span class="sd">        List of times for :math:`t`. Must be uniformly spaced.</span>

<span class="sd">    c_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        Deterministic collapse operator which will contribute with a standard</span>
<span class="sd">        Lindblad type of dissipation.</span>

<span class="sd">    sc_ops : list of :class:`qutip.Qobj`</span>
<span class="sd">        List of stochastic collapse operators. Each stochastic collapse</span>
<span class="sd">        operator will give a deterministic and stochastic contribution</span>
<span class="sd">        to the eqaution of motion according to how the d1 and d2 functions</span>
<span class="sd">        are defined.</span>

<span class="sd">    e_ops : list of :class:`qutip.Qobj` / callback function single</span>
<span class="sd">        single operator or list of operators for which to evaluate</span>
<span class="sd">        expectation values.</span>

<span class="sd">    kwargs : *dictionary*</span>
<span class="sd">        Optional keyword arguments. See</span>
<span class="sd">        :class:`qutip.stochastic.StochasticSolverOptions`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    output: :class:`qutip.solver.SolverResult`</span>

<span class="sd">        An instance of the class :class:`qutip.solver.SolverResult`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_ops</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="n">e_ops</span>
        <span class="n">e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">e_ops</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">e_ops_dict</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">sso</span> <span class="o">=</span> <span class="n">StochasticSolverOptions</span><span class="p">(</span><span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">state0</span><span class="o">=</span><span class="n">rho0</span><span class="p">,</span> <span class="n">times</span><span class="o">=</span><span class="n">times</span><span class="p">,</span> <span class="n">c_ops</span><span class="o">=</span><span class="n">c_ops</span><span class="p">,</span>
                                  <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_smepdpsolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">progress_bar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e_ops_dict</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())}</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="c"># -----------------------------------------------------------------------------</span>
<span class="c"># Generic parameterized stochastic Schrodinger equation solver</span>
<span class="c">#</span></div>
<span class="k">def</span> <span class="nf">_ssesolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function for carrying out a sse integration. Used by ssesolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">nsubsteps</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">Result</span><span class="p">()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s">&quot;ssesolve&quot;</span>
    <span class="n">data</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data</span><span class="o">.</span><span class="n">measurement</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># pre-compute collapse operator combinations that are commonly needed</span>
    <span class="c"># when evaluating the RHS of stochastic Schrodinger equations</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">A_ops</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>

    <span class="n">map_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;progress_bar&#39;</span><span class="p">:</span> <span class="n">progress_bar</span><span class="p">}</span>
    <span class="n">map_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">map_kwargs</span><span class="p">)</span>

    <span class="n">task</span> <span class="o">=</span> <span class="n">_ssesolve_single_trajectory</span>
    <span class="n">task_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">sso</span><span class="p">,)</span>
    <span class="n">task_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">map_func</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="p">)),</span>
                           <span class="n">task_args</span><span class="p">,</span> <span class="n">task_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">map_kwargs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="n">states_list</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">expect</span><span class="p">,</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">result</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">states_list</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dW</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">measurement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">+=</span> <span class="n">expect</span>
        <span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">+=</span> <span class="n">ss</span>

    <span class="c"># average density matrices</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">average_states</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="n">ket2dm</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">mm</span><span class="p">][</span><span class="n">n</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">mm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">)])</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
                       <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">times</span><span class="p">))]</span>

    <span class="c"># average</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">/</span> <span class="n">nt</span>

    <span class="c"># standard error</span>
    <span class="k">if</span> <span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">-</span> <span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c"># convert complex data to real if hermitian</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:])</span>
                   <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">isherm</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:]</span>
                   <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_ssesolve_single_trajectory</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">sso</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function. See ssesolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">dt</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span>
    <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">d1</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">d2</span>
    <span class="n">d2_len</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span>
    <span class="n">e_ops</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span>
    <span class="n">H_data</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">data</span>
    <span class="n">A_ops</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">A_ops</span>

    <span class="n">expect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="n">psi_t</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">state0</span><span class="o">.</span><span class="n">full</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">state0</span><span class="o">.</span><span class="n">dims</span>

    <span class="c"># reseed the random number generator so that forked</span>
    <span class="c"># processes do not get the same sequence of random numbers</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4294967295</span> <span class="o">//</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s">&#39;normal&#39;</span><span class="p">:</span>
                <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">*</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span><span class="p">,</span>
                                    <span class="n">d2_len</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Unsupported increment distribution for &#39;</span> <span class="o">+</span>
                                <span class="s">&#39;homogeneous process.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">!=</span> <span class="s">&#39;poisson&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Unsupported increment distribution for &#39;</span> <span class="o">+</span>
                                <span class="s">&#39;inhomogeneous process.&#39;</span><span class="p">)</span>

            <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">A_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span><span class="p">,</span> <span class="n">d2_len</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dW</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="n">states_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">measurements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span><span class="p">),</span> <span class="n">d2_len</span><span class="p">),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">e_ops</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e_idx</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                      <span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span>
                                      <span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">expect</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span>
                <span class="n">ss</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">states_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qobj</span><span class="p">(</span><span class="n">psi_t</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="n">A</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_ops</span><span class="p">):</span>
                    <span class="c"># dw_expect = norm(spmv(A[0], psi_t)) ** 2 * dt</span>
                    <span class="n">dw_expect</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                  <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span>
                                                  <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
                    <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">dw_expect</span><span class="p">,</span>
                                                               <span class="n">d2_len</span><span class="p">)</span>

            <span class="n">psi_t</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span><span class="p">(</span><span class="n">H_data</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">j</span><span class="p">,</span>
                            <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">[:,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

            <span class="c"># optionally renormalize the wave function</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">normalize</span><span class="p">:</span>
                <span class="n">psi_t</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">store_measurement</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">dW_idx</span><span class="p">,</span> <span class="n">dW_factor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">dW_idx</span><span class="p">]:</span>
                        <span class="n">m_data</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">dW_idx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
                        <span class="n">m_expt</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">m_data</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                   <span class="n">m_data</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span>
                                                   <span class="n">m_data</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span>
                                                   <span class="n">psi_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">m_expt</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">mm</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_expt</span> <span class="o">+</span> <span class="n">dW_factor</span> <span class="o">*</span>
                          <span class="n">dW</span><span class="p">[</span><span class="n">m_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="n">dW_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span>
                          <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span><span class="p">))</span>
                    <span class="n">measurements</span><span class="p">[</span><span class="n">t_idx</span><span class="p">,</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">dW_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mm</span>

    <span class="k">if</span> <span class="n">d2_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">measurements</span> <span class="o">=</span> <span class="n">measurements</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">states_list</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">measurements</span><span class="p">,</span> <span class="n">expect</span><span class="p">,</span> <span class="n">ss</span>


<span class="c"># -----------------------------------------------------------------------------</span>
<span class="c"># Generic parameterized stochastic master equation solver</span>
<span class="c">#</span>
<span class="k">def</span> <span class="nf">_smesolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function. See smesolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">nsubsteps</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">Result</span><span class="p">()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s">&quot;smesolve&quot;</span>
    <span class="n">data</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data</span><span class="o">.</span><span class="n">measurement</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># Liouvillian for the deterministic part.</span>
    <span class="c"># needs to be modified for TD systems</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">liouvillian</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">c_ops</span><span class="p">)</span>

    <span class="c"># pre-compute suporoperator operator combinations that are commonly needed</span>
    <span class="c"># when evaluating the RHS of stochastic master equations</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">A_ops</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">generate_A_ops</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>

    <span class="c"># use .data instead of Qobj ?</span>
    <span class="n">sso</span><span class="o">.</span><span class="n">s_e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">spre</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">s_m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">spre</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">m</span> <span class="k">else</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">m_op</span><span class="p">]</span>
                       <span class="k">for</span> <span class="n">m_op</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">m_ops</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sso</span><span class="o">.</span><span class="n">s_m_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span><span class="p">)]</span>
                       <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">sc_ops</span><span class="p">]</span>

    <span class="n">map_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;progress_bar&#39;</span><span class="p">:</span> <span class="n">progress_bar</span><span class="p">}</span>
    <span class="n">map_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">map_kwargs</span><span class="p">)</span>

    <span class="n">task</span> <span class="o">=</span> <span class="n">_smesolve_single_trajectory</span>
    <span class="n">task_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">sso</span><span class="p">,)</span>
    <span class="n">task_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">map_func</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="p">)),</span>
                           <span class="n">task_args</span><span class="p">,</span> <span class="n">task_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">map_kwargs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="n">states_list</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">expect</span><span class="p">,</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">result</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">states_list</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">noise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dW</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">measurement</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">+=</span> <span class="n">expect</span>
        <span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">+=</span> <span class="n">ss</span>

    <span class="c"># average density matrices</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">average_states</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">mm</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">mm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">)])</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
                       <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">times</span><span class="p">))]</span>

    <span class="c"># average</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">/</span> <span class="n">nt</span>

    <span class="c"># standard error</span>
    <span class="k">if</span> <span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">-</span> <span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c"># convert complex data to real if hermitian</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:])</span>
                   <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">isherm</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:]</span>
                   <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_smesolve_single_trajectory</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">sso</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function. See smesolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">dt</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span>
    <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">d1</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">d2</span>
    <span class="n">d2_len</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span>
    <span class="n">L_data</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">L</span><span class="o">.</span><span class="n">data</span>
    <span class="n">N_substeps</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_substeps</span>
    <span class="n">N_store</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span>
    <span class="n">A_ops</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">A_ops</span>

    <span class="n">rho_t</span> <span class="o">=</span> <span class="n">mat2vec</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">state0</span><span class="o">.</span><span class="n">full</span><span class="p">())</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">state0</span><span class="o">.</span><span class="n">dims</span>

    <span class="n">expect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">sso</span><span class="o">.</span><span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="c"># reseed the random number generator so that forked</span>
    <span class="c"># processes do not get the same sequence of random numbers</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4294967295</span> <span class="o">//</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">generate_noise</span><span class="p">:</span>
            <span class="n">dW</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">generate_noise</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A_ops</span><span class="p">),</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span>
                                    <span class="n">sso</span><span class="o">.</span><span class="n">d2_len</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">==</span> <span class="s">&#39;normal&#39;</span><span class="p">:</span>
                <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A_ops</span><span class="p">),</span> <span class="n">N_store</span><span class="p">,</span>
                                                   <span class="n">N_substeps</span><span class="p">,</span> <span class="n">d2_len</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Unsupported increment distribution for &#39;</span> <span class="o">+</span>
                                <span class="s">&#39;homogeneous process.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">distribution</span> <span class="o">!=</span> <span class="s">&#39;poisson&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Unsupported increment distribution for &#39;</span> <span class="o">+</span>
                                <span class="s">&#39;inhomogeneous process.&#39;</span><span class="p">)</span>

            <span class="n">dW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">A_ops</span><span class="p">),</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="n">d2_len</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dW</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">noise</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="n">states_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">measurements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">s_m_ops</span><span class="p">),</span> <span class="n">d2_len</span><span class="p">),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">s_e_ops</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e_idx</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">s_e_ops</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">expect</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span>
                <span class="n">ss</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">store_states</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">sso</span><span class="o">.</span><span class="n">s_e_ops</span><span class="p">:</span>
            <span class="n">states_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qobj</span><span class="p">(</span><span class="n">vec2mat</span><span class="p">(</span><span class="n">rho_t</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">))</span>

        <span class="n">rho_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rho_t</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_substeps</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">noise</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sso</span><span class="o">.</span><span class="n">homogeneous</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="n">A</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_ops</span><span class="p">):</span>
                    <span class="n">dw_expect</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
                    <span class="k">if</span> <span class="n">dw_expect</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">dw_expect</span><span class="p">,</span>
                                                                   <span class="n">d2_len</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">d2_len</span><span class="p">)</span>

            <span class="n">rho_t</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">rhs</span><span class="p">(</span><span class="n">L_data</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">j</span><span class="p">,</span>
                            <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">[:,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sso</span><span class="o">.</span><span class="n">store_measurement</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">s_m_ops</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">dW_idx</span><span class="p">,</span> <span class="n">dW_factor</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">dW_factors</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">dW_idx</span><span class="p">]:</span>
                        <span class="n">m_expt</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">dW_idx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rho_prev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">m_expt</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">measurements</span><span class="p">[</span><span class="n">t_idx</span><span class="p">,</span> <span class="n">m_idx</span><span class="p">,</span> <span class="n">dW_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_expt</span> <span class="o">+</span> <span class="n">dW_factor</span> <span class="o">*</span> \
                        <span class="n">dW</span><span class="p">[</span><span class="n">m_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="n">dW_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">N_substeps</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">d2_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">measurements</span> <span class="o">=</span> <span class="n">measurements</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">states_list</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">measurements</span><span class="p">,</span> <span class="n">expect</span><span class="p">,</span> <span class="n">ss</span>


<span class="c"># -----------------------------------------------------------------------------</span>
<span class="c"># Generic parameterized stochastic SE PDP solver</span>
<span class="c">#</span>
<span class="k">def</span> <span class="nf">_ssepdpsolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For internal use. See ssepdpsolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">N_store</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    <span class="n">N_substeps</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">nsubsteps</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">N_substeps</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">Result</span><span class="p">()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s">&quot;sepdpsolve&quot;</span>
    <span class="n">data</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">tlist</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">jump_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data</span><span class="o">.</span><span class="n">jump_op_idx</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># effective hamiltonian for deterministic part</span>
    <span class="n">Heff</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">H</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sso</span><span class="o">.</span><span class="n">c_ops</span><span class="p">:</span>
        <span class="n">Heff</span> <span class="o">+=</span> <span class="o">-</span><span class="mf">0.5j</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">c</span>

    <span class="n">progress_bar</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="p">):</span>
        <span class="n">progress_bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">psi_t</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">state0</span><span class="o">.</span><span class="n">full</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">states_list</span><span class="p">,</span> <span class="n">jump_times</span><span class="p">,</span> <span class="n">jump_op_idx</span> <span class="o">=</span> \
            <span class="n">_ssepdpsolve_single_trajectory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Heff</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">,</span>
                                           <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span>
                                           <span class="n">psi_t</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">state0</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                                           <span class="n">sso</span><span class="o">.</span><span class="n">c_ops</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">states_list</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">jump_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jump_times</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">jump_op_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jump_op_idx</span><span class="p">)</span>

    <span class="n">progress_bar</span><span class="o">.</span><span class="n">finished</span><span class="p">()</span>

    <span class="c"># average density matrices</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">average_states</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">)])</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
                       <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">times</span><span class="p">))]</span>

    <span class="c"># average</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">/</span> <span class="n">nt</span>

    <span class="c"># standard error</span>
    <span class="k">if</span> <span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">-</span> <span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c"># convert complex data to real if hermitian</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:])</span>
                   <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">isherm</span> <span class="k">else</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:]</span>
                   <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_ssepdpsolve_single_trajectory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Heff</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span>
                                   <span class="n">psi_t</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function. See ssepdpsolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">states_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">phi_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span>

    <span class="n">prng</span> <span class="o">=</span> <span class="n">RandomState</span><span class="p">()</span>  <span class="c"># todo: seed it</span>
    <span class="n">r_jump</span><span class="p">,</span> <span class="n">r_op</span> <span class="o">=</span> <span class="n">prng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">jump_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">jump_op_idx</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">e_ops</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e_idx</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span>
                <span class="n">data</span><span class="o">.</span><span class="n">ss</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">states_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qobj</span><span class="p">(</span><span class="n">psi_t</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_substeps</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">norm</span><span class="p">(</span><span class="n">phi_t</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">r_jump</span><span class="p">:</span>
                <span class="c"># jump occurs</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">psi_t</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">c_ops</span><span class="p">])</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">r_op</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c"># apply jump</span>
                <span class="n">psi_t</span> <span class="o">=</span> <span class="n">c_ops</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">psi_t</span>
                <span class="n">psi_t</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span>
                <span class="n">phi_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span>

                <span class="c"># store info about jump</span>
                <span class="n">jump_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">jump_op_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

                <span class="c"># get new random numbers for next jump</span>
                <span class="n">r_jump</span><span class="p">,</span> <span class="n">r_op</span> <span class="o">=</span> <span class="n">prng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

            <span class="c"># deterministic evolution wihtout correction for norm decay</span>
            <span class="n">dphi_t</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0j</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Heff</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">phi_t</span><span class="p">)</span>

            <span class="c"># deterministic evolution with correction for norm decay</span>
            <span class="n">dpsi_t</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0j</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Heff</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">psi_t</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">norm</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">psi_t</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">c_ops</span><span class="p">])</span>
            <span class="n">dpsi_t</span> <span class="o">+=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">psi_t</span>

            <span class="c"># increment wavefunctions</span>
            <span class="n">phi_t</span> <span class="o">+=</span> <span class="n">dphi_t</span>
            <span class="n">psi_t</span> <span class="o">+=</span> <span class="n">dpsi_t</span>

            <span class="c"># ensure that normalized wavefunction remains normalized</span>
            <span class="c"># this allows larger time step than otherwise would be possible</span>
            <span class="n">psi_t</span> <span class="o">/=</span> <span class="n">norm</span><span class="p">(</span><span class="n">psi_t</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">states_list</span><span class="p">,</span> <span class="n">jump_times</span><span class="p">,</span> <span class="n">jump_op_idx</span>


<span class="c"># -----------------------------------------------------------------------------</span>
<span class="c"># Generic parameterized stochastic ME PDP solver</span>
<span class="c">#</span>
<span class="k">def</span> <span class="nf">_smepdpsolve_generic</span><span class="p">(</span><span class="n">sso</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">progress_bar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For internal use. See smepdpsolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">N_store</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    <span class="n">N_substeps</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">nsubsteps</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">N_substeps</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">Result</span><span class="p">()</span>
    <span class="n">data</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="s">&quot;smepdpsolve&quot;</span>
    <span class="n">data</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">),</span> <span class="n">N_store</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">data</span><span class="o">.</span><span class="n">jump_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">data</span><span class="o">.</span><span class="n">jump_op_idx</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># Liouvillian for the deterministic part.</span>
    <span class="c"># needs to be modified for TD systems</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">liouvillian</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">c_ops</span><span class="p">)</span>

    <span class="n">progress_bar</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span><span class="p">):</span>
        <span class="n">progress_bar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">rho_t</span> <span class="o">=</span> <span class="n">mat2vec</span><span class="p">(</span><span class="n">sso</span><span class="o">.</span><span class="n">rho0</span><span class="o">.</span><span class="n">full</span><span class="p">())</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">states_list</span><span class="p">,</span> <span class="n">jump_times</span><span class="p">,</span> <span class="n">jump_op_idx</span> <span class="o">=</span> \
            <span class="n">_smepdpsolve_single_trajectory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">times</span><span class="p">,</span>
                                           <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span>
                                           <span class="n">rho_t</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">rho0</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                                           <span class="n">sso</span><span class="o">.</span><span class="n">c_ops</span><span class="p">,</span> <span class="n">sso</span><span class="o">.</span><span class="n">e_ops</span><span class="p">)</span>

        <span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">states_list</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">jump_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jump_times</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">jump_op_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jump_op_idx</span><span class="p">)</span>

    <span class="n">progress_bar</span><span class="o">.</span><span class="n">finished</span><span class="p">()</span>

    <span class="c"># average density matrices</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">average_states</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">)])</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
                       <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">times</span><span class="p">))]</span>

    <span class="c"># average</span>
    <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">/</span> <span class="n">sso</span><span class="o">.</span><span class="n">ntraj</span>

    <span class="c"># standard error</span>
    <span class="k">if</span> <span class="n">nt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ss</span> <span class="o">-</span> <span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">expect</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">nt</span> <span class="o">*</span> <span class="p">(</span><span class="n">nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">_smepdpsolve_single_trajectory</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span>
                                   <span class="n">rho_t</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">c_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal function. See smepdpsolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">states_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">rho_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rho_t</span><span class="p">)</span>
    <span class="n">sigma_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rho_t</span><span class="p">)</span>

    <span class="n">prng</span> <span class="o">=</span> <span class="n">RandomState</span><span class="p">()</span>  <span class="c"># todo: seed it</span>
    <span class="n">r_jump</span><span class="p">,</span> <span class="n">r_op</span> <span class="o">=</span> <span class="n">prng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">jump_times</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">jump_op_idx</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">t_idx</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">e_ops</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e_idx</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">e_ops</span><span class="p">):</span>
                <span class="n">data</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">t_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">expect_rho_vec</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">states_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qobj</span><span class="p">(</span><span class="n">vec2mat</span><span class="p">(</span><span class="n">rho_t</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_substeps</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">sigma_t</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">r_jump</span><span class="p">:</span>
                <span class="c"># jump occurs</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">expect</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">c_ops</span><span class="p">])</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">p</span> <span class="o">&gt;=</span> <span class="n">r_op</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c"># apply jump</span>
                <span class="n">rho_t</span> <span class="o">=</span> <span class="n">c_ops</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span> <span class="o">*</span> <span class="n">c_ops</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span>
                <span class="n">rho_t</span> <span class="o">/=</span> <span class="n">expect</span><span class="p">(</span><span class="n">c_ops</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">c_ops</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span>
                <span class="n">sigma_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">rho_t</span><span class="p">)</span>

                <span class="c"># store info about jump</span>
                <span class="n">jump_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">t_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">jump_op_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

                <span class="c"># get new random numbers for next jump</span>
                <span class="n">r_jump</span><span class="p">,</span> <span class="n">r_op</span> <span class="o">=</span> <span class="n">prng</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

            <span class="c"># deterministic evolution wihtout correction for norm decay</span>
            <span class="n">dsigma_t</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>

            <span class="c"># deterministic evolution with correction for norm decay</span>
            <span class="n">drho_t</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>

            <span class="n">rho_t</span> <span class="o">+=</span> <span class="n">drho_t</span>

            <span class="c"># increment density matrices</span>
            <span class="n">sigma_t</span> <span class="o">+=</span> <span class="n">dsigma_t</span>
            <span class="n">rho_t</span> <span class="o">+=</span> <span class="n">drho_t</span>

    <span class="k">return</span> <span class="n">states_list</span><span class="p">,</span> <span class="n">jump_times</span><span class="p">,</span> <span class="n">jump_op_idx</span>


<span class="c"># -----------------------------------------------------------------------------</span>
<span class="c"># Helper-functions for stochastic DE</span>
<span class="c">#</span>
<span class="c"># d1 = deterministic part of the contribution to the DE RHS function, to be</span>
<span class="c">#      multiplied by the increament dt</span>
<span class="c">#</span>
<span class="c"># d1 = stochastic part of the contribution to the DE RHS function, to be</span>
<span class="c">#      multiplied by the increament dW</span>
<span class="c">#</span>


<span class="c">#</span>
<span class="c"># For SSE</span>
<span class="c">#</span>

<span class="c"># Function sigurature:</span>
<span class="c">#</span>
<span class="c"># def d(A, psi):</span>
<span class="c">#</span>
<span class="c">#     psi = wave function at the current time step</span>
<span class="c">#</span>
<span class="c">#     A[0] = c</span>
<span class="c">#     A[1] = c + c.dag()</span>
<span class="c">#     A[2] = c - c.dag()</span>
<span class="c">#     A[3] = c.dag() * c</span>
<span class="c">#</span>
<span class="c">#     where c is a collapse operator. The combinations of c&#39;s stored in A are</span>
<span class="c">#     precomputed before the time-evolution is started to avoid repeated</span>
<span class="c">#     computations.</span>


<span class="k">def</span> <span class="nf">_generate_psi_A_ops</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    pre-compute superoperator operator combinations that are commonly needed</span>
<span class="sd">    when evaluating the RHS of stochastic schrodinger equations</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">A_ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c_idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sc_ops</span><span class="p">):</span>
        <span class="n">A_ops</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                      <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                      <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                      <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">A_ops</span>


<span class="k">def</span> <span class="nf">d1_psi_homodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    OK</span>
<span class="sd">    Todo: cythonize</span>

<span class="sd">    .. math::</span>

<span class="sd">        D_1(C, \psi) = \\frac{1}{2}(\\langle C + C^\\dagger\\rangle\\C psi -</span>
<span class="sd">        C^\\dagger C\\psi - \\frac{1}{4}\\langle C + C^\\dagger\\rangle^2\\psi)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">e1</span> <span class="o">*</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">-</span>
                  <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">-</span>
                  <span class="mf">0.25</span> <span class="o">*</span> <span class="n">e1</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">psi</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">d2_psi_homodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    OK</span>
<span class="sd">    Todo: cythonize</span>

<span class="sd">    .. math::</span>

<span class="sd">        D_2(\psi, t) = (C - \\frac{1}{2}\\langle C + C^\\dagger\\rangle)\\psi</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">psi</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">d1_psi_heterodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Todo: cythonize</span>

<span class="sd">    .. math::</span>

<span class="sd">        D_1(\psi, t) = -\\frac{1}{2}(C^\\dagger C -</span>
<span class="sd">        \\langle C^\\dagger \\rangle C +</span>
<span class="sd">        \\frac{1}{2}\\langle C \\rangle\\langle C^\\dagger \\rangle))\psi</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">e_C</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
    <span class="n">e_Cd</span> <span class="o">=</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">+</span>
            <span class="mf">0.5</span> <span class="o">*</span> <span class="n">e_Cd</span> <span class="o">*</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">-</span>
            <span class="mf">0.25</span> <span class="o">*</span> <span class="n">e_C</span> <span class="o">*</span> <span class="n">e_Cd</span> <span class="o">*</span> <span class="n">psi</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">d2_psi_heterodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Todo: cythonize</span>

<span class="sd">        X = \\frac{1}{2}(C + C^\\dagger)</span>

<span class="sd">        Y = \\frac{1}{2}(C - C^\\dagger)</span>

<span class="sd">        D_{2,1}(\psi, t) = \\sqrt(1/2) (C - \\langle X \\rangle) \\psi</span>

<span class="sd">        D_{2,2}(\psi, t) = -i\\sqrt(1/2) (C - \\langle Y \\rangle) \\psi</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">X</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cy_expect_psi_csr</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">d2_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span> <span class="o">*</span> <span class="n">psi</span><span class="p">)</span>
    <span class="n">d2_2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span> <span class="o">-</span> <span class="n">Y</span> <span class="o">*</span> <span class="n">psi</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">d2_1</span><span class="p">,</span> <span class="n">d2_2</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">d1_psi_photocurrent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Todo: cythonize.</span>

<span class="sd">    Note: requires poisson increments</span>

<span class="sd">    .. math::</span>

<span class="sd">        D_1(\psi, t) = - \\frac{1}{2}(C^\dagger C \psi - ||C\psi||^2 \psi)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">norm</span><span class="p">(</span><span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">psi</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">d2_psi_photocurrent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Todo: cythonize</span>

<span class="sd">    Note: requires poisson increments</span>

<span class="sd">    .. math::</span>

<span class="sd">        D_2(\psi, t) = C\psi / ||C\psi|| - \psi</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">psi_1</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">psi</span><span class="p">)</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">psi_1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n1</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">psi_1</span> <span class="o">/</span> <span class="n">n1</span> <span class="o">-</span> <span class="n">psi</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="o">-</span> <span class="n">psi</span><span class="p">]</span>


<span class="c">#</span>
<span class="c"># For SME</span>
<span class="c">#</span>

<span class="c"># def d(A, rho_vec):</span>
<span class="c">#</span>
<span class="c">#     rho = density operator in vector form at the current time stemp</span>
<span class="c">#</span>
<span class="c">#     A[_idx_A_L] = spre(a) = A_L</span>
<span class="c">#     A[_idx_A_R] = spost(a) = A_R</span>
<span class="c">#     A[_idx_Ad_L] = spre(a.dag()) = Ad_L</span>
<span class="c">#     A[_idx_Ad_R] = spost(a.dag()) = Ad_R</span>
<span class="c">#     A[_idx_AdA_L] = spre(a.dag() * a) = (Ad A)_L</span>
<span class="c">#     A[_idx_AdA_R] = spost(a.dag() * a) = (Ad A)_R</span>
<span class="c">#     A[_idx_A_LxAd_R] = (spre(a) * spost(a.dag()) = A_L * Ad_R</span>
<span class="c">#     A[_idx_LD] = lindblad_dissipator(a)</span>

<span class="n">_idx_A_L</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">_idx_A_R</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">_idx_Ad_L</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">_idx_Ad_R</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">_idx_AdA_L</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">_idx_AdA_R</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">_idx_A_LxAd_R</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">_idx_LD</span> <span class="o">=</span> <span class="mi">7</span>


<span class="k">def</span> <span class="nf">_generate_rho_A_ops</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    pre-compute superoperator operator combinations that are commonly needed</span>
<span class="sd">    when evaluating the RHS of stochastic master equations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c_idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sc</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">c</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">spost</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">spost</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">spre</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">spost</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">spost</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">()))</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">lindblad_dissipator</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)])</span>

    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_generate_A_ops_Euler</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    combine precomputed operators in one long operator for the Euler method</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">spost</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">L</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="p">[</span><span class="n">lindblad_dissipator</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">dt</span><span class="p">]</span>
    <span class="n">out1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">sp</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(),</span> <span class="n">sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
    <span class="c"># the following hack is required for compatibility with old A_ops</span>
    <span class="n">out1</span> <span class="o">+=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c"># XXX: fix this!</span>
    <span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out1</span>


<span class="k">def</span> <span class="nf">_generate_A_ops_Milstein</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    combine precomputed operators in one long operator for the Milstein method</span>
<span class="sd">    with commuting stochastic jump operators.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">spre</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">spost</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="n">temp</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">temp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span><span class="n">temp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">temp</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">A_len</span><span class="p">,</span> <span class="n">A_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">L</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="p">[</span><span class="n">lindblad_dissipator</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data_only</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sc</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">dt</span><span class="p">]</span>
    <span class="n">out1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">sp</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(),</span> <span class="n">sc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
    <span class="c"># the following hack is required for compatibility with old A_ops</span>
    <span class="n">out1</span> <span class="o">+=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c"># XXX: fix this!</span>
    <span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out1</span>


<span class="k">def</span> <span class="nf">_generate_noise_Milstein</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="n">d2_len</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    generate noise terms for the fast Milstein scheme</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sc_len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">dW_temp</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW_temp</span> <span class="o">*</span> <span class="n">dW_temp</span> <span class="o">-</span> <span class="n">dt</span> <span class="o">*</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">dW_temp</span><span class="p">,</span>
             <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW_temp</span> <span class="o">*</span> <span class="n">dW_temp</span> <span class="o">-</span>
                    <span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">N_store</span><span class="p">,</span> <span class="n">N_substeps</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))]</span> <span class="o">+</span>
            <span class="p">[[</span><span class="n">dW_temp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW_temp</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">sc_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">noise</span>


<span class="k">def</span> <span class="nf">sop_H</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the superoperator</span>

<span class="sd">    H[a] rho = a rho + rho a^\dagger - Tr[a rho + rho a^\dagger] rho</span>
<span class="sd">            -&gt; (A_L + Ad_R) rho_vec - E[(A_L + Ad_R) rho_vec] rho_vec</span>

<span class="sd">    Todo: cythonize, add A_L + Ad_R to precomputed operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">)</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">rho_vec</span>


<span class="k">def</span> <span class="nf">sop_G</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate the superoperator</span>

<span class="sd">    G[a] rho = a rho a^\dagger / Tr[a rho a^\dagger] - rho</span>
<span class="sd">            -&gt; A_L Ad_R rho_vec / Tr[A_L Ad_R rho_vec] - rho_vec</span>

<span class="sd">    Todo: cythonize, add A_L + Ad_R to precomputed operators</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">e1</span> <span class="o">&gt;</span> <span class="mf">1e-15</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">rho_vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">e1</span> <span class="o">-</span> <span class="n">rho_vec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">rho_vec</span>


<span class="k">def</span> <span class="nf">d1_rho_homodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    D1[a] rho = lindblad_dissipator(a) * rho</span>

<span class="sd">    Todo: cythonize</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">rho_vec</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">d2_rho_homodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    D2[a] rho = a rho + rho a^\dagger - Tr[a rho + rho a^\dagger]</span>
<span class="sd">              = (A_L + Ad_R) rho_vec - E[(A_L + Ad_R) rho_vec]</span>

<span class="sd">    Todo: cythonize, add A_L + Ad_R to precomputed operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">)</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">rho_vec</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">d1_rho_heterodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    todo: cythonize, docstrings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">rho_vec</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">d2_rho_heterodyne</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    todo: cythonize, docstrings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">)</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">rho_vec</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">)</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">rho_vec</span>
    <span class="k">return</span> <span class="p">[</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">d1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0j</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">d2</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">d1_rho_photocurrent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Todo: cythonize, add (AdA)_L + AdA_R to precomputed operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_sum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">n_sum</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">e1</span> <span class="o">*</span> <span class="n">rho_vec</span> <span class="o">-</span> <span class="n">spmv</span><span class="p">(</span><span class="n">n_sum</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">d2_rho_photocurrent</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Todo: cythonize, add (AdA)_L + AdA_R to precomputed operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">rho_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">e1</span><span class="o">.</span><span class="n">real</span> <span class="o">&gt;</span> <span class="mf">1e-15</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">rho_vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">e1</span> <span class="o">-</span> <span class="n">rho_vec</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">rho_vec</span><span class="p">]</span>


<span class="c"># -----------------------------------------------------------------------------</span>
<span class="c"># Deterministic part of the rho/psi update functions. TODO: Make these</span>
<span class="c"># compatible with qutip&#39;s time-dependent hamiltonian and collapse operators</span>
<span class="c">#</span>
<span class="k">def</span> <span class="nf">_rhs_psi_deterministic</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deterministic contribution to the density matrix change</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dpsi_t</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0j</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">H</span> <span class="o">*</span> <span class="n">psi_t</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpsi_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_deterministic</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deterministic contribution to the density matrix change</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>

    <span class="k">return</span> <span class="n">drho_t</span>


<span class="c"># -----------------------------------------------------------------------------</span>
<span class="c"># Euler-Maruyama rhs functions for the stochastic Schrodinger and master</span>
<span class="c"># equations</span>
<span class="c">#</span>

<span class="k">def</span> <span class="nf">_rhs_psi_euler_maruyama</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Euler-Maruyama rhs function for wave function solver.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">dpsi_t</span> <span class="o">=</span> <span class="n">_rhs_psi_deterministic</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="n">A</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_ops</span><span class="p">):</span>
        <span class="n">d2_vec</span> <span class="o">=</span> <span class="n">d2</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">dpsi_t</span> <span class="o">+=</span> <span class="n">d1</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">d2_vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dW_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">psi_t</span> <span class="o">+</span> <span class="n">dpsi_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_euler_maruyama</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Euler-Maruyama rhs function for density matrix solver.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">_rhs_rho_deterministic</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="n">A</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_ops</span><span class="p">):</span>
        <span class="n">d2_vec</span> <span class="o">=</span> <span class="n">d2</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">d1</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">d2_vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dW_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rho_t</span> <span class="o">+</span> <span class="n">drho_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_euler_homodyne_fast</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ddW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fast Euler-Maruyama for homodyne detection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dW</span> <span class="o">=</span> <span class="n">ddW</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">d_vec</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho_t</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">d_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dW</span><span class="p">,</span> <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">dW</span><span class="p">))</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="k">return</span> <span class="n">drho_t</span>


<span class="c"># -----------------------------------------------------------------------------</span>
<span class="c"># Platen method</span>
<span class="c">#</span>
<span class="k">def</span> <span class="nf">_rhs_psi_platen</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TODO: support multiple stochastic increments</span>

<span class="sd">    .. note::</span>

<span class="sd">        Experimental.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sqrt_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>

    <span class="n">dpsi_t</span> <span class="o">=</span> <span class="n">_rhs_psi_deterministic</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a_idx</span><span class="p">,</span> <span class="n">A</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">A_ops</span><span class="p">):</span>
        <span class="c"># XXX: This needs to be revised now that</span>
        <span class="c"># dpsi_t is the change for all stochastic collapse operators</span>

        <span class="c"># TODO: needs to be updated to support mutiple Weiner increments</span>
        <span class="n">dpsi_t_H</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0j</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">spmv</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)</span>

        <span class="n">psi_t_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">psi_t</span> <span class="o">+</span> <span class="n">dpsi_t_H</span> <span class="o">+</span>
                   <span class="n">d1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span>
                   <span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">psi_t_p</span> <span class="o">=</span> <span class="p">(</span><span class="n">psi_t</span> <span class="o">+</span> <span class="n">dpsi_t_H</span> <span class="o">+</span>
                   <span class="n">d1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span>
                   <span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sqrt_dt</span><span class="p">)</span>
        <span class="n">psi_t_m</span> <span class="o">=</span> <span class="p">(</span><span class="n">psi_t</span> <span class="o">+</span> <span class="n">dpsi_t_H</span> <span class="o">+</span>
                   <span class="n">d1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">-</span>
                   <span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sqrt_dt</span><span class="p">)</span>

        <span class="n">dpsi_t</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="mf">0.50</span> <span class="o">*</span> <span class="p">(</span><span class="n">d1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t_1</span><span class="p">)</span> <span class="o">+</span> <span class="n">d1</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">))</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">+</span>
            <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t_p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t_m</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
                    <span class="mi">2</span> <span class="o">*</span> <span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span>
            <span class="mf">0.25</span> <span class="o">*</span> <span class="p">(</span><span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t_p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">d2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">psi_t_m</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
            <span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="n">a_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span> <span class="o">/</span> <span class="n">sqrt_dt</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">dpsi_t</span>


<span class="c"># -----------------------------------------------------------------------------</span>
<span class="c"># Milstein rhs functions for the stochastic master equation</span>
<span class="c">#</span>
<span class="k">def</span> <span class="nf">_rhs_rho_milstein_homodyne_single</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span>
                                      <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. note::</span>

<span class="sd">        Experimental.</span>
<span class="sd">        Milstein scheme for homodyne detection with single jump operator.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A_ops</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">d2_vec</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">)</span>
    <span class="n">d2_vec2</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">d2_vec</span><span class="p">)</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">d2_vec</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">_rhs_rho_deterministic</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="p">(</span><span class="n">d2_vec</span> <span class="o">-</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">d2_vec2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">d2_vec</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">e2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">e1</span> <span class="o">*</span> <span class="n">e1</span><span class="p">)</span> <span class="o">*</span>
                     <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rho_t</span> <span class="o">+</span> <span class="n">drho_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_milstein_homodyne</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A_ops</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. note::</span>

<span class="sd">        Experimental.</span>
<span class="sd">        Milstein scheme for homodyne detection.</span>
<span class="sd">        This implementation works for commuting stochastic jump operators.</span>
<span class="sd">        TODO: optimizations: do calculation for n&gt;m only</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A_ops</span><span class="p">)</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">A_ops</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A_ops</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)])</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)])</span>

    <span class="n">d1_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">spmv</span><span class="p">(</span><span class="n">A_ops</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">7</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">d2_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)])</span>

    <span class="c"># This calculation is suboptimal. We need only values for m&gt;n in case of</span>
    <span class="c"># commuting jump operators.</span>
    <span class="n">d2_vec2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">spmv</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">d2_vec</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>
                         <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)])</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cy_expect_rho_vec</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">d2_vec</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)])</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="n">_rhs_rho_deterministic</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">d1_vec</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([(</span><span class="n">d2_vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">e1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">d2_vec2</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">d2_vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span>
         <span class="p">(</span><span class="o">-</span><span class="n">e2</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">*</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dW</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_len</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c"># This calculation is suboptimal. We need only values for m&gt;n in case of</span>
    <span class="c"># commuting jump operators.</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">d2_vec2</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">e1</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">d2_vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">e1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">d2_vec</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span>
         <span class="p">(</span><span class="o">-</span><span class="n">e2</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="o">*</span> <span class="n">rho_t</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dW</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">A_len</span><span class="p">,</span> <span class="n">A_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rho_t</span> <span class="o">+</span> <span class="n">drho_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_milstein_homodyne_single_fast</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ddW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span>
                                           <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    fast Milstein for homodyne detection with 1 stochastic operator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW</span> <span class="o">=</span> <span class="n">ddW</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">d_vec</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho_t</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
        <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">dW</span><span class="p">))</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="n">dW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">d_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dW</span><span class="p">,</span> <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">drho_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_milstein_homodyne_two_fast</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ddW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    fast Milstein for homodyne detection with 2 stochastic operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW</span> <span class="o">=</span> <span class="n">ddW</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">d_vec</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho_t</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span>
        <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">d_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_vec</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">e</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">dW</span><span class="p">))</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="n">dW</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>

    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">d_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dW</span><span class="p">,</span> <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">drho_t</span>


<span class="k">def</span> <span class="nf">_rhs_rho_milstein_homodyne_fast</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">rho_t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">ddW</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    fast Milstein for homodyne detection with &gt;2 stochastic operators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dW</span> <span class="o">=</span> <span class="n">ddW</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">sc_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">sc2_len</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sc_len</span>

    <span class="n">d_vec</span> <span class="o">=</span> <span class="n">spmv</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">rho_t</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rho_t</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">d_vec</span><span class="p">[</span><span class="n">sc2_len</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_vec</span><span class="p">[</span><span class="n">m</span><span class="p">]</span>
         <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">sc_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">])</span>

    <span class="n">e</span><span class="p">[</span><span class="n">sc_len</span><span class="p">:</span><span class="n">sc2_len</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[:</span><span class="n">sc_len</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[:</span><span class="n">sc_len</span><span class="p">]</span>
    <span class="n">e</span><span class="p">[</span><span class="n">sc2_len</span><span class="p">:]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">sc_len</span><span class="p">,</span> <span class="n">sc_len</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">])</span>

    <span class="n">drho_t</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">dW</span><span class="p">))</span> <span class="o">*</span> <span class="n">rho_t</span>
    <span class="n">dW</span><span class="p">[:</span><span class="n">sc_len</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">e</span><span class="p">[:</span><span class="n">sc_len</span><span class="p">]</span> <span class="o">*</span> <span class="n">dW</span><span class="p">[</span><span class="n">sc_len</span><span class="p">:</span><span class="n">sc2_len</span><span class="p">]</span>

    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">d_vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">drho_t</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dW</span><span class="p">,</span> <span class="n">d_vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">drho_t</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2011 and later, P.D. Nation, J.R. Johansson.<br/>
      Last updated on Dec 31, 2014.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>