
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Classes &mdash; QuTiP 5.0 Documentation</title>
      <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../static/sg_gallery-rendered-html.css" type="text/css" />
      <link rel="stylesheet" href="../static/site.css" type="text/css" />
    <link rel="shortcut icon" href="../static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../static/documentation_options.js"></script>
        <script src="../static/doctools.js"></script>
        <script src="../static/sphinx_highlight.js"></script>
        <script>window.MathJax = {"TeX": {"Macros": {"bra": ["\\left\\langle{#1}\\right\\rvert", 1], "ket": ["\\left\\lvert{#1}\\right\\rangle", 1], "tr": "\\operatorname{tr}"}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="Functions" href="functions.html" />
    <link rel="prev" title="API documentation" href="apidoc.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            QuTiP: Quantum Toolbox in Python
          </a>
              <div class="version">
                5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/guide.html">Users Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gallery/build/index.html">Gallery</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="apidoc.html">API documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qobj">Qobj</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.core.qobj.Qobj"><code class="docutils literal notranslate"><span class="pre">Qobj</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#qobjevo">QobjEvo</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo"><code class="docutils literal notranslate"><span class="pre">QobjEvo</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#bloch-sphere">Bloch sphere</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.bloch.Bloch"><code class="docutils literal notranslate"><span class="pre">Bloch</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#distributions">Distributions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.QFunc"><code class="docutils literal notranslate"><span class="pre">QFunc</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#solvers">Solvers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.sesolve.SESolver"><code class="docutils literal notranslate"><span class="pre">SESolver</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.mesolve.MESolver"><code class="docutils literal notranslate"><span class="pre">MESolver</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.brmesolve.BRSolver"><code class="docutils literal notranslate"><span class="pre">BRSolver</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.floquet.FMESolver"><code class="docutils literal notranslate"><span class="pre">FMESolver</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.floquet.FloquetBasis"><code class="docutils literal notranslate"><span class="pre">FloquetBasis</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.propagator.Propagator"><code class="docutils literal notranslate"><span class="pre">Propagator</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#monte-carlo-solvers">Monte Carlo Solvers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.mcsolve.MCSolver"><code class="docutils literal notranslate"><span class="pre">MCSolver</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver"><code class="docutils literal notranslate"><span class="pre">NonMarkovianMCSolver</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#non-markovian-heom-solver">Non-Markovian HEOM Solver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.HEOMSolver"><code class="docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.HSolverDL"><code class="docutils literal notranslate"><span class="pre">HSolverDL</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.BathExponent"><code class="docutils literal notranslate"><span class="pre">BathExponent</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.Bath"><code class="docutils literal notranslate"><span class="pre">Bath</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.BosonicBath"><code class="docutils literal notranslate"><span class="pre">BosonicBath</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.DrudeLorentzBath"><code class="docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.DrudeLorentzPadeBath"><code class="docutils literal notranslate"><span class="pre">DrudeLorentzPadeBath</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.UnderDampedBath"><code class="docutils literal notranslate"><span class="pre">UnderDampedBath</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.FermionicBath"><code class="docutils literal notranslate"><span class="pre">FermionicBath</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.LorentzianBath"><code class="docutils literal notranslate"><span class="pre">LorentzianBath</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.LorentzianPadeBath"><code class="docutils literal notranslate"><span class="pre">LorentzianPadeBath</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.HierarchyADOs"><code class="docutils literal notranslate"><span class="pre">HierarchyADOs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.HierarchyADOsState"><code class="docutils literal notranslate"><span class="pre">HierarchyADOsState</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.heom.HEOMResult"><code class="docutils literal notranslate"><span class="pre">HEOMResult</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#stochastic-solver">Stochastic Solver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.stochastic.SMESolver"><code class="docutils literal notranslate"><span class="pre">SMESolver</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.stochastic.SSESolver"><code class="docutils literal notranslate"><span class="pre">SSESolver</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#classes-ode">Integrator</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams"><code class="docutils literal notranslate"><span class="pre">IntegratorScipyAdams</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF"><code class="docutils literal notranslate"><span class="pre">IntegratorScipyBDF</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda"><code class="docutils literal notranslate"><span class="pre">IntegratorScipylsoda</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853"><code class="docutils literal notranslate"><span class="pre">IntegratorScipyDop853</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.integrator.qutip_integrator.IntegratorVern7"><code class="docutils literal notranslate"><span class="pre">IntegratorVern7</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.integrator.qutip_integrator.IntegratorVern9"><code class="docutils literal notranslate"><span class="pre">IntegratorVern9</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.integrator.qutip_integrator.IntegratorDiag"><code class="docutils literal notranslate"><span class="pre">IntegratorDiag</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.integrator.krylov.IntegratorKrylov"><code class="docutils literal notranslate"><span class="pre">IntegratorKrylov</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#stochastic-integrator">Stochastic Integrator</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.sode.rouchon.RouchonSODE"><code class="docutils literal notranslate"><span class="pre">RouchonSODE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.sode.itotaylor.EulerSODE"><code class="docutils literal notranslate"><span class="pre">EulerSODE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.sode.itotaylor.Milstein_SODE"><code class="docutils literal notranslate"><span class="pre">Milstein_SODE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.sode.itotaylor.Taylor1_5_SODE"><code class="docutils literal notranslate"><span class="pre">Taylor1_5_SODE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.sode.itotaylor.Implicit_Milstein_SODE"><code class="docutils literal notranslate"><span class="pre">Implicit_Milstein_SODE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE"><code class="docutils literal notranslate"><span class="pre">Implicit_Taylor1_5_SODE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.sode.sode.PlatenSODE"><code class="docutils literal notranslate"><span class="pre">PlatenSODE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.sode.itotaylor.Explicit1_5_SODE"><code class="docutils literal notranslate"><span class="pre">Explicit1_5_SODE</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.sode.sode.PredCorr_SODE"><code class="docutils literal notranslate"><span class="pre">PredCorr_SODE</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#solver-options-and-results">Solver Options and Results</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.result.Result"><code class="docutils literal notranslate"><span class="pre">Result</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.result.MultiTrajResult"><code class="docutils literal notranslate"><span class="pre">MultiTrajResult</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.result.McResult"><code class="docutils literal notranslate"><span class="pre">McResult</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.solver.result.NmmcResult"><code class="docutils literal notranslate"><span class="pre">NmmcResult</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#permutational-invariance">Permutational Invariance</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.piqs.piqs.Dicke"><code class="docutils literal notranslate"><span class="pre">Dicke</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#qutip.piqs.piqs.Pim"><code class="docutils literal notranslate"><span class="pre">Pim</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#distribution-functions">Distribution functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#qutip.distributions.Distribution"><code class="docutils literal notranslate"><span class="pre">Distribution</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="functions.html">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../development/development.html">Development Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../copyright.html">Copyright and Licensing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuTiP: Quantum Toolbox in Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="apidoc.html">API documentation</a></li>
      <li class="breadcrumb-item active">Classes</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="classes">
<span id="id1"></span><h1>Classes<a class="headerlink" href="#classes" title="Permalink to this heading"></a></h1>
<section id="qobj">
<span id="classes-qobj"></span><h2>Qobj<a class="headerlink" href="#qobj" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Qobj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">superrep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isherm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isunitary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj" title="Permalink to this definition"></a></dt>
<dd><p>A class for representing quantum objects, such as quantum operators and
states.</p>
<p>The Qobj class is the QuTiP representation of quantum operators and state
vectors. This class also implements math operations +,-,* between Qobj
instances (and / by a C-number), as well as a collection of common
operator/state operations.  The Qobj constructor optionally takes a
dimension <code class="docutils literal notranslate"><span class="pre">list</span></code> and/or shape <code class="docutils literal notranslate"><span class="pre">list</span></code> as arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inpt: array_like, data object or :obj:`.Qobj`</strong></dt><dd><p>Data for vector/matrix representation of the quantum object.</p>
</dd>
<dt><strong>dims: list</strong></dt><dd><p>Dimensions of object used for tensor products.</p>
</dd>
<dt><strong>shape: list</strong></dt><dd><p>Shape of underlying data structure (matrix shape).</p>
</dd>
<dt><strong>copy: bool</strong></dt><dd><p>Flag specifying whether Qobj should get a copy of the
input data, or use the original.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">object</span></dt><dd><p>The data object storing the vector / matrix representation of the
<cite>Qobj</cite>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type</span></dt><dd><p>The data-layer type used for storing the data. The possible types are
described in <a class="reference external" href="./classes.html#qutip.core.qobj.Qobj.to">Qobj.to</a>.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>List of dimensions keeping track of the tensor structure.</p>
</dd>
<dt><a class="reference internal" href="#qutip.core.qobj.Qobj.shape" title="qutip.core.qobj.Qobj.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a><span class="classifier">list</span></dt><dd><p>Return the shape of the Qobj data.</p>
</dd>
<dt><strong>type</strong><span class="classifier">str</span></dt><dd><p>Type of quantum object: ‘bra’, ‘ket’, ‘oper’, ‘operator-ket’,
‘operator-bra’, or ‘super’.</p>
</dd>
<dt><strong>superrep</strong><span class="classifier">str</span></dt><dd><p>Representation used if <cite>type</cite> is ‘super’. One of ‘super’
(Liouville form), ‘choi’ (Choi matrix with tr = dimension),
or ‘chi’ (chi-matrix representation).</p>
</dd>
<dt><strong>isherm</strong><span class="classifier">bool</span></dt><dd><p>Indicates if quantum object represents Hermitian operator.</p>
</dd>
<dt><strong>isunitary</strong><span class="classifier">bool</span></dt><dd><p>Indictaes if quantum object represents unitary operator.</p>
</dd>
<dt><strong>iscp</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents a map, and if that map is
completely positive (CP).</p>
</dd>
<dt><strong>ishp</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents a map, and if that map is
hermicity preserving (HP).</p>
</dd>
<dt><strong>istp</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents a map, and if that map is
trace preserving (TP).</p>
</dd>
<dt><strong>iscptp</strong><span class="classifier">bool</span></dt><dd><p>Indicates if the quantum object represents a map that is completely
positive and trace preserving (CPTP).</p>
</dd>
<dt><a class="reference internal" href="#qutip.core.qobj.Qobj.isket" title="qutip.core.qobj.Qobj.isket"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isket</span></code></a><span class="classifier">bool</span></dt><dd><p>Indicates if the Qobj represents a ket state.</p>
</dd>
<dt><a class="reference internal" href="#qutip.core.qobj.Qobj.isbra" title="qutip.core.qobj.Qobj.isbra"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isbra</span></code></a><span class="classifier">bool</span></dt><dd><p>Indicates if the Qobj represents a bra state.</p>
</dd>
<dt><a class="reference internal" href="#qutip.core.qobj.Qobj.isoper" title="qutip.core.qobj.Qobj.isoper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isoper</span></code></a><span class="classifier">bool</span></dt><dd><p>Indicates if the Qobj represents an operator.</p>
</dd>
<dt><a class="reference internal" href="#qutip.core.qobj.Qobj.issuper" title="qutip.core.qobj.Qobj.issuper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">issuper</span></code></a><span class="classifier">bool</span></dt><dd><p>Indicates if the Qobj represents a superoperator.</p>
</dd>
<dt><a class="reference internal" href="#qutip.core.qobj.Qobj.isoperket" title="qutip.core.qobj.Qobj.isoperket"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isoperket</span></code></a><span class="classifier">bool</span></dt><dd><p>Indicates if the Qobj represents a operator-ket state.</p>
</dd>
<dt><a class="reference internal" href="#qutip.core.qobj.Qobj.isoperbra" title="qutip.core.qobj.Qobj.isoperbra"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isoperbra</span></code></a><span class="classifier">bool</span></dt><dd><p>Indicates if the Qobj represents a operator-bra state.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p><strong>copy()</strong></p></td>
<td><p>Create copy of Qobj</p></td>
</tr>
<tr class="row-even"><td><p><strong>conj()</strong></p></td>
<td><p>Conjugate of quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>contract()</strong></p></td>
<td><p>Contract subspaces of the tensor structure which are 1D.</p></td>
</tr>
<tr class="row-even"><td><p><strong>cosm()</strong></p></td>
<td><p>Cosine of quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>dag()</strong></p></td>
<td><p>Adjoint (dagger) of quantum object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>data_as(format, copy)</strong></p></td>
<td><p>Vector / matrix representation of quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>diag()</strong></p></td>
<td><p>Diagonal elements of quantum object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>dnorm()</strong></p></td>
<td><p>Diamond norm of quantum operator.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>dual_chan()</strong></p></td>
<td><p>Dual channel of quantum object representing a CP map.</p></td>
</tr>
<tr class="row-even"><td><p><strong>eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000)</strong></p></td>
<td><p>Returns eigenenergies (eigenvalues) of a quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000)</strong></p></td>
<td><p>Returns eigenenergies and eigenstates of quantum object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>expm()</strong></p></td>
<td><p>Matrix exponential of quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>full(order=’C’)</strong></p></td>
<td><p>Returns dense array of quantum object <cite>data</cite> attribute.</p></td>
</tr>
<tr class="row-even"><td><p><strong>groundstate(sparse=False, tol=0, maxiter=100000)</strong></p></td>
<td><p>Returns eigenvalue and eigenket for the groundstate of a quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>inv()</strong></p></td>
<td><p>Return a Qobj corresponding to the matrix inverse of the operator.</p></td>
</tr>
<tr class="row-even"><td><p><strong>logm()</strong></p></td>
<td><p>Matrix logarithm of quantum operator.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>matrix_element(bra, ket)</strong></p></td>
<td><p>Returns the matrix element of operator between <cite>bra</cite> and <cite>ket</cite> vectors.</p></td>
</tr>
<tr class="row-even"><td><p><strong>norm(norm=’tr’, sparse=False, tol=0, maxiter=100000)</strong></p></td>
<td><p>Returns norm of a ket or an operator.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>overlap(other)</strong></p></td>
<td><p>Overlap between two state vectors or two operators.</p></td>
</tr>
<tr class="row-even"><td><p><strong>permute(order)</strong></p></td>
<td><p>Returns composite qobj with indices reordered.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>proj()</strong></p></td>
<td><p>Computes the projector for a ket or bra vector.</p></td>
</tr>
<tr class="row-even"><td><p><strong>ptrace(sel)</strong></p></td>
<td><p>Returns quantum object for selected dimensions after performing partial trace.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>purity()</strong></p></td>
<td><p>Calculates the purity of a quantum object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>sinm()</strong></p></td>
<td><p>Sine of quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>sqrtm()</strong></p></td>
<td><p>Matrix square root of quantum object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>tidyup(atol=1e-12)</strong></p></td>
<td><p>Removes small elements from quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>tr()</strong></p></td>
<td><p>Trace of quantum object.</p></td>
</tr>
<tr class="row-even"><td><p><strong>trans()</strong></p></td>
<td><p>Transpose of quantum object.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>transform(inpt, inverse=False)</strong></p></td>
<td><p>Performs a basis transformation defined by <cite>inpt</cite> matrix.</p></td>
</tr>
<tr class="row-even"><td><p><strong>trunc_neg(method=’clip’)</strong></p></td>
<td><p>Removes negative eigenvalues and returns a new Qobj that is a valid density operator.</p></td>
</tr>
<tr class="row-odd"><td><p><strong>unit(norm=’tr’, sparse=False, tol=0, maxiter=100000)</strong></p></td>
<td><p>Returns normalized quantum object.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.__call__" title="Permalink to this definition"></a></dt>
<dd><p>Acts this Qobj on another Qobj either by left-multiplication,
or by vectorization and devectorization, as
appropriate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.check_herm">
<span class="sig-name descname"><span class="pre">check_herm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.check_herm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.check_herm" title="Permalink to this definition"></a></dt>
<dd><p>Check if the quantum object is hermitian.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>isherm</strong><span class="classifier">bool</span></dt><dd><p>Returns the new value of isherm property.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.conj">
<span class="sig-name descname"><span class="pre">conj</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.conj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.conj" title="Permalink to this definition"></a></dt>
<dd><p>Get the element-wise conjugation of the quantum object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.contract">
<span class="sig-name descname"><span class="pre">contract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.contract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.contract" title="Permalink to this definition"></a></dt>
<dd><p>Contract subspaces of the tensor structure which are 1D.  Not defined
on superoperators.  If all dimensions are scalar, a Qobj of dimension
[[1], [1]] is returned, i.e. _multiple_ scalar dimensions are
contracted, but one is left.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace: bool, optional</strong></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, modify the dimensions in place.  If <code class="docutils literal notranslate"><span class="pre">False</span></code>, return
a copied object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>out: <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></dt><dd><p>Quantum object with dimensions contracted.  Will be <code class="docutils literal notranslate"><span class="pre">self</span></code> if
<code class="docutils literal notranslate"><span class="pre">inplace</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.copy" title="Permalink to this definition"></a></dt>
<dd><p>Create identical copy</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.cosm">
<span class="sig-name descname"><span class="pre">cosm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.cosm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.cosm" title="Permalink to this definition"></a></dt>
<dd><p>Cosine of a quantum operator.</p>
<p>Operator must be square.</p>
<dl class="field-list">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Matrix cosine of operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError</dt><dd><p>Quantum object is not square.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses the Q.expm() method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.dag">
<span class="sig-name descname"><span class="pre">dag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.dag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.dag" title="Permalink to this definition"></a></dt>
<dd><p>Get the Hermitian adjoint of the quantum object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.data_as">
<span class="sig-name descname"><span class="pre">data_as</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.data_as"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.data_as" title="Permalink to this definition"></a></dt>
<dd><p>Matrix from quantum object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>format</strong><span class="classifier">str, default: None</span></dt><dd><p>Type of the output, “ndarray” for <code class="docutils literal notranslate"><span class="pre">Dense</span></code>, “csr_matrix” for
<code class="docutils literal notranslate"><span class="pre">CSR</span></code>. A ValueError will be raised if the format is not
supported.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Whether to return a copy</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy.ndarray, scipy.sparse.matrix_csr, etc.</span></dt><dd><p>Matrix in the type of the underlying libraries.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.diag">
<span class="sig-name descname"><span class="pre">diag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.diag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.diag" title="Permalink to this definition"></a></dt>
<dd><p>Diagonal elements of quantum object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>diags</strong><span class="classifier">array</span></dt><dd><p>Returns array of <code class="docutils literal notranslate"><span class="pre">real</span></code> values if operators is Hermitian,
otherwise <code class="docutils literal notranslate"><span class="pre">complex</span></code> values are returned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.dnorm">
<span class="sig-name descname"><span class="pre">dnorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.dnorm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.dnorm" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the diamond norm, or the diamond distance to another
operator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>B</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a> or None</span></dt><dd><p>If B is not None, the diamond distance d(A, B) = dnorm(A - B)
between this operator and B is returned instead of the diamond norm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>d</strong><span class="classifier">float</span></dt><dd><p>Either the diamond norm of this operator, or the diamond distance
from this operator to B.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.dual_chan">
<span class="sig-name descname"><span class="pre">dual_chan</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.dual_chan"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.dual_chan" title="Permalink to this definition"></a></dt>
<dd><p>Dual channel of quantum object representing a completely positive
map.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.eigenenergies">
<span class="sig-name descname"><span class="pre">eigenenergies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'low'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigvals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.eigenenergies"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.eigenenergies" title="Permalink to this definition"></a></dt>
<dd><p>Eigenenergies of a quantum object.</p>
<p>Eigenenergies (eigenvalues) are defined for operators or superoperators
only.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Use sparse Eigensolver</p>
</dd>
<dt><strong>sort</strong><span class="classifier">str</span></dt><dd><p>Sort eigenvalues ‘low’ to high, or ‘high’ to low.</p>
</dd>
<dt><strong>eigvals</strong><span class="classifier">int</span></dt><dd><p>Number of requested eigenvalues. Default is all eigenvalues.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse Eigensolver (0=machine precision).
The sparse solver may not converge if the tolerance is set too low.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations performed by sparse solver (if used).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigvals</strong><span class="classifier">array</span></dt><dd><p>Array of eigenvalues for operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.eigenstates">
<span class="sig-name descname"><span class="pre">eigenstates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'low'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigvals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_fix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.eigenstates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.eigenstates" title="Permalink to this definition"></a></dt>
<dd><p>Eigenstates and eigenenergies.</p>
<p>Eigenstates and eigenenergies are defined for operators and
superoperators only.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Use sparse Eigensolver</p>
</dd>
<dt><strong>sort</strong><span class="classifier">str</span></dt><dd><p>Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low.</p>
</dd>
<dt><strong>eigvals</strong><span class="classifier">int</span></dt><dd><p>Number of requested eigenvalues. Default is all eigenvalues.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse Eigensolver (0 = machine precision).
The sparse solver may not converge if the tolerance is set too low.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations performed by sparse solver (if used).</p>
</dd>
<dt><strong>phase_fix</strong><span class="classifier">int, None</span></dt><dd><p>If not None, set the phase of each kets so that ket[phase_fix,0]
is real positive.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigvals</strong><span class="classifier">array</span></dt><dd><p>Array of eigenvalues for operator.</p>
</dd>
<dt><strong>eigvecs</strong><span class="classifier">array</span></dt><dd><p>Array of quantum operators representing the oprator eigenkets.
Order of eigenkets is determined by order of eigenvalues.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.expm">
<span class="sig-name descname"><span class="pre">expm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'qutip.core.data.dense.Dense'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.expm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.expm" title="Permalink to this definition"></a></dt>
<dd><p>Matrix exponential of quantum operator.</p>
<p>Input operator must be square.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">type</span></dt><dd><p>The data-layer type that should be output.  As the matrix
exponential is almost dense, this defaults to outputting dense
matrices.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Exponentiated quantum operator.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>Quantum operator is not square.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.full">
<span class="sig-name descname"><span class="pre">full</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'C'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">squeeze</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.full"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.full" title="Permalink to this definition"></a></dt>
<dd><p>Dense array from quantum object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">str {‘C’, ‘F’}</span></dt><dd><p>Return array in C (default) or Fortran ordering.</p>
</dd>
<dt><strong>squeeze</strong><span class="classifier">bool {False, True}</span></dt><dd><p>Squeeze output array.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array</span></dt><dd><p>Array of complex data from quantum objects <cite>data</cite> attribute.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.groundstate">
<span class="sig-name descname"><span class="pre">groundstate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.groundstate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.groundstate" title="Permalink to this definition"></a></dt>
<dd><p>Ground state Eigenvalue and Eigenvector.</p>
<p>Defined for quantum operators or superoperators only.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Use sparse Eigensolver</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse Eigensolver (0 = machine precision).
The sparse solver may not converge if the tolerance is set too low.</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations performed by sparse solver (if used).</p>
</dd>
<dt><strong>safe</strong><span class="classifier">bool (default=True)</span></dt><dd><p>Check for degenerate ground state</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>eigval</strong><span class="classifier">float</span></dt><dd><p>Eigenvalue for the ground state of quantum operator.</p>
</dd>
<dt><strong>eigvec</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Eigenket for the ground state of quantum operator.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.inv">
<span class="sig-name descname"><span class="pre">inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.inv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.inv" title="Permalink to this definition"></a></dt>
<dd><p>Matrix inverse of a quantum operator</p>
<p>Operator must be square.</p>
<dl class="field-list">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Matrix inverse of operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError</dt><dd><p>Quantum object is not square.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.isbra">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">isbra</span></span><a class="headerlink" href="#qutip.core.qobj.Qobj.isbra" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if the Qobj represents a bra state.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.isket">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">isket</span></span><a class="headerlink" href="#qutip.core.qobj.Qobj.isket" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if the Qobj represents a ket state.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.isoper">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">isoper</span></span><a class="headerlink" href="#qutip.core.qobj.Qobj.isoper" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if the Qobj represents an operator.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.isoperbra">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">isoperbra</span></span><a class="headerlink" href="#qutip.core.qobj.Qobj.isoperbra" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if the Qobj represents a operator-bra state.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.isoperket">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">isoperket</span></span><a class="headerlink" href="#qutip.core.qobj.Qobj.isoperket" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if the Qobj represents a operator-ket state.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.issuper">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">issuper</span></span><a class="headerlink" href="#qutip.core.qobj.Qobj.issuper" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if the Qobj represents a superoperator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.logm">
<span class="sig-name descname"><span class="pre">logm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.logm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.logm" title="Permalink to this definition"></a></dt>
<dd><p>Matrix logarithm of quantum operator.</p>
<p>Input operator must be square.</p>
<dl class="field-list">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Logarithm of the quantum operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError</dt><dd><p>Quantum operator is not square.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.matrix_element">
<span class="sig-name descname"><span class="pre">matrix_element</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bra</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ket</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.matrix_element"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.matrix_element" title="Permalink to this definition"></a></dt>
<dd><p>Calculates a matrix element.</p>
<p>Gives the matrix element for the quantum object sandwiched between a
<cite>bra</cite> and <cite>ket</cite> vector.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>bra</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Quantum object of type ‘bra’ or ‘ket’</p>
</dd>
<dt><strong>ket</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Quantum object of type ‘ket’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>elem</strong><span class="classifier">complex</span></dt><dd><p>Complex valued matrix element.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It is slightly more computationally efficient to use a ket
vector for the ‘bra’ input.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.norm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.norm" title="Permalink to this definition"></a></dt>
<dd><p>Norm of a quantum object.</p>
<p>Default norm is L2-norm for kets and trace-norm for operators.  Other
ket and operator norms may be specified using the <cite>norm</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">str</span></dt><dd><p>Which type of norm to use.  Allowed values for vectors are ‘l2’ and
‘max’.  Allowed values for matrices are ‘tr’ for the trace norm,
‘fro’ for the Frobenius norm, ‘one’ and ‘max’.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional keyword arguments to pass on to the relevant norm
solver.  See details for each norm function in <code class="xref py py-mod docutils literal notranslate"><span class="pre">data.norm</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>norm</strong><span class="classifier">float</span></dt><dd><p>The requested norm of the operator or state quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.overlap">
<span class="sig-name descname"><span class="pre">overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.overlap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.overlap" title="Permalink to this definition"></a></dt>
<dd><p>Overlap between two state vectors or two operators.</p>
<p>Gives the overlap (inner product) between the current bra or ket Qobj
and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap
when one of the Qobj is an operator/density matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Quantum object for a state vector of type ‘ket’, ‘bra’ or density
matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>overlap</strong><span class="classifier">complex</span></dt><dd><p>Complex valued overlap.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>Can only calculate overlap between a bra, ket and density matrix
quantum objects.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.permute">
<span class="sig-name descname"><span class="pre">permute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.permute"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.permute" title="Permalink to this definition"></a></dt>
<dd><p>Permute the tensor structure of a quantum object.  For example,</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">qutip.tensor(x,</span> <span class="pre">y).permute([1,</span> <span class="pre">0])</span></code></p>
</div></blockquote>
<p>will give the same result as</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">qutip.tensor(y,</span> <span class="pre">x)</span></code></p>
</div></blockquote>
<p>and</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">qutip.tensor(a,</span> <span class="pre">b,</span> <span class="pre">c).permute([1,</span> <span class="pre">2,</span> <span class="pre">0])</span></code></p>
</div></blockquote>
<p>will be the same as</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">qutip.tensor(b,</span> <span class="pre">c,</span> <span class="pre">a)</span></code></p>
</div></blockquote>
<p>For regular objects (bras, kets and operators) we expect <code class="docutils literal notranslate"><span class="pre">order</span></code> to
be a flat list of integers, which specifies the new order of the tensor
product.</p>
<p>For superoperators, we expect <code class="docutils literal notranslate"><span class="pre">order</span></code> to be something like</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">[[0,</span> <span class="pre">2],</span> <span class="pre">[1,</span> <span class="pre">3]]</span></code></p>
</div></blockquote>
<p>which tells us to permute according to [0, 2, 1, 3], and then group
indices according to the length of each sublist.  As another example,
permuting a superoperator with dimensions of</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">[[[1,</span> <span class="pre">2,</span> <span class="pre">3],</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]],</span> <span class="pre">[[1,</span> <span class="pre">2,</span> <span class="pre">3],</span> <span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]]]</span></code></p>
</div></blockquote>
<p>by an <code class="docutils literal notranslate"><span class="pre">order</span></code></p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">[[0,</span> <span class="pre">3],</span> <span class="pre">[1,</span> <span class="pre">4],</span> <span class="pre">[2,</span> <span class="pre">5]]</span></code></p>
</div></blockquote>
<p>should give a new object with dimensions</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">[[[1,</span> <span class="pre">1],</span> <span class="pre">[2,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">3]],</span> <span class="pre">[[1,</span> <span class="pre">1],</span> <span class="pre">[2,</span> <span class="pre">2],</span> <span class="pre">[3,</span> <span class="pre">3]]]</span></code>.</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">list</span></dt><dd><p>List of indices specifying the new tensor order.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>P</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Permuted quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.proj">
<span class="sig-name descname"><span class="pre">proj</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.proj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.proj" title="Permalink to this definition"></a></dt>
<dd><p>Form the projector from a given ket or bra vector.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>Q</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Input bra or ket vector</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>P</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Projection operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.ptrace">
<span class="sig-name descname"><span class="pre">ptrace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.ptrace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.ptrace" title="Permalink to this definition"></a></dt>
<dd><p>Take the partial trace of the quantum object leaving the selected
subspaces.  In other words, trace out all subspaces which are _not_
passed.</p>
<p>This is typically a function which acts on operators; bras and kets
will be promoted to density matrices before the operation takes place
since the partial trace is inherently undefined on pure states.</p>
<p>For operators which are currently being represented as states in the
superoperator formalism (i.e. the object has type <cite>operator-ket</cite> or
<cite>operator-bra</cite>), the partial trace is applied as if the operator were
in the conventional form.  This means that for any operator <cite>x</cite>,
<code class="docutils literal notranslate"><span class="pre">operator_to_vector(x).ptrace(0)</span> <span class="pre">==</span> <span class="pre">operator_to_vector(x.ptrace(0))</span></code>
and similar for <cite>operator-bra</cite>.</p>
<p>The story is different for full superoperators.  In the formalism that
QuTiP uses, if an operator has dimensions (<cite>dims</cite>) of
<cite>[[2, 3], [2, 3]]</cite> then it can be represented as a state on a Hilbert
space of dimensions <cite>[2, 3, 2, 3]</cite>, and a superoperator would be an
operator which acts on this joint space.  This function performs the
partial trace on superoperators by letting the selected components
refer to elements of the _joint_ _space_, and then returns a regular
operator (of type <cite>oper</cite>).</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sel</strong><span class="classifier">int or iterable of int</span></dt><dd><p>An <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> of components to keep after partial trace.
The selected subspaces will _not_ be reordered, no matter order
they are supplied to <cite>ptrace</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Quantum object representing partial trace with selected components
remaining.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.purity">
<span class="sig-name descname"><span class="pre">purity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.purity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.purity" title="Permalink to this definition"></a></dt>
<dd><p>Calculate purity of a quantum object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>state_purity</strong><span class="classifier">float</span></dt><dd><p>Returns the purity of a quantum object.
For a pure state, the purity is 1.
For a mixed state of dimension <cite>d</cite>, 1/d&lt;=purity&lt;1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#qutip.core.qobj.Qobj.shape" title="Permalink to this definition"></a></dt>
<dd><p>Return the shape of the Qobj data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.sinm">
<span class="sig-name descname"><span class="pre">sinm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.sinm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.sinm" title="Permalink to this definition"></a></dt>
<dd><p>Sine of a quantum operator.</p>
<p>Operator must be square.</p>
<dl class="field-list">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Matrix sine of operator.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError</dt><dd><p>Quantum object is not square.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses the Q.expm() method.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.sqrtm">
<span class="sig-name descname"><span class="pre">sqrtm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxiter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.sqrtm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.sqrtm" title="Permalink to this definition"></a></dt>
<dd><p>Sqrt of a quantum operator.  Operator must be square.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sparse</strong><span class="classifier">bool</span></dt><dd><p>Use sparse eigenvalue/vector solver.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used by sparse solver (0 = machine precision).</p>
</dd>
<dt><strong>maxiter</strong><span class="classifier">int</span></dt><dd><p>Maximum number of iterations used by sparse solver.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Matrix square root of operator.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>Quantum object is not square.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.tidyup">
<span class="sig-name descname"><span class="pre">tidyup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.tidyup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.tidyup" title="Permalink to this definition"></a></dt>
<dd><p>Removes small elements from the quantum object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>Absolute tolerance used by tidyup. Default is set
via qutip global settings parameters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Quantum object with small elements removed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.to">
<span class="sig-name descname"><span class="pre">to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data_type</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.to"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.to" title="Permalink to this definition"></a></dt>
<dd><p>Convert the underlying data store of this <cite>Qobj</cite> into a different
storage representation.</p>
<p>The different storage representations available are the “data-layer
types” which are known to <code class="xref py py-obj docutils literal notranslate"><span class="pre">qutip.core.data.to</span></code>.  By default, these
are <code class="xref py py-class docutils literal notranslate"><span class="pre">CSR</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Dense</span></code> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">Dia</span></code>, which respectively construct a
compressed sparse row matrix, diagonal matrix and a dense one.  Certain
algorithms and operations may be faster or more accurate when using a
more appropriate data store.</p>
<p>If the data store is already in the format requested, the function
returns <cite>self</cite>.  Otherwise, it returns a copy of itself with the data
store in the new type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data_type</strong><span class="classifier">type</span></dt><dd><p>The data-layer type that the data of this <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a> should be
converted to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Qobj</dt><dd><p>A new <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a> if a type conversion took place with the data
stored in the requested format, or <cite>self</cite> if not.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.tr">
<span class="sig-name descname"><span class="pre">tr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.tr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.tr" title="Permalink to this definition"></a></dt>
<dd><p>Trace of a quantum object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>trace</strong><span class="classifier">float</span></dt><dd><p>Returns the trace of the quantum object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.trans">
<span class="sig-name descname"><span class="pre">trans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.trans"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.trans" title="Permalink to this definition"></a></dt>
<dd><p>Get the matrix transpose of the quantum operator.</p>
<dl class="field-list">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Transpose of input operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inpt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.transform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.transform" title="Permalink to this definition"></a></dt>
<dd><p>Basis transform defined by input array.</p>
<p>Input array can be a <code class="docutils literal notranslate"><span class="pre">matrix</span></code> defining the transformation,
or a <code class="docutils literal notranslate"><span class="pre">list</span></code> of kets that defines the new basis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inpt</strong><span class="classifier">array_like</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">matrix</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> of kets defining the transformation.</p>
</dd>
<dt><strong>inverse</strong><span class="classifier">bool</span></dt><dd><p>Whether to return inverse transformation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Operator in new basis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is still in development.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.trunc_neg">
<span class="sig-name descname"><span class="pre">trunc_neg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'clip'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.trunc_neg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.trunc_neg" title="Permalink to this definition"></a></dt>
<dd><p>Truncates negative eigenvalues and renormalizes.</p>
<p>Returns a new Qobj by removing the negative eigenvalues
of this instance, then renormalizing to obtain a valid density
operator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>Algorithm to use to remove negative eigenvalues. “clip”
simply discards negative eigenvalues, then renormalizes.
“sgs” uses the SGS algorithm (doi:10/bb76) to find the
positive operator that is nearest in the Shatten 2-norm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>oper</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>A valid density operator.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.qobj.Qobj.unit">
<span class="sig-name descname"><span class="pre">unit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/core/qobj.html#Qobj.unit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.core.qobj.Qobj.unit" title="Permalink to this definition"></a></dt>
<dd><p>Operator or state normalized to unity.  Uses norm from Qobj.norm().</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool</span></dt><dd><p>Do an in-place normalization</p>
</dd>
<dt><strong>norm</strong><span class="classifier">str</span></dt><dd><p>Requested norm for states / operators.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional key-word arguments to be passed on to the relevant norm
function (see <a class="reference internal" href="#qutip.core.qobj.Qobj.norm" title="qutip.core.qobj.Qobj.norm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">norm</span></code></a> for more details).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>obj</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Normalized quantum object.  Will be the <cite>self</cite> object if in place.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="qobjevo">
<span id="classes-qobjevo"></span><h2>QobjEvo<a class="headerlink" href="#qobjevo" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">QobjEvo</span></span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo" title="Permalink to this definition"></a></dt>
<dd><p>A class for representing time-dependent quantum objects, such as quantum
operators and states.</p>
<p>Importantly, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> instances are used to represent such
time-dependent quantum objects when working with QuTiP solvers.</p>
<p>A <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> instance may be constructed from one of the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>a callable <code class="docutils literal notranslate"><span class="pre">f(t:</span> <span class="pre">double,</span> <span class="pre">args:</span> <span class="pre">dict)</span> <span class="pre">-&gt;</span> <span class="pre">Qobj</span></code> that returns the
value of the quantum object at time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
<li><p>a <code class="docutils literal notranslate"><span class="pre">[Qobj,</span> <span class="pre">Coefficient]</span></code> pair, where the <code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code> may be any
item that <a class="reference internal" href="functions.html#qutip.core.coefficient.coefficient" title="qutip.core.coefficient.coefficient"><code class="xref py py-func docutils literal notranslate"><span class="pre">coefficient</span></code></a> can accept (e.g. a function, a numpy
array of coefficient values, a string expression).</p></li>
<li><p>a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> (which creates a constant <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> term).</p></li>
<li><p>a list of such callables, pairs or <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>s.</p></li>
<li><p>a <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> (in which case a copy is created, all other arguments
are ignored except <code class="docutils literal notranslate"><span class="pre">args</span></code> which, if passed, replaces the existing
arguments).</p></li>
</ul>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>Q_object</strong><span class="classifier">callable, list or <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>A specification of the time-depedent quantum object. See the
paragraph above for a full description and the examples section below
for examples.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional</span></dt><dd><p>A dictionary that contains the arguments for the coefficients.
Arguments may be omitted if no function or string coefficients that
require arguments are present.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">array-like, optional</span></dt><dd><p>A list of times corresponding to the values of the coefficients
supplied as numpy arrays. If no coefficients are supplied as numpy
arrays, <code class="docutils literal notranslate"><span class="pre">tlist</span></code> may be omitted, otherwise it is required.</p>
<p>The times in <code class="docutils literal notranslate"><span class="pre">tlist</span></code> do not need to be equidistant, but must
be sorted.</p>
<p>By default, a cubic spline interpolation will be used to interpolate
the value of the (numpy array) coefficients at time <code class="docutils literal notranslate"><span class="pre">t</span></code>. If the
coefficients are to be treated as step functions, pass the argument
<code class="docutils literal notranslate"><span class="pre">order=0</span></code> (see below).</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, default=3</span></dt><dd><p>Order of the spline interpolation that is to be used to interpolate
the value of the (numpy array) coefficients at time <code class="docutils literal notranslate"><span class="pre">t</span></code>.
<code class="docutils literal notranslate"><span class="pre">0</span></code> use previous or left value.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to make a copy of the <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> instances supplied in
the <code class="docutils literal notranslate"><span class="pre">Q_object</span></code> parameter.</p>
</dd>
<dt><strong>compress</strong><span class="classifier">bool, default=True</span></dt><dd><p>Whether to compress the <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> instance terms after the
instance has been created.</p>
<p>This sums the constant terms in a single term and combines
<code class="docutils literal notranslate"><span class="pre">[Qobj,</span> <span class="pre">coefficient]</span></code> pairs with the same <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> into a single
pair containing the sum of the coefficients.</p>
<p>See <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo.compress" title="qutip.core.cy.qobjevo.QobjEvo.compress"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compress</span></code></a>.</p>
</dd>
<dt><strong>function_style</strong><span class="classifier">{None, “pythonic”, “dict”, “auto”}</span></dt><dd><p>The style of function signature used by callables in <code class="docutils literal notranslate"><span class="pre">Q_object</span></code>.
If style is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the value of
<code class="docutils literal notranslate"><span class="pre">qutip.settings.core[&quot;function_coefficient_style&quot;]</span></code>
is used. Otherwise the supplied value overrides the global setting.</p>
</dd>
<dt><strong>boundary_conditions</strong><span class="classifier">2-Tuple, str or None, optional</span></dt><dd><p>Boundary conditions for spline evaluation. Default value is <cite>None</cite>.
Correspond to <cite>bc_type</cite> of scipy.interpolate.make_interp_spline.
Refer to Scipy’s documentation for further details:
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.make_interp_spline.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.make_interp_spline.html</a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>A <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> constructed from a function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">qutip</span><span class="o">.</span><span class="n">qeye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>

<span class="n">QobjEvo</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="n">j</span><span class="p">})</span>
</pre></div>
</div>
<p>For list based <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, the list must consist of <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> or
<code class="docutils literal notranslate"><span class="pre">[Qobj,</span> <span class="pre">Coefficient]</span></code> pairs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QobjEvo</span><span class="p">([</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">coeff1</span><span class="p">],</span> <span class="p">[</span><span class="n">H2</span><span class="p">,</span> <span class="n">coeff2</span><span class="p">]],</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>The coefficients may be specified either using a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code> object
or by a function, string, numpy array or any object that can be passed to
the <a class="reference internal" href="functions.html#qutip.core.coefficient.coefficient" title="qutip.core.coefficient.coefficient"><code class="xref py py-func docutils literal notranslate"><span class="pre">coefficient</span></code></a> function. See the documentation of
<a class="reference internal" href="functions.html#qutip.core.coefficient.coefficient" title="qutip.core.coefficient.coefficient"><code class="xref py py-func docutils literal notranslate"><span class="pre">coefficient</span></code></a> for a full description.</p>
<p>An example of a coefficient specified by a function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f1_t</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">args</span><span class="p">[</span><span class="s2">&quot;w1&quot;</span><span class="p">])</span>

<span class="n">QobjEvo</span><span class="p">([[</span><span class="n">H1</span><span class="p">,</span> <span class="n">f1_t</span><span class="p">]],</span> <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;w1&quot;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">})</span>
</pre></div>
</div>
<p>And of coefficients specified by string expressions:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="n">QobjEvo</span><span class="p">(</span>
    <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s1">&#39;exp(-1j*w1*t)&#39;</span><span class="p">],</span> <span class="p">[</span><span class="n">H2</span><span class="p">,</span> <span class="s1">&#39;cos(w2*t)&#39;</span><span class="p">]],</span>
    <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;w1&quot;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span> <span class="s2">&quot;w2&quot;</span><span class="p">:</span> <span class="mf">2.</span><span class="p">}</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Coefficients maybe also be expressed as numpy arrays giving a list
of the coefficient values:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">QobjEvo</span><span class="p">(</span>
    <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">tlist</span><span class="p">)],</span> <span class="p">[</span><span class="n">H2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">tlist</span><span class="p">)]],</span>
    <span class="n">tlist</span><span class="o">=</span><span class="n">tlist</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The coeffients array must have the same len as the tlist.</p>
<p>A <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> may also be built using simple arithmetic operations
combining <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> with <code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code>, for example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">coeff</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">coefficient</span><span class="p">(</span><span class="s2">&quot;exp(-1j*w1*t)&quot;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;w1&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="n">qevo</span> <span class="o">=</span> <span class="n">H0</span> <span class="o">+</span> <span class="n">H1</span> <span class="o">*</span> <span class="n">coeff</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dims</strong><span class="classifier">list</span></dt><dd><p>List of dimensions keeping track of the tensor structure.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">(int, int)</span></dt><dd><p>List of dimensions keeping track of the tensor structure.</p>
</dd>
<dt><strong>type</strong><span class="classifier">str</span></dt><dd><p>Type of quantum object: ‘bra’, ‘ket’, ‘oper’, ‘operator-ket’,
‘operator-bra’, or ‘super’.</p>
</dd>
<dt><strong>superrep</strong><span class="classifier">str</span></dt><dd><p>Representation used if <cite>type</cite> is ‘super’. One of ‘super’
(Liouville form) or ‘choi’ (Choi matrix with tr = dimension).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.__call__" title="Permalink to this definition"></a></dt>
<dd><p>Get the <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> at <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>Time at which the <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> is to be evalued.</p>
</dd>
<dt><strong>_args</strong><span class="classifier">dict [optional]</span></dt><dd><p>New arguments as a dict. Update args with <code class="docutils literal notranslate"><span class="pre">arguments(new_args)</span></code>.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>New arguments as a keywors. Update args with
<code class="docutils literal notranslate"><span class="pre">arguments(**new_args)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both the positional <code class="docutils literal notranslate"><span class="pre">_args</span></code> and keywords are passed new values
from both will be used. If a key is present with both, the
<code class="docutils literal notranslate"><span class="pre">_args</span></code> dict value will take priority.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.arguments">
<span class="sig-name descname"><span class="pre">arguments</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.arguments" title="Permalink to this definition"></a></dt>
<dd><p>Update the arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>_args</strong><span class="classifier">dict [optional]</span></dt><dd><p>New arguments as a dict. Update args with <code class="docutils literal notranslate"><span class="pre">arguments(new_args)</span></code>.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>New arguments as a keywors. Update args with
<code class="docutils literal notranslate"><span class="pre">arguments(**new_args)</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If both the positional <code class="docutils literal notranslate"><span class="pre">_args</span></code> and keywords are passed new values
from both will be used. If a key is present with both, the <code class="docutils literal notranslate"><span class="pre">_args</span></code>
dict value will take priority.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.compress">
<span class="sig-name descname"><span class="pre">compress</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.compress" title="Permalink to this definition"></a></dt>
<dd><p>Look for redundance in the <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> components:</p>
<p>Constant parts, (<a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> without <code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code>) will be
summed.
Pairs <code class="docutils literal notranslate"><span class="pre">[Qobj,</span> <span class="pre">Coefficient]</span></code> with the same <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> are merged.</p>
<p>Example:
<code class="docutils literal notranslate"><span class="pre">[[sigmax(),</span> <span class="pre">f1],</span> <span class="pre">[sigmax(),</span> <span class="pre">f2]]</span> <span class="pre">-&gt;</span> <span class="pre">[[sigmax(),</span> <span class="pre">f1+f2]]</span></code></p>
<p>The <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> is transformed inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.conj">
<span class="sig-name descname"><span class="pre">conj</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.conj" title="Permalink to this definition"></a></dt>
<dd><p>Get the element-wise conjugation of the quantum object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.copy" title="Permalink to this definition"></a></dt>
<dd><p>Return a copy of this <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.dag">
<span class="sig-name descname"><span class="pre">dag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.dag" title="Permalink to this definition"></a></dt>
<dd><p>Get the Hermitian adjoint of the quantum object.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.dtype">
<span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.dtype" title="Permalink to this definition"></a></dt>
<dd><p>Type of the data layers of the QobjEvo.
When different data layers are used, we return the type of the sum of
the parts.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.expect">
<span class="sig-name descname"><span class="pre">expect</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.expect" title="Permalink to this definition"></a></dt>
<dd><p>Expectation value of this operator at time <code class="docutils literal notranslate"><span class="pre">t</span></code> with the state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>Time of the operator to apply.</p>
</dd>
<dt><strong>state</strong><span class="classifier">Qobj</span></dt><dd><p>right matrix of the product</p>
</dd>
<dt><strong>check_real</strong><span class="classifier">bool (True)</span></dt><dd><p>Whether to convert the result to a <cite>real</cite> when the imaginary part
is smaller than the real part by a dactor of
<code class="docutils literal notranslate"><span class="pre">settings.core['rtol']</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>expect</strong><span class="classifier">float or complex</span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">state.adjoint()</span> <span class="pre">&#64;</span> <span class="pre">self</span> <span class="pre">&#64;</span> <span class="pre">state</span></code> if <code class="docutils literal notranslate"><span class="pre">state</span></code> is a ket.
<code class="docutils literal notranslate"><span class="pre">trace(self</span> <span class="pre">&#64;</span> <span class="pre">matrix)</span></code> is <code class="docutils literal notranslate"><span class="pre">state</span></code> is an operator or
operator-ket.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.expect_data">
<span class="sig-name descname"><span class="pre">expect_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.expect_data" title="Permalink to this definition"></a></dt>
<dd><p>Expectation is defined as <code class="docutils literal notranslate"><span class="pre">state.adjoint()</span> <span class="pre">&#64;</span> <span class="pre">self</span> <span class="pre">&#64;</span> <span class="pre">state</span></code> if
<code class="docutils literal notranslate"><span class="pre">state</span></code> is a vector, or <code class="docutils literal notranslate"><span class="pre">state</span></code> is an operator and <code class="docutils literal notranslate"><span class="pre">self</span></code> is a
superoperator.  If <code class="docutils literal notranslate"><span class="pre">state</span></code> is an operator and <code class="docutils literal notranslate"><span class="pre">self</span></code> is an
operator, then expectation is <code class="docutils literal notranslate"><span class="pre">trace(self</span> <span class="pre">&#64;</span> <span class="pre">matrix)</span></code>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.isbra">
<span class="sig-name descname"><span class="pre">isbra</span></span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.isbra" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if the system represents a bra state.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.isconstant">
<span class="sig-name descname"><span class="pre">isconstant</span></span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.isconstant" title="Permalink to this definition"></a></dt>
<dd><p>Does the system change depending on <code class="docutils literal notranslate"><span class="pre">t</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.isket">
<span class="sig-name descname"><span class="pre">isket</span></span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.isket" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if the system represents a ket state.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.isoper">
<span class="sig-name descname"><span class="pre">isoper</span></span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.isoper" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if the system represents an operator.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.isoperbra">
<span class="sig-name descname"><span class="pre">isoperbra</span></span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.isoperbra" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if the system represents a operator-bra state.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.isoperket">
<span class="sig-name descname"><span class="pre">isoperket</span></span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.isoperket" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if the system represents a operator-ket state.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.issuper">
<span class="sig-name descname"><span class="pre">issuper</span></span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.issuper" title="Permalink to this definition"></a></dt>
<dd><p>Indicates if the system represents a superoperator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.linear_map">
<span class="sig-name descname"><span class="pre">linear_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.linear_map" title="Permalink to this definition"></a></dt>
<dd><p>Apply mapping to each Qobj contribution.</p>
<p class="rubric">Example</p>
<p><code class="docutils literal notranslate"><span class="pre">QobjEvo([sigmax(),</span> <span class="pre">coeff]).linear_map(spre)</span></code></p>
<p>gives the same result has</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([spre(sigmax()),</span> <span class="pre">coeff])</span></code></p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>op_mapping: callable</strong></dt><dd><p>Funtion to apply to each elements.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></a></dt><dd><p>Modified object</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Does not modify the coefficients, thus <code class="docutils literal notranslate"><span class="pre">linear_map(conj)</span></code> would not
give the the conjugate of the QobjEvo. It’s only valid for linear
transformations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.matmul">
<span class="sig-name descname"><span class="pre">matmul</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.matmul" title="Permalink to this definition"></a></dt>
<dd><p>Product of this operator at time <code class="docutils literal notranslate"><span class="pre">t</span></code> to the state.
<code class="docutils literal notranslate"><span class="pre">self(t)</span> <span class="pre">&#64;</span> <span class="pre">state</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>Time of the operator to apply.</p>
</dd>
<dt><strong>state</strong><span class="classifier">Qobj</span></dt><dd><p>right matrix of the product</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>product</strong><span class="classifier">Qobj</span></dt><dd><p>The result product as a Qobj</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.matmul_data">
<span class="sig-name descname"><span class="pre">matmul_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.matmul_data" title="Permalink to this definition"></a></dt>
<dd><p>Compute <code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">+=</span> <span class="pre">self(t)</span> <span class="pre">&#64;</span> <span class="pre">state</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.num_elements">
<span class="sig-name descname"><span class="pre">num_elements</span></span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.num_elements" title="Permalink to this definition"></a></dt>
<dd><p>Number of parts composing the system</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.tidyup">
<span class="sig-name descname"><span class="pre">tidyup</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.tidyup" title="Permalink to this definition"></a></dt>
<dd><p>Removes small elements from quantum object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.to">
<span class="sig-name descname"><span class="pre">to</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.to" title="Permalink to this definition"></a></dt>
<dd><p>Convert the underlying data store of all component into the desired
storage representation.</p>
<p>The different storage representations available are the “data-layer
types”.  By default, these are <code class="xref py py-obj docutils literal notranslate"><span class="pre">Dense</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Dia</span></code> and
<code class="xref py py-obj docutils literal notranslate"><span class="pre">CSR</span></code>, which respectively construct a dense matrix, diagonal
sparse matrixand a compressed sparse row one.</p>
<p>The <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> is transformed inplace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data_type</strong><span class="classifier">type</span></dt><dd><p>The data-layer type that the data of this <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> should be
converted to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.to_list">
<span class="sig-name descname"><span class="pre">to_list</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.to_list" title="Permalink to this definition"></a></dt>
<dd><p>Restore the QobjEvo to a list form.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>list_qevo: list</dt><dd><p>The QobjEvo as a list, element are either <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> for
constant parts, <code class="docutils literal notranslate"><span class="pre">[Qobj,</span> <span class="pre">Coefficient]</span></code> for coefficient based term.
The original format of the <code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code> is not restored.
Lastly if the original <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> is constructed with a
function returning a Qobj, the term is returned as a pair of the
original function and args (<code class="docutils literal notranslate"><span class="pre">dict</span></code>).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.core.cy.qobjevo.QobjEvo.trans">
<span class="sig-name descname"><span class="pre">trans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.core.cy.qobjevo.QobjEvo.trans" title="Permalink to this definition"></a></dt>
<dd><p>Transpose of the quantum object</p>
</dd></dl>

</dd></dl>

</section>
<section id="bloch-sphere">
<span id="classes-bloch"></span><h2>Bloch sphere<a class="headerlink" href="#bloch-sphere" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.bloch.Bloch">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Bloch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">view</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch" title="Permalink to this definition"></a></dt>
<dd><p>Class for plotting data on the Bloch sphere.  Valid data can be either
points, vectors, or Qobj objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axes</strong><span class="classifier">matplotlib.axes.Axes</span></dt><dd><p>User supplied Matplotlib axes for Bloch sphere animation.</p>
</dd>
<dt><strong>fig</strong><span class="classifier">matplotlib.figure.Figure</span></dt><dd><p>User supplied Matplotlib Figure instance for plotting Bloch sphere.</p>
</dd>
<dt><strong>font_color</strong><span class="classifier">str, default ‘black’</span></dt><dd><p>Color of font used for Bloch sphere labels.</p>
</dd>
<dt><strong>font_size</strong><span class="classifier">int, default 20</span></dt><dd><p>Size of font used for Bloch sphere labels.</p>
</dd>
<dt><strong>frame_alpha</strong><span class="classifier">float, default 0.1</span></dt><dd><p>Sets transparency of Bloch sphere frame.</p>
</dd>
<dt><strong>frame_color</strong><span class="classifier">str, default ‘gray’</span></dt><dd><p>Color of sphere wireframe.</p>
</dd>
<dt><strong>frame_width</strong><span class="classifier">int, default 1</span></dt><dd><p>Width of wireframe.</p>
</dd>
<dt><strong>point_color</strong><span class="classifier">list, default [“b”, “r”, “g”, “#CC6600”]</span></dt><dd><p>List of colors for Bloch sphere point markers to cycle through, i.e.
by default, points 0 and 4 will both be blue (‘b’).</p>
</dd>
<dt><strong>point_marker</strong><span class="classifier">list, default [“o”, “s”, “d”, “^”]</span></dt><dd><p>List of point marker shapes to cycle through.</p>
</dd>
<dt><strong>point_size</strong><span class="classifier">list, default [25, 32, 35, 45]</span></dt><dd><p>List of point marker sizes. Note, not all point markers look the same
size when plotted!</p>
</dd>
<dt><strong>sphere_alpha</strong><span class="classifier">float, default 0.2</span></dt><dd><p>Transparency of Bloch sphere itself.</p>
</dd>
<dt><strong>sphere_color</strong><span class="classifier">str, default ‘#FFDDDD’</span></dt><dd><p>Color of Bloch sphere.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">list, default [7, 7]</span></dt><dd><p>Figure size of Bloch sphere plot.  Best to have both numbers the same;
otherwise you will have a Bloch sphere that looks like a football.</p>
</dd>
<dt><strong>vector_color</strong><span class="classifier">list, [“g”, “#CC6600”, “b”, “r”]</span></dt><dd><p>List of vector colors to cycle through.</p>
</dd>
<dt><strong>vector_width</strong><span class="classifier">int, default 5</span></dt><dd><p>Width of displayed vectors.</p>
</dd>
<dt><strong>vector_style</strong><span class="classifier">str, default ‘-|&gt;’</span></dt><dd><p>Vector arrowhead style (from matplotlib’s arrow style).</p>
</dd>
<dt><strong>vector_mutation</strong><span class="classifier">int, default 20</span></dt><dd><p>Width of vectors arrowhead.</p>
</dd>
<dt><strong>view</strong><span class="classifier">list, default [-60, 30]</span></dt><dd><p>Azimuthal and Elevation viewing angles.</p>
</dd>
<dt><strong>xlabel</strong><span class="classifier">list, default [“$x$”, “”]</span></dt><dd><p>List of strings corresponding to +x and -x axes labels, respectively.</p>
</dd>
<dt><strong>xlpos</strong><span class="classifier">list, default [1.1, -1.1]</span></dt><dd><p>Positions of +x and -x labels respectively.</p>
</dd>
<dt><strong>ylabel</strong><span class="classifier">list, default [“$y$”, “”]</span></dt><dd><p>List of strings corresponding to +y and -y axes labels, respectively.</p>
</dd>
<dt><strong>ylpos</strong><span class="classifier">list, default [1.2, -1.2]</span></dt><dd><p>Positions of +y and -y labels respectively.</p>
</dd>
<dt><strong>zlabel</strong><span class="classifier">list, default [‘$\left|0\right&gt;$’, ‘$\left|1\right&gt;$’]</span></dt><dd><p>List of strings corresponding to +z and -z axes labels, respectively.</p>
</dd>
<dt><strong>zlpos</strong><span class="classifier">list, default [1.2, -1.2]</span></dt><dd><p>Positions of +z and -z labels respectively.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.bloch.Bloch.add_annotation">
<span class="sig-name descname"><span class="pre">add_annotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_or_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.add_annotation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_annotation" title="Permalink to this definition"></a></dt>
<dd><p>Add a text or LaTeX annotation to Bloch sphere, parametrized by a qubit
state or a vector.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state_or_vector</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>/array/list/tuple</span></dt><dd><p>Position for the annotaion.
Qobj of a qubit or a vector of 3 elements.</p>
</dd>
<dt><strong>text</strong><span class="classifier">str</span></dt><dd><p>Annotation text.
You can use LaTeX, but remember to use raw string
e.g. r”$langle x rangle$”
or escape backslashes
e.g. “$\langle x \rangle$”.</p>
</dd>
<dt><strong>kwargs</strong></dt><dd><p>Options as for mplot3d.axes3d.text, including:
fontsize, color, horizontalalignment, verticalalignment.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.bloch.Bloch.add_arc">
<span class="sig-name descname"><span class="pre">add_arc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'b'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.add_arc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_arc" title="Permalink to this definition"></a></dt>
<dd><p>Adds an arc between two points on a sphere. The arc is set to be
blue solid curve by default.</p>
<p>The start and end points must be on the same sphere (i.e. have the
same radius) but need not be on the unit sphere.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>start</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> or array-like</span></dt><dd><p>Array with cartesian coordinates of the first point, or a state
vector or density matrix that can be mapped to a point on or
within the Bloch sphere.</p>
</dd>
<dt><strong>end</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> or array-like</span></dt><dd><p>Array with cartesian coordinates of the second point, or a state
vector or density matrix that can be mapped to a point on or
within the Bloch sphere.</p>
</dd>
<dt><strong>fmt</strong><span class="classifier">str, default: “b”</span></dt><dd><p>A matplotlib format string for rendering the arc.</p>
</dd>
<dt><strong>steps</strong><span class="classifier">int, default: None</span></dt><dd><p>The number of segments to use when rendering the arc. The default
uses 100 steps times the distance between the start and end points,
with a minimum of 2 steps.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional parameters to pass to the matplotlib .plot function
when rendering this arc.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.bloch.Bloch.add_line">
<span class="sig-name descname"><span class="pre">add_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.add_line"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_line" title="Permalink to this definition"></a></dt>
<dd><p>Adds a line segment connecting two points on the bloch sphere.</p>
<p>The line segment is set to be a black solid line by default.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>start</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> or array-like</span></dt><dd><p>Array with cartesian coordinates of the first point, or a state
vector or density matrix that can be mapped to a point on or
within the Bloch sphere.</p>
</dd>
<dt><strong>end</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> or array-like</span></dt><dd><p>Array with cartesian coordinates of the second point, or a state
vector or density matrix that can be mapped to a point on or
within the Bloch sphere.</p>
</dd>
<dt><strong>fmt</strong><span class="classifier">str, default: “k”</span></dt><dd><p>A matplotlib format string for rendering the line.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>Additional parameters to pass to the matplotlib .plot function
when rendering this line.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.bloch.Bloch.add_points">
<span class="sig-name descname"><span class="pre">add_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">meth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.add_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_points" title="Permalink to this definition"></a></dt>
<dd><p>Add a list of data points to bloch sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>points</strong><span class="classifier">array_like</span></dt><dd><p>Collection of data points.</p>
</dd>
<dt><strong>meth</strong><span class="classifier">{‘s’, ‘m’, ‘l’}</span></dt><dd><p>Type of points to plot, use ‘m’ for multicolored, ‘l’ for points
connected with a line.</p>
</dd>
<dt><strong>colors</strong><span class="classifier">array_like</span></dt><dd><p>Optional array with colors for the points.
A single color for meth ‘s’, and list of colors for meth ‘m’</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, default=1.</span></dt><dd><p>Transparency value for the vectors. Values between 0 and 1.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">meth=l</span></code> in QuTiP 4.6, the line transparency defaulted
to <code class="docutils literal notranslate"><span class="pre">0.75</span></code> and there was no way to alter it.
When the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> parameter was added in QuTiP 4.7, the default
became <code class="docutils literal notranslate"><span class="pre">alpha=1.0</span></code> for values of <code class="docutils literal notranslate"><span class="pre">meth</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.bloch.Bloch.add_states">
<span class="sig-name descname"><span class="pre">add_states</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'vector'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.add_states"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_states" title="Permalink to this definition"></a></dt>
<dd><p>Add a state vector Qobj to Bloch sphere.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Input state vector.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">{‘vector’, ‘point’}</span></dt><dd><p>Type of object to plot.</p>
</dd>
<dt><strong>colors</strong><span class="classifier">array_like</span></dt><dd><p>Optional array with colors for the states.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, default=1.</span></dt><dd><p>Transparency value for the vectors. Values between 0 and 1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.bloch.Bloch.add_vectors">
<span class="sig-name descname"><span class="pre">add_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.add_vectors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_vectors" title="Permalink to this definition"></a></dt>
<dd><p>Add a list of vectors to Bloch sphere.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vectors</strong><span class="classifier">array_like</span></dt><dd><p>Array with vectors of unit length or smaller.</p>
</dd>
<dt><strong>colors</strong><span class="classifier">array_like</span></dt><dd><p>Optional array with colors for the vectors.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, default=1.</span></dt><dd><p>Transparency value for the vectors. Values between 0 and 1.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.bloch.Bloch.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.clear" title="Permalink to this definition"></a></dt>
<dd><p>Resets Bloch sphere data sets to empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.bloch.Bloch.make_sphere">
<span class="sig-name descname"><span class="pre">make_sphere</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.make_sphere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.make_sphere" title="Permalink to this definition"></a></dt>
<dd><p>Plots Bloch sphere and data sets.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.bloch.Bloch.render">
<span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.render"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.render" title="Permalink to this definition"></a></dt>
<dd><p>Render the Bloch sphere and its data sets in on given figure and axes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.bloch.Bloch.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'png'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dirc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dpin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.save"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.save" title="Permalink to this definition"></a></dt>
<dd><p>Saves Bloch sphere to file of type <code class="docutils literal notranslate"><span class="pre">format</span></code> in directory <code class="docutils literal notranslate"><span class="pre">dirc</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of saved image. Must include path and format as well.
i.e. ‘/Users/Me/Desktop/bloch.png’
This overrides the ‘format’ and ‘dirc’ arguments.</p>
</dd>
<dt><strong>format</strong><span class="classifier">str</span></dt><dd><p>Format of output image.</p>
</dd>
<dt><strong>dirc</strong><span class="classifier">str</span></dt><dd><p>Directory for output images. Defaults to current working directory.</p>
</dd>
<dt><strong>dpin</strong><span class="classifier">int</span></dt><dd><p>Resolution in dots per inch.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>File containing plot of Bloch sphere.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.bloch.Bloch.set_label_convention">
<span class="sig-name descname"><span class="pre">set_label_convention</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">convention</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.set_label_convention"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.set_label_convention" title="Permalink to this definition"></a></dt>
<dd><p>Set x, y and z labels according to one of conventions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>convention</strong><span class="classifier">string</span></dt><dd><p>One of the following:</p>
<ul class="simple">
<li><p>“original”</p></li>
<li><p>“xyz”</p></li>
<li><p>“sx sy sz”</p></li>
<li><p>“01”</p></li>
<li><p>“polarization jones”</p></li>
<li><p>“polarization jones letters”
see also: <a class="reference external" href="https://en.wikipedia.org/wiki/Jones_calculus">https://en.wikipedia.org/wiki/Jones_calculus</a></p></li>
<li><p>“polarization stokes”
see also: <a class="reference external" href="https://en.wikipedia.org/wiki/Stokes_parameters">https://en.wikipedia.org/wiki/Stokes_parameters</a></p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.bloch.Bloch.show">
<span class="sig-name descname"><span class="pre">show</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/bloch.html#Bloch.show"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.bloch.Bloch.show" title="Permalink to this definition"></a></dt>
<dd><p>Display Bloch sphere and corresponding data sets.</p>
<p class="rubric">Notes</p>
<p>When using inline plotting in Jupyter notebooks, any figure created
in a notebook cell is displayed after the cell executes. Thus if you
create a figure yourself and use it create a Bloch sphere with
<code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">Bloch(...,</span> <span class="pre">fig=fig)</span></code> and then call <code class="docutils literal notranslate"><span class="pre">b.show()</span></code> in the same
cell, then the figure will be displayed twice. If you do create your
own figure, the simplest solution to this is to not call <code class="docutils literal notranslate"><span class="pre">.show()</span></code>
in the cell you create the figure in.</p>
</dd></dl>

</dd></dl>

</section>
<section id="distributions">
<h2>Distributions<a class="headerlink" href="#distributions" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.QFunc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">QFunc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yvec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.4142135623730951</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1024</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/wigner.html#QFunc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.QFunc" title="Permalink to this definition"></a></dt>
<dd><p>Class-based method of calculating the Husimi-Q function of many different
quantum states at fixed phase-space points <code class="docutils literal notranslate"><span class="pre">0.5*g*</span> <span class="pre">(xvec</span> <span class="pre">+</span> <span class="pre">i*yvec)</span></code>.
This class has slightly higher first-usage costs than <a class="reference internal" href="functions.html#qutip.wigner.qfunc" title="qutip.wigner.qfunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qfunc</span></code></a>, but
subsequent operations will be several times faster. However, it can require
quite a lot of memory. Call the created object as a function to retrieve
the Husimi-Q function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xvec, yvec</strong><span class="classifier">array_like</span></dt><dd><p>x- and y-coordinates at which to calculate the Husimi-Q function.</p>
</dd>
<dt><strong>g</strong><span class="classifier">float, default: sqrt(2)</span></dt><dd><p>Scaling factor for <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">0.5</span> <span class="pre">*</span> <span class="pre">g</span> <span class="pre">*</span> <span class="pre">(x</span> <span class="pre">+</span> <span class="pre">iy)</span></code>.  The value of <cite>g</cite> is
related to the value of <cite>hbar</cite> in the commutation relation
<span class="math notranslate nohighlight">\([x,\,y] = i\hbar\)</span> via <span class="math notranslate nohighlight">\(\hbar=2/g^2\)</span>, so the default
corresponds to <span class="math notranslate nohighlight">\(\hbar=1\)</span>.</p>
</dd>
<dt><strong>memory</strong><span class="classifier">real, default: 1024</span></dt><dd><p>Size in MB that may be used internally as workspace.  This class will
raise <code class="docutils literal notranslate"><span class="pre">MemoryError</span></code> if subsequently passed a state of sufficiently
large dimension that this bound would be exceeded.  In those cases, use
<a class="reference internal" href="functions.html#qutip.wigner.qfunc" title="qutip.wigner.qfunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qfunc</span></code></a> with <code class="docutils literal notranslate"><span class="pre">precompute_memory=None</span></code> instead to force using
the slower, more memory-efficient algorithm.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="functions.html#qutip.wigner.qfunc" title="qutip.wigner.qfunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">qfunc</span></code></a></dt><dd><p>A single function version, which will involve computing several quantities multiple times in order to use less memory.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Initialise the class for a square set of coordinates, with some states we
want to investigate.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">qutip</span><span class="o">.</span><span class="n">rand_dm</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qfunc</span> <span class="o">=</span> <span class="n">qutip</span><span class="o">.</span><span class="n">QFunc</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span> <span class="n">xvec</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we can calculate the Husimi-Q function over each of the states more
efficiently with:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">husimiq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">qfunc</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="solvers">
<span id="classes-solver"></span><h2>Solvers<a class="headerlink" href="#solvers" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.sesolve.SESolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SESolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/sesolve.html#SESolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.sesolve.SESolver" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></p>
<p>Schrodinger equation evolution of a state vector or unitary matrix
for a given Hamiltonian.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a></span></dt><dd><p>System Hamiltonian as a Qobj or QobjEvo for time-dependent
Hamiltonians. List of [<a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable
that can be made into <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> are also accepted.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver, see <a class="reference internal" href="#qutip.solver.sesolve.SESolver.options" title="qutip.solver.sesolve.SESolver.options"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SESolver.options</span></code></a> and
<a class="reference external" href="./classes.html#classes-ode">Integrator</a> for a list of all options.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stats: dict</strong></dt><dd><p>Diverse diagnostic statistics of the evolution.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.sesolve.SESolver.ExpectFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ExpectFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.sesolve.SESolver.ExpectFeedback" title="Permalink to this definition"></a></dt>
<dd><p>Expectation value of the instantaneous state of the evolution to be
used by a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;E0&quot;:</span> <span class="pre">Solver.ExpectFeedback(oper)})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive <code class="docutils literal notranslate"><span class="pre">expect(oper,</span> <span class="pre">state)</span></code> as <code class="docutils literal notranslate"><span class="pre">E0</span></code> during the
evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>operator</strong><span class="classifier">Qobj, QobjEvo</span></dt><dd><p>Operator to compute the expectation values of.</p>
</dd>
<dt><strong>default</strong><span class="classifier">float, default</span><span class="classifier">0.</span></dt><dd><p>Initial value to be used at setup.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.sesolve.SESolver.StateFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">StateFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raw_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/sesolve.html#SESolver.StateFeedback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.sesolve.SESolver.StateFeedback" title="Permalink to this definition"></a></dt>
<dd><p>State of the evolution to be used in a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;state&quot;:</span> <span class="pre">SESolver.StateFeedback()})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive the ket as <code class="docutils literal notranslate"><span class="pre">state</span></code> during the evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default</strong><span class="classifier">Qobj or qutip.core.data.Data, default</span><span class="classifier">None</span></dt><dd><p>Initial value to be used at setup of the system.</p>
</dd>
<dt><strong>prop</strong><span class="classifier">bool, default</span><span class="classifier">False</span></dt><dd><p>Set to True when using sesolve for computing propagators.</p>
</dd>
<dt><strong>raw_data</strong><span class="classifier">bool, default</span><span class="classifier">False</span></dt><dd><p>If True, the raw matrix will be passed instead of a Qobj.
For density matrices, the matrices can be column stacked or square
depending on the integration method.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.sesolve.SESolver.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.sesolve.SESolver.options" title="Permalink to this definition"></a></dt>
<dd><p>Solver’s options:</p>
<dl class="simple">
<dt>store_final_state: bool, default: False</dt><dd><p>Whether or not to store the final state of the evolution in the
result class.</p>
</dd>
<dt>store_states: bool, default: None</dt><dd><p>Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p>
</dd>
<dt>normalize_output: bool, default: True</dt><dd><p>Normalize output state to hide ODE numerical errors.</p>
</dd>
<dt>progress_bar: str {“text”, “enhanced”, “tqdm”, “”}, default: “”</dt><dd><p>How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p>
</dd>
<dt>progress_kwargs: dict, default: {“chunk_size”: 10}</dt><dd><p>Arguments to pass to the progress_bar. Qutip’s bars use
<code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>.</p>
</dd>
<dt>method: str, default: “adams”</dt><dd><p>Which ordinary differential equation integration method to use.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.sesolve.SESolver.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.sesolve.SESolver.run" title="Permalink to this definition"></a></dt>
<dd><p>Do the evolution of the Quantum system.</p>
<p>For a <code class="docutils literal notranslate"><span class="pre">state0</span></code> at time <code class="docutils literal notranslate"><span class="pre">tlist[0]</span></code> do the evolution as directed by
<code class="docutils literal notranslate"><span class="pre">rhs</span></code> and for each time in <code class="docutils literal notranslate"><span class="pre">tlist</span></code> store the state and/or
expectation values in a <a class="reference internal" href="#qutip.solver.result.Result" title="qutip.solver.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>. The evolution method and
stored results are determined by <code class="docutils literal notranslate"><span class="pre">options</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list of double</span></dt><dd><p>Time for which to save the results (state and/or expect) of the
evolution. The first element of the list is the initial time of the
evolution. Each times of the list must be increasing, but does not
need to be uniformy distributed.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Change the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the rhs for the evolution.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list {None}</span></dt><dd><p>List of Qobj, QobjEvo or callable to compute the expectation
values. Function[s] must have the signature
f(t : float, state : Qobj) -&gt; expect.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.result.Result" title="qutip.solver.result.Result"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Result</span></code></a></span></dt><dd><p>Results of the evolution. States and/or expect will be saved. You
can control the saved data in the options.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.sesolve.SESolver.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.sesolve.SESolver.start" title="Permalink to this definition"></a></dt>
<dd><p>Set the initial state and time for a step evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>t0</strong><span class="classifier">double</span></dt><dd><p>Initial time of the evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.sesolve.SESolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.sesolve.SESolver.step" title="Permalink to this definition"></a></dt>
<dd><p>Evolve the state to <code class="docutils literal notranslate"><span class="pre">t</span></code> and return the state as a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">double</span></dt><dd><p>Time to evolve to, must be higher than the last call.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Update the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the system.
The change is effective from the beginning of the interval.
Changing <code class="docutils literal notranslate"><span class="pre">args</span></code> can slow the evolution.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional {True}</span></dt><dd><p>Whether to return a copy of the data or the data in the ODE solver.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The state must be initialized first by calling <a class="reference internal" href="#qutip.solver.sesolve.SESolver.start" title="qutip.solver.sesolve.SESolver.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start</span></code></a> or
<a class="reference internal" href="#qutip.solver.sesolve.SESolver.run" title="qutip.solver.sesolve.SESolver.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run</span></code></a>. If <a class="reference internal" href="#qutip.solver.sesolve.SESolver.run" title="qutip.solver.sesolve.SESolver.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run</span></code></a> is called, <a class="reference internal" href="#qutip.solver.sesolve.SESolver.step" title="qutip.solver.sesolve.SESolver.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step</span></code></a> will continue from
the last time and state obtained.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.sesolve.SESolver.sys_dims">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sys_dims</span></span><a class="headerlink" href="#qutip.solver.sesolve.SESolver.sys_dims" title="Permalink to this definition"></a></dt>
<dd><p>Dimensions of the space that the system use:</p>
<p><code class="docutils literal notranslate"><span class="pre">qutip.basis(sovler.dims)</span></code> will create a state with proper dimensions
for this solver.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.mesolve.MESolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MESolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/mesolve.html#MESolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.mesolve.MESolver" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#qutip.solver.sesolve.SESolver" title="qutip.solver.sesolve.SESolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">SESolver</span></code></a></p>
<p>Master equation evolution of a density matrix for a given Hamiltonian and
set of collapse operators, or a Liouvillian.</p>
<p>Evolve the density matrix (<cite>rho0</cite>) using a given
Hamiltonian or Liouvillian (<cite>H</cite>) and an optional set of collapse operators
(<cite>c_ops</cite>), by integrating the set of ordinary differential equations
that define the system.</p>
<p>If either <cite>H</cite> or the Qobj elements in <cite>c_ops</cite> are superoperators, they
will be treated as direct contributions to the total system Liouvillian.
This allows the solution of master equations that are not in standard
Lindblad form.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a></span></dt><dd><p>Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or
QobjEvo. List of [<a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable that
can be made into <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> are also accepted.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a></span></dt><dd><p>Single collapse operator, or list of collapse operators, or a list
of Liouvillian superoperators. None is equivalent to an empty list.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver, see <a class="reference internal" href="#qutip.solver.mesolve.MESolver.options" title="qutip.solver.mesolve.MESolver.options"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MESolver.options</span></code></a> and
<a class="reference external" href="./classes.html#classes-ode">Integrator</a> for a list of all options.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stats: dict</strong></dt><dd><p>Diverse diagnostic statistics of the evolution.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.mesolve.MESolver.ExpectFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ExpectFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.mesolve.MESolver.ExpectFeedback" title="Permalink to this definition"></a></dt>
<dd><p>Expectation value of the instantaneous state of the evolution to be
used by a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;E0&quot;:</span> <span class="pre">Solver.ExpectFeedback(oper)})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive <code class="docutils literal notranslate"><span class="pre">expect(oper,</span> <span class="pre">state)</span></code> as <code class="docutils literal notranslate"><span class="pre">E0</span></code> during the
evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>operator</strong><span class="classifier">Qobj, QobjEvo</span></dt><dd><p>Operator to compute the expectation values of.</p>
</dd>
<dt><strong>default</strong><span class="classifier">float, default</span><span class="classifier">0.</span></dt><dd><p>Initial value to be used at setup.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.mesolve.MESolver.StateFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">StateFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raw_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/mesolve.html#MESolver.StateFeedback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.mesolve.MESolver.StateFeedback" title="Permalink to this definition"></a></dt>
<dd><p>State of the evolution to be used in a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;state&quot;:</span> <span class="pre">MESolver.StateFeedback()})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive the density matrix as <code class="docutils literal notranslate"><span class="pre">state</span></code> during the
evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default</strong><span class="classifier">Qobj or qutip.core.data.Data, default</span><span class="classifier">None</span></dt><dd><p>Initial value to be used at setup of the system.</p>
</dd>
<dt><strong>prop</strong><span class="classifier">bool, default</span><span class="classifier">False</span></dt><dd><p>Set to True when computing propagators.
The default with take the shape of the propagator instead of a
state.</p>
</dd>
<dt><strong>raw_data</strong><span class="classifier">bool, default</span><span class="classifier">False</span></dt><dd><p>If True, the raw matrix will be passed instead of a Qobj.
For density matrices, the matrices can be column stacked or square
depending on the integration method.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.mesolve.MESolver.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.mesolve.MESolver.options" title="Permalink to this definition"></a></dt>
<dd><p>Solver’s options:</p>
<dl class="simple">
<dt>store_final_state: bool, default: False</dt><dd><p>Whether or not to store the final state of the evolution in the
result class.</p>
</dd>
<dt>store_states: bool, default: None</dt><dd><p>Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p>
</dd>
<dt>normalize_output: bool, default: True</dt><dd><p>Normalize output state to hide ODE numerical errors.</p>
</dd>
<dt>progress_bar: str {“text”, “enhanced”, “tqdm”, “”}, default: “”</dt><dd><p>How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p>
</dd>
<dt>progress_kwargs: dict, default: {“chunk_size”: 10}</dt><dd><p>Arguments to pass to the progress_bar. Qutip’s bars use
<code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>.</p>
</dd>
<dt>method: str, default: “adams”</dt><dd><p>Which ordinary differential equation integration method to use.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.mesolve.MESolver.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.mesolve.MESolver.run" title="Permalink to this definition"></a></dt>
<dd><p>Do the evolution of the Quantum system.</p>
<p>For a <code class="docutils literal notranslate"><span class="pre">state0</span></code> at time <code class="docutils literal notranslate"><span class="pre">tlist[0]</span></code> do the evolution as directed by
<code class="docutils literal notranslate"><span class="pre">rhs</span></code> and for each time in <code class="docutils literal notranslate"><span class="pre">tlist</span></code> store the state and/or
expectation values in a <a class="reference internal" href="#qutip.solver.result.Result" title="qutip.solver.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>. The evolution method and
stored results are determined by <code class="docutils literal notranslate"><span class="pre">options</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list of double</span></dt><dd><p>Time for which to save the results (state and/or expect) of the
evolution. The first element of the list is the initial time of the
evolution. Each times of the list must be increasing, but does not
need to be uniformy distributed.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Change the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the rhs for the evolution.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list {None}</span></dt><dd><p>List of Qobj, QobjEvo or callable to compute the expectation
values. Function[s] must have the signature
f(t : float, state : Qobj) -&gt; expect.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.result.Result" title="qutip.solver.result.Result"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Result</span></code></a></span></dt><dd><p>Results of the evolution. States and/or expect will be saved. You
can control the saved data in the options.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.mesolve.MESolver.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.mesolve.MESolver.start" title="Permalink to this definition"></a></dt>
<dd><p>Set the initial state and time for a step evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>t0</strong><span class="classifier">double</span></dt><dd><p>Initial time of the evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.mesolve.MESolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.mesolve.MESolver.step" title="Permalink to this definition"></a></dt>
<dd><p>Evolve the state to <code class="docutils literal notranslate"><span class="pre">t</span></code> and return the state as a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">double</span></dt><dd><p>Time to evolve to, must be higher than the last call.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Update the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the system.
The change is effective from the beginning of the interval.
Changing <code class="docutils literal notranslate"><span class="pre">args</span></code> can slow the evolution.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional {True}</span></dt><dd><p>Whether to return a copy of the data or the data in the ODE solver.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The state must be initialized first by calling <a class="reference internal" href="#qutip.solver.mesolve.MESolver.start" title="qutip.solver.mesolve.MESolver.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start</span></code></a> or
<a class="reference internal" href="#qutip.solver.mesolve.MESolver.run" title="qutip.solver.mesolve.MESolver.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run</span></code></a>. If <a class="reference internal" href="#qutip.solver.mesolve.MESolver.run" title="qutip.solver.mesolve.MESolver.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run</span></code></a> is called, <a class="reference internal" href="#qutip.solver.mesolve.MESolver.step" title="qutip.solver.mesolve.MESolver.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step</span></code></a> will continue from
the last time and state obtained.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.mesolve.MESolver.sys_dims">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sys_dims</span></span><a class="headerlink" href="#qutip.solver.mesolve.MESolver.sys_dims" title="Permalink to this definition"></a></dt>
<dd><p>Dimensions of the space that the system use:</p>
<p><code class="docutils literal notranslate"><span class="pre">qutip.basis(sovler.dims)</span></code> will create a state with proper dimensions
for this solver.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.brmesolve.BRSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BRSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sec_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/brmesolve.html#BRSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.brmesolve.BRSolver" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></p>
<p>Bloch Redfield equation evolution of a density matrix for a given
Hamiltonian and set of bath coupling operators.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a></span></dt><dd><p>Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or
QobjEvo. list of [<a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable that
can be made into <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> are also accepted.</p>
</dd>
<dt><strong>a_ops</strong><span class="classifier">list of (a_op, spectra)</span></dt><dd><p>Nested list of system operators that couple to the environment,
and the corresponding bath spectra.</p>
<dl>
<dt>a_op<span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a></span></dt><dd><p>The operator coupling to the environment. Must be hermitian.</p>
</dd>
<dt>spectra<span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code></span></dt><dd><p>The corresponding bath spectra. As a <cite>Coefficient</cite> using an ‘w’
args. Can depend on <code class="docutils literal notranslate"><span class="pre">t</span></code> only if a_op is a <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>.
<code class="xref py py-obj docutils literal notranslate"><span class="pre">SpectraCoefficient</span></code> can be used to conver a coefficient
depending on <code class="docutils literal notranslate"><span class="pre">t</span></code> to one depending on <code class="docutils literal notranslate"><span class="pre">w</span></code>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_ops</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span> <span class="n">coefficient</span><span class="p">(</span><span class="s1">&#39;w&gt;0&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;w&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">})),</span>
    <span class="p">(</span><span class="n">QobjEvo</span><span class="p">([</span><span class="n">b</span><span class="o">+</span><span class="n">b</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="o">...</span><span class="p">]),</span>
     <span class="n">coefficient</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="o">...</span><span class="p">),</span> <span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;w&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}),</span>
    <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">c</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span> <span class="n">SpectraCoefficient</span><span class="p">(</span><span class="n">coefficient</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">tlist</span><span class="o">=</span><span class="n">ws</span><span class="p">))),</span>
<span class="p">]</span>
</pre></div>
</div>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a></span></dt><dd><p>Single collapse operator, or list of collapse operators, or a list
of Lindblad dissipator. None is equivalent to an empty list.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver, see <a class="reference internal" href="#qutip.solver.brmesolve.BRSolver.options" title="qutip.solver.brmesolve.BRSolver.options"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BRSolver.options</span></code></a> and
<a class="reference external" href="./classes.html#classes-ode">Integrator</a> for a list of all options.</p>
</dd>
<dt><strong>sec_cutoff</strong><span class="classifier">float {0.1}</span></dt><dd><p>Cutoff for secular approximation. Use <code class="docutils literal notranslate"><span class="pre">-1</span></code> if secular approximation
is not used when evaluating bath-coupling terms.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>stats: dict</strong></dt><dd><p>Diverse diagnostic statistics of the evolution.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.brmesolve.BRSolver.ExpectFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ExpectFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.brmesolve.BRSolver.ExpectFeedback" title="Permalink to this definition"></a></dt>
<dd><p>Expectation value of the instantaneous state of the evolution to be
used by a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;E0&quot;:</span> <span class="pre">Solver.ExpectFeedback(oper)})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive <code class="docutils literal notranslate"><span class="pre">expect(oper,</span> <span class="pre">state)</span></code> as <code class="docutils literal notranslate"><span class="pre">E0</span></code> during the
evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>operator</strong><span class="classifier">Qobj, QobjEvo</span></dt><dd><p>Operator to compute the expectation values of.</p>
</dd>
<dt><strong>default</strong><span class="classifier">float, default</span><span class="classifier">0.</span></dt><dd><p>Initial value to be used at setup.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.brmesolve.BRSolver.StateFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">StateFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raw_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/brmesolve.html#BRSolver.StateFeedback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.brmesolve.BRSolver.StateFeedback" title="Permalink to this definition"></a></dt>
<dd><p>State of the evolution to be used in a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;state&quot;:</span> <span class="pre">BRMESolver.StateFeedback()})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive the density matrix as <code class="docutils literal notranslate"><span class="pre">state</span></code> during the
evolution.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The state will not be in the lab basis, but in the evolution basis.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default</strong><span class="classifier">Qobj or qutip.core.data.Data, default</span><span class="classifier">None</span></dt><dd><p>Initial value to be used at setup of the system.</p>
</dd>
<dt><strong>raw_data</strong><span class="classifier">bool, default</span><span class="classifier">False</span></dt><dd><p>If True, the raw matrix will be passed instead of a Qobj.
For density matrices, the matrices can be column stacked or square
depending on the integration method.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.brmesolve.BRSolver.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.brmesolve.BRSolver.options" title="Permalink to this definition"></a></dt>
<dd><p>Options for bloch redfield solver:</p>
<dl class="simple">
<dt>store_final_state: bool, default: False</dt><dd><p>Whether or not to store the final state of the evolution in the
result class.</p>
</dd>
<dt>store_states: bool, default: None</dt><dd><p>Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p>
</dd>
<dt>normalize_output: bool, default: False</dt><dd><p>Normalize output state to hide ODE numerical errors.</p>
</dd>
<dt>progress_bar: str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}, default: “”</dt><dd><p>How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error if
not installed. Empty string or False will disable the bar.</p>
</dd>
<dt>progress_kwargs: dict, default: {“chunk_size”:10}</dt><dd><p>Arguments to pass to the progress_bar. Qutip’s bars use
<code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>.</p>
</dd>
<dt>tensor_type: str [‘sparse’, ‘dense’, ‘data’], default: “sparse”</dt><dd><p>Which data type to use when computing the brtensor.
With a cutoff ‘sparse’ is usually the most efficient.</p>
</dd>
<dt>sparse_eigensolver: bool, default: False</dt><dd><p>Whether to use the sparse eigensolver</p>
</dd>
<dt>method: str, default: “adams”</dt><dd><p>Which ODE integrator methods are supported.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.brmesolve.BRSolver.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.brmesolve.BRSolver.run" title="Permalink to this definition"></a></dt>
<dd><p>Do the evolution of the Quantum system.</p>
<p>For a <code class="docutils literal notranslate"><span class="pre">state0</span></code> at time <code class="docutils literal notranslate"><span class="pre">tlist[0]</span></code> do the evolution as directed by
<code class="docutils literal notranslate"><span class="pre">rhs</span></code> and for each time in <code class="docutils literal notranslate"><span class="pre">tlist</span></code> store the state and/or
expectation values in a <a class="reference internal" href="#qutip.solver.result.Result" title="qutip.solver.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>. The evolution method and
stored results are determined by <code class="docutils literal notranslate"><span class="pre">options</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list of double</span></dt><dd><p>Time for which to save the results (state and/or expect) of the
evolution. The first element of the list is the initial time of the
evolution. Each times of the list must be increasing, but does not
need to be uniformy distributed.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Change the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the rhs for the evolution.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list {None}</span></dt><dd><p>List of Qobj, QobjEvo or callable to compute the expectation
values. Function[s] must have the signature
f(t : float, state : Qobj) -&gt; expect.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.result.Result" title="qutip.solver.result.Result"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Result</span></code></a></span></dt><dd><p>Results of the evolution. States and/or expect will be saved. You
can control the saved data in the options.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.brmesolve.BRSolver.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.brmesolve.BRSolver.start" title="Permalink to this definition"></a></dt>
<dd><p>Set the initial state and time for a step evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>t0</strong><span class="classifier">double</span></dt><dd><p>Initial time of the evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.brmesolve.BRSolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.brmesolve.BRSolver.step" title="Permalink to this definition"></a></dt>
<dd><p>Evolve the state to <code class="docutils literal notranslate"><span class="pre">t</span></code> and return the state as a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">double</span></dt><dd><p>Time to evolve to, must be higher than the last call.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Update the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the system.
The change is effective from the beginning of the interval.
Changing <code class="docutils literal notranslate"><span class="pre">args</span></code> can slow the evolution.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional {True}</span></dt><dd><p>Whether to return a copy of the data or the data in the ODE solver.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The state must be initialized first by calling <a class="reference internal" href="#qutip.solver.brmesolve.BRSolver.start" title="qutip.solver.brmesolve.BRSolver.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start</span></code></a> or
<a class="reference internal" href="#qutip.solver.brmesolve.BRSolver.run" title="qutip.solver.brmesolve.BRSolver.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run</span></code></a>. If <a class="reference internal" href="#qutip.solver.brmesolve.BRSolver.run" title="qutip.solver.brmesolve.BRSolver.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run</span></code></a> is called, <a class="reference internal" href="#qutip.solver.brmesolve.BRSolver.step" title="qutip.solver.brmesolve.BRSolver.step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">step</span></code></a> will continue from
the last time and state obtained.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.brmesolve.BRSolver.sys_dims">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sys_dims</span></span><a class="headerlink" href="#qutip.solver.brmesolve.BRSolver.sys_dims" title="Permalink to this definition"></a></dt>
<dd><p>Dimensions of the space that the system use:</p>
<p><code class="docutils literal notranslate"><span class="pre">qutip.basis(sovler.dims)</span></code> will create a state with proper dimensions
for this solver.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FMESolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">floquet_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_th</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nT</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FMESolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FMESolver" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#qutip.solver.mesolve.MESolver" title="qutip.solver.mesolve.MESolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">MESolver</span></code></a></p>
<p>Solver for the Floquet-Markov master equation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Operators (<code class="docutils literal notranslate"><span class="pre">c_ops</span></code> and <code class="docutils literal notranslate"><span class="pre">e_ops</span></code>) are in the laboratory basis.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>floquet_basis</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.floquet.FloquetBasis" title="qutip.solver.floquet.FloquetBasis"><code class="xref py py-class docutils literal notranslate"><span class="pre">FloquetBasis</span></code></a></span></dt><dd><p>The system Hamiltonian wrapped in a FloquetBasis object. Choosing a
different integrator for the <code class="docutils literal notranslate"><span class="pre">floquet_basis</span></code> than for the evolution
of the floquet state can improve the performance.</p>
</dd>
<dt><strong>a_ops</strong><span class="classifier">list of tuple(<a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>, callable)</span></dt><dd><p>List of collapse operators and the corresponding function for the noise
power spectrum. The collapse operator must be a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> and
cannot be time dependent. The spectrum function must take and return
an numpy array.</p>
</dd>
<dt><strong>w_th</strong><span class="classifier">float</span></dt><dd><p>The temperature of the environment in units of Hamiltonian frequency.</p>
</dd>
<dt><strong>kmax</strong><span class="classifier">int [5]</span></dt><dd><p>The truncation of the number of sidebands..</p>
</dd>
<dt><strong>nT</strong><span class="classifier">int [20*kmax]</span></dt><dd><p>The number of integration steps (for calculating X) within one period.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver, see <a class="reference internal" href="#qutip.solver.floquet.FMESolver.options" title="qutip.solver.floquet.FMESolver.options"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FMESolver.options</span></code></a> and
<a class="reference external" href="./classes.html#classes-ode">Integrator</a> for a list of all options.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver.ExpectFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ExpectFeedback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FMESolver.ExpectFeedback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FMESolver.ExpectFeedback" title="Permalink to this definition"></a></dt>
<dd><p>Expect of the state of the evolution to be used in a time-dependent
operator.</p>
<p>Not not implemented for FMESolver</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver.StateFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">StateFeedback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FMESolver.StateFeedback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FMESolver.StateFeedback" title="Permalink to this definition"></a></dt>
<dd><p>State of the evolution to be used in a time-dependent operator.</p>
<p>Not not implemented for FMESolver</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.floquet.FMESolver.options" title="Permalink to this definition"></a></dt>
<dd><p>Solver’s options:</p>
<dl class="simple">
<dt>store_final_state: bool, default: False</dt><dd><p>Whether or not to store the final state of the evolution in the
result class.</p>
</dd>
<dt>store_states: bool, default: None</dt><dd><p>Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p>
</dd>
<dt>normalize_output: bool, default: True</dt><dd><p>Normalize output state to hide ODE numerical errors.</p>
</dd>
<dt>progress_bar: str {“text”, “enhanced”, “tqdm”, “”}, default: “”</dt><dd><p>How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p>
</dd>
<dt>progress_kwargs: dict, default: {“chunk_size”: 10}</dt><dd><p>Arguments to pass to the progress_bar. Qutip’s bars use
<code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>.</p>
</dd>
<dt>method: str, default: “adams”</dt><dd><p>Which ordinary differential equation integration method to use.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">floquet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FMESolver.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FMESolver.run" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the evolution of the quantum system.</p>
<p>For a <code class="docutils literal notranslate"><span class="pre">state0</span></code> at time <code class="docutils literal notranslate"><span class="pre">tlist[0]</span></code> do the evolution as directed by
<code class="docutils literal notranslate"><span class="pre">rhs</span></code> and for each time in <code class="docutils literal notranslate"><span class="pre">tlist</span></code> store the state and/or
expectation values in a <a class="reference internal" href="#qutip.solver.result.Result" title="qutip.solver.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>. The evolution method and
stored results are determined by <code class="docutils literal notranslate"><span class="pre">options</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list of double</span></dt><dd><p>Time for which to save the results (state and/or expect) of the
evolution. The first element of the list is the initial time of the
evolution. Each times of the list must be increasing, but does not
need to be uniformy distributed.</p>
</dd>
<dt><strong>floquet</strong><span class="classifier">bool, optional {False}</span></dt><dd><p>Whether the initial state in the floquet basis or laboratory basis.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Not supported</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list {None}</span></dt><dd><p>List of Qobj, QobjEvo or callable to compute the expectation
values. Function[s] must have the signature
f(t : float, state : Qobj) -&gt; expect.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">FloquetResult</span></code></span></dt><dd><p>Results of the evolution. States and/or expect will be saved. You
can control the saved data in the options.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">floquet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FMESolver.start"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FMESolver.start" title="Permalink to this definition"></a></dt>
<dd><p>Set the initial state and time for a step evolution.
<code class="docutils literal notranslate"><span class="pre">options</span></code> for the evolutions are read at this step.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>t0</strong><span class="classifier">double</span></dt><dd><p>Initial time of the evolution.</p>
</dd>
<dt><strong>floquet</strong><span class="classifier">bool, optional {False}</span></dt><dd><p>Whether the initial state is in the floquet basis or laboratory
basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">floquet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FMESolver.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FMESolver.step" title="Permalink to this definition"></a></dt>
<dd><p>Evolve the state to <code class="docutils literal notranslate"><span class="pre">t</span></code> and return the state as a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">double</span></dt><dd><p>Time to evolve to, must be higher than the last call.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional {True}</span></dt><dd><p>Whether to return a copy of the data or the data in the ODE solver.</p>
</dd>
<dt><strong>floquet</strong><span class="classifier">bool, optional {False}</span></dt><dd><p>Whether to return the state in the floquet basis or laboratory
basis.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Not supported</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The state must be initialized first by calling <code class="docutils literal notranslate"><span class="pre">start</span></code> or
<code class="docutils literal notranslate"><span class="pre">run</span></code>. If <code class="docutils literal notranslate"><span class="pre">run</span></code> is called, <code class="docutils literal notranslate"><span class="pre">step</span></code> will continue from the last
time and state obtained.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.floquet.FMESolver.sys_dims">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sys_dims</span></span><a class="headerlink" href="#qutip.solver.floquet.FMESolver.sys_dims" title="Permalink to this definition"></a></dt>
<dd><p>Dimensions of the space that the system use:</p>
<p><code class="docutils literal notranslate"><span class="pre">qutip.basis(sovler.dims)</span></code> will create a state with proper dimensions
for this solver.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.floquet.FloquetBasis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FloquetBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sparse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precompute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FloquetBasis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FloquetBasis" title="Permalink to this definition"></a></dt>
<dd><p>Utility to compute floquet modes and states.</p>
<dl class="field-list">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>U</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.propagator.Propagator" title="qutip.solver.propagator.Propagator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Propagator</span></code></a></span></dt><dd><p>The propagator of the Hamiltonian over one period.</p>
</dd>
<dt><strong>evecs</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">Data</span></code></span></dt><dd><p>Matrix where each column is an initial Floquet mode.</p>
</dd>
<dt><strong>e_quasi</strong><span class="classifier">np.ndarray[float]</span></dt><dd><p>The quasi energies of the Hamiltonian.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FloquetBasis.from_floquet_basis">
<span class="sig-name descname"><span class="pre">from_floquet_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">floquet_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FloquetBasis.from_floquet_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FloquetBasis.from_floquet_basis" title="Permalink to this definition"></a></dt>
<dd><p>Transform a ket or density matrix from the Floquet basis at time <code class="docutils literal notranslate"><span class="pre">t</span></code>
to the lab basis.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>floquet_basis</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Data</span></code></span></dt><dd><p>Initial state in the Floquet basis at time <code class="docutils literal notranslate"><span class="pre">t</span></code>. May be either a
ket or density matrix.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float [0]</span></dt><dd><p>The time at which to evaluate the Floquet states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Data</span></code></span></dt><dd><p>The state in the lab basis. The return type is the same as the type
of the input state.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FloquetBasis.mode">
<span class="sig-name descname"><span class="pre">mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FloquetBasis.mode"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FloquetBasis.mode" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the Floquet modes at time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet mode.</p>
</dd>
<dt><strong>data</strong><span class="classifier">bool [False]</span></dt><dd><p>Whether to return the states as a single data matrix or a list of
ket states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier">list[<a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Data</span></code></span></dt><dd><p>A list of Floquet states for the time <code class="docutils literal notranslate"><span class="pre">t</span></code> or the states as column
in a single matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FloquetBasis.state">
<span class="sig-name descname"><span class="pre">state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FloquetBasis.state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FloquetBasis.state" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the floquet states at time t.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time for which to evaluate the Floquet states.</p>
</dd>
<dt><strong>data</strong><span class="classifier">bool [False]</span></dt><dd><p>Whether to return the states as a single data matrix or a list of
ket states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier">list[<a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>], <code class="xref py py-class docutils literal notranslate"><span class="pre">Data</span></code></span></dt><dd><p>A list of Floquet states for the time <code class="docutils literal notranslate"><span class="pre">t</span></code> or the states as column
in a single matrix.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.floquet.FloquetBasis.to_floquet_basis">
<span class="sig-name descname"><span class="pre">to_floquet_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/floquet.html#FloquetBasis.to_floquet_basis"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.floquet.FloquetBasis.to_floquet_basis" title="Permalink to this definition"></a></dt>
<dd><p>Transform a ket or density matrix in the lab basis
to the Floquet basis at time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lab_basis</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Data</span></code></span></dt><dd><p>Initial state in the lab basis.</p>
</dd>
<dt><strong>t</strong><span class="classifier">float [0]</span></dt><dd><p>The time at which to evaluate the Floquet states.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>output</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Data</span></code></span></dt><dd><p>The state in the Floquet basis. The return type is the same as the
type of the input state.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.propagator.Propagator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Propagator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memoize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-14</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/propagator.html#Propagator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.propagator.Propagator" title="Permalink to this definition"></a></dt>
<dd><p>A generator of propagator for a system.</p>
<p>Usage:</p>
<blockquote>
<div><p>U = Propagator(H, c_ops)</p>
<p>psi_t = U(t) &#64; psi_0</p>
</div></blockquote>
<p>Save some previously computed propagator are stored to speed up subsequent
computation. Changing <code class="docutils literal notranslate"><span class="pre">args</span></code> will erase these stored probagator.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>system</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></span></dt><dd><p>Possibly time-dependent system driving the evolution, either already
packaged in a solver, such as <a class="reference internal" href="#qutip.solver.sesolve.SESolver" title="qutip.solver.sesolve.SESolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">SESolver</span></code></a> or <a class="reference internal" href="#qutip.solver.brmesolve.BRSolver" title="qutip.solver.brmesolve.BRSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">BRSolver</span></code></a>,
or the Liouvillian or Hamiltonian as a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>,
<a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>. <code class="docutils literal notranslate"><span class="pre">list</span></code> of [<a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code>]
or callable that can be made into <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> are also accepted.</p>
<p>Solvers that run non-deterministacilly, such as <a class="reference internal" href="#qutip.solver.mcsolve.MCSolver" title="qutip.solver.mcsolve.MCSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">MCSolver</span></code></a>, are
not supported.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list, optional</span></dt><dd><p>List of <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> or <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> collapse operators.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dictionary, optional</span></dt><dd><p>Parameters to callback functions for time-dependent Hamiltonians and
collapse operators.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver.</p>
</dd>
<dt><strong>memoize</strong><span class="classifier">int, default: 10</span></dt><dd><p>Max number of propagator to save.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, default: 1e-14</span></dt><dd><p>Absolute tolerance for the time. If a previous propagator was computed
at a time within tolerance, that propagator will be returned.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The <a class="reference internal" href="#qutip.solver.propagator.Propagator" title="qutip.solver.propagator.Propagator"><code class="xref py py-class docutils literal notranslate"><span class="pre">Propagator</span></code></a> is not a <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> so
it cannot be used for operations with <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> or
<a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>. It can be made into a
<a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> with</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">U</span> <span class="o">=</span> <span class="n">QobjEvo</span><span class="p">(</span><span class="n">Propagator</span><span class="p">(</span><span class="n">H</span><span class="p">))</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.propagator.Propagator.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/propagator.html#Propagator.__call__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.propagator.Propagator.__call__" title="Permalink to this definition"></a></dt>
<dd><p>Get the propagator from <code class="docutils literal notranslate"><span class="pre">t_start</span></code> to <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>Time at which to compute the propagator.</p>
</dd>
<dt><strong>t_start: float [0]</strong></dt><dd><dl class="simple">
<dt>Time at which the propagator start such that:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">psi[t]</span> <span class="pre">=</span> <span class="pre">U.prop(t,</span> <span class="pre">t_start)</span> <span class="pre">&#64;</span> <span class="pre">psi[t_start]</span></code></p>
</dd>
</dl>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Argument to pass to a time dependent Hamiltonian.
Updating <code class="docutils literal notranslate"><span class="pre">args</span></code> take effect since <code class="docutils literal notranslate"><span class="pre">t=0</span></code> and the new <code class="docutils literal notranslate"><span class="pre">args</span></code>
will be used in future call.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.propagator.Propagator.inv">
<span class="sig-name descname"><span class="pre">inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/propagator.html#Propagator.inv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.propagator.Propagator.inv" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Get the inverse of the propagator at <code class="docutils literal notranslate"><span class="pre">t</span></code>, such that</dt><dd><p><code class="docutils literal notranslate"><span class="pre">psi_0</span> <span class="pre">=</span> <span class="pre">U.inv(t)</span> <span class="pre">&#64;</span> <span class="pre">psi_t</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>Time at which to compute the propagator.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict</span></dt><dd><p>Argument to pass to a time dependent Hamiltonian.
Updating <code class="docutils literal notranslate"><span class="pre">args</span></code> take effect since <code class="docutils literal notranslate"><span class="pre">t=0</span></code> and the new <code class="docutils literal notranslate"><span class="pre">args</span></code>
will be used in future call.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="monte-carlo-solvers">
<span id="classes-monte-carlo-solver"></span><h2>Monte Carlo Solvers<a class="headerlink" href="#monte-carlo-solvers" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.mcsolve.MCSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MCSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/mcsolve.html#MCSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.mcsolve.MCSolver" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">MultiTrajSolver</span></code></p>
<p>Monte Carlo Solver of a state vector <span class="math notranslate nohighlight">\(|\psi \rangle\)</span> for a
given Hamiltonian and sets of collapse operators. Options for the
underlying ODE solver are given by the Options class.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, list, callable.</span></dt><dd><p>System Hamiltonian as a Qobj, QobjEvo. It can also be any input type
that QobjEvo accepts (see <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>’s documentation).
<code class="docutils literal notranslate"><span class="pre">H</span></code> can also be a superoperator (liouvillian) if some collapse
operators are to be treated deterministically.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> of collapse operators in any input type that QobjEvo accepts
(see <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>’s documentation). They must be operators
even if <code class="docutils literal notranslate"><span class="pre">H</span></code> is a superoperator.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, [optional]</span></dt><dd><p>Options for the evolution.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.mcsolve.MCSolver.CollapseFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CollapseFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/mcsolve.html#MCSolver.CollapseFeedback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.mcsolve.MCSolver.CollapseFeedback" title="Permalink to this definition"></a></dt>
<dd><p>Collapse of the trajectory argument for time dependent systems.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;cols&quot;:</span> <span class="pre">MCSolver.CollapseFeedback()})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive a list of <code class="docutils literal notranslate"><span class="pre">(time,</span> <span class="pre">operator</span> <span class="pre">number)</span></code> for
each collapses of the trajectory as <code class="docutils literal notranslate"><span class="pre">cols</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CollapseFeedback can’t be added to a running solver when updating
arguments between steps: <code class="docutils literal notranslate"><span class="pre">solver.step(...,</span> <span class="pre">args={})</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default</strong><span class="classifier">callable, default</span><span class="classifier">[]</span></dt><dd><p>Default function used outside the solver.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.mcsolve.MCSolver.ExpectFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ExpectFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.mcsolve.MCSolver.ExpectFeedback" title="Permalink to this definition"></a></dt>
<dd><p>Expectation value of the instantaneous state of the evolution to be
used by a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;E0&quot;:</span> <span class="pre">Solver.ExpectFeedback(oper)})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive <code class="docutils literal notranslate"><span class="pre">expect(oper,</span> <span class="pre">state)</span></code> as <code class="docutils literal notranslate"><span class="pre">E0</span></code> during the
evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>operator</strong><span class="classifier">Qobj, QobjEvo</span></dt><dd><p>Operator to compute the expectation values of.</p>
</dd>
<dt><strong>default</strong><span class="classifier">float, default</span><span class="classifier">0.</span></dt><dd><p>Initial value to be used at setup.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.mcsolve.MCSolver.StateFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">StateFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raw_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">open</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/mcsolve.html#MCSolver.StateFeedback"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.mcsolve.MCSolver.StateFeedback" title="Permalink to this definition"></a></dt>
<dd><p>State of the evolution to be used in a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;state&quot;:</span> <span class="pre">MCSolver.StateFeedback()})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive the density matrix as <code class="docutils literal notranslate"><span class="pre">state</span></code> during the
evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default</strong><span class="classifier">Qobj or qutip.core.data.Data, default</span><span class="classifier">None</span></dt><dd><p>Initial value to be used at setup of the system.</p>
</dd>
<dt><strong>open</strong><span class="classifier">bool, default False</span></dt><dd><p>Set to <code class="docutils literal notranslate"><span class="pre">True</span></code> when using the monte carlo solver for open systems.</p>
</dd>
<dt><strong>raw_data</strong><span class="classifier">bool, default</span><span class="classifier">False</span></dt><dd><p>If True, the raw matrix will be passed instead of a Qobj.
For density matrices, the matrices can be column stacked or square
depending on the integration method.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.mcsolve.MCSolver.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.mcsolve.MCSolver.options" title="Permalink to this definition"></a></dt>
<dd><p>Options for monte carlo solver:</p>
<dl class="simple">
<dt>store_final_state: bool, default: False</dt><dd><p>Whether or not to store the final state of the evolution in the
result class.</p>
</dd>
<dt>store_states: bool, default: None</dt><dd><p>Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p>
</dd>
<dt>progress_bar: str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}, default: “text”</dt><dd><p>How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p>
</dd>
<dt>progress_kwargs: dict, default: {“chunk_size”:10}</dt><dd><p>Arguments to pass to the progress_bar. Qutip’s bars use
<code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>.</p>
</dd>
<dt>keep_runs_results: bool, default: False</dt><dd><p>Whether to store results from all trajectories or just store the
averages.</p>
</dd>
<dt>method: str, default: “adams”</dt><dd><p>Which differential equation integration method to use.</p>
</dd>
<dt>map: str {“serial”, “parallel”, “loky”, “mpi”}, default: “serial”</dt><dd><p>How to run the trajectories. “parallel” uses the multiprocessing
module to run in parallel while “loky” and “mpi” use the “loky” and
“mpi4py” modules to do so.</p>
</dd>
<dt>mpi_options: dict, default: {}</dt><dd><p>Only applies if map is “mpi”. This dictionary will be passed as
keyword arguments to the <cite>mpi4py.futures.MPIPoolExecutor</cite>
constructor. Note that the <cite>max_workers</cite> argument is provided
separately through the <cite>num_cpus</cite> option.</p>
</dd>
<dt>num_cpus: None, int</dt><dd><p>Number of cpus to use when running in parallel. <code class="docutils literal notranslate"><span class="pre">None</span></code> detect the
number of available cpus.</p>
</dd>
<dt>bitgenerator: {None, “MT19937”, “PCG64”, “PCG64DXSM”, …}</dt><dd><p>Which of numpy.random’s bitgenerator to use. With <code class="docutils literal notranslate"><span class="pre">None</span></code>, your
numpy version’s default is used.</p>
</dd>
<dt>mc_corr_eps: float, default: 1e-10</dt><dd><p>Small number used to detect non-physical collapse caused by
numerical imprecision.</p>
</dd>
<dt>norm_t_tol: float, default: 1e-6</dt><dd><p>Tolerance in time used when finding the collapse.</p>
</dd>
<dt>norm_tol: float, default: 1e-4</dt><dd><p>Tolerance in norm used when finding the collapse.</p>
</dd>
<dt>norm_steps: int, default: 5</dt><dd><p>Maximum number of tries to find the collapse.</p>
</dd>
<dt>improved_sampling: Bool, default: False</dt><dd><p>Whether to use the improved sampling algorithm
of Abdelhafez et al. PRA (2019)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.mcsolve.MCSolver.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seeds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/mcsolve.html#MCSolver.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.mcsolve.MCSolver.run" title="Permalink to this definition"></a></dt>
<dd><p>Do the evolution of the Quantum system.
See the overridden method for further details. The modification
here is to sample the no-jump trajectory first. Then, the no-jump
probability is used as a lower-bound for random numbers in future
monte carlo runs</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.mcsolve.MCSolver.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.mcsolve.MCSolver.start" title="Permalink to this definition"></a></dt>
<dd><p>Set the initial state and time for a step evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>t0</strong><span class="classifier">double</span></dt><dd><p>Initial time of the evolution.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, SeedSequence, list, optional</span></dt><dd><p>Seed for the random number generator. It can be a single seed used
to spawn seeds for each trajectory or a list of seed, one for each
trajectory.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When using step evolution, only one trajectory can be computed at once.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.mcsolve.MCSolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.mcsolve.MCSolver.step" title="Permalink to this definition"></a></dt>
<dd><p>Evolve the state to <code class="docutils literal notranslate"><span class="pre">t</span></code> and return the state as a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">double</span></dt><dd><p>Time to evolve to, must be higher than the last call.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional</span></dt><dd><p>Update the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the system.
The change is effective from the beginning of the interval.
Changing <code class="docutils literal notranslate"><span class="pre">args</span></code> can slow the evolution.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default: True</span></dt><dd><p>Whether to return a copy of the data or the data in the ODE solver.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.mcsolve.MCSolver.sys_dims">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sys_dims</span></span><a class="headerlink" href="#qutip.solver.mcsolve.MCSolver.sys_dims" title="Permalink to this definition"></a></dt>
<dd><p>Dimensions of the space that the system use:</p>
<p><code class="docutils literal notranslate"><span class="pre">qutip.basis(sovler.dims)</span></code> will create a state with proper dimensions
for this solver.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">NonMarkovianMCSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ops_and_rates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/nm_mcsolve.html#NonMarkovianMCSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#qutip.solver.mcsolve.MCSolver" title="qutip.solver.mcsolve.MCSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">MCSolver</span></code></a></p>
<p>Monte Carlo Solver for Lindblad equations with “rates” that may be
negative. The <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> parameter of <a class="reference internal" href="#qutip.solver.mcsolve.MCSolver" title="qutip.solver.mcsolve.MCSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">MCSolver</span></code></a> is replaced by
an <code class="docutils literal notranslate"><span class="pre">ops_and_rates</span></code> parameter to allow for negative rates. Options for the
underlying ODE solver are given by the Options class.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, <code class="docutils literal notranslate"><span class="pre">list</span></code>, callable.</span></dt><dd><p>System Hamiltonian as a Qobj, QobjEvo. It can also be any input type
that QobjEvo accepts (see <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> documentation).
<code class="docutils literal notranslate"><span class="pre">H</span></code> can also be a superoperator (liouvillian) if some collapse
operators are to be treated deterministically.</p>
</dd>
<dt><strong>ops_and_rates</strong><span class="classifier">list</span></dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">list</span></code> of tuples <code class="docutils literal notranslate"><span class="pre">(L,</span> <span class="pre">Gamma)</span></code>, where the Lindblad operator <code class="docutils literal notranslate"><span class="pre">L</span></code>
is a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a> and <code class="docutils literal notranslate"><span class="pre">Gamma</span></code> represents the corresponding
rate, which is allowed to be negative. The Lindblad operators must be
operators even if <code class="docutils literal notranslate"><span class="pre">H</span></code> is a superoperator. Each rate <code class="docutils literal notranslate"><span class="pre">Gamma</span></code> may be
just a number (in the case of a constant rate) or, otherwise, specified
using any format accepted by <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.coefficient</span></code>.</p>
</dd>
<dt><strong>args</strong><span class="classifier">None / dict</span></dt><dd><p>Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</dd>
<dt><strong>options</strong><span class="classifier">SolverOptions, [optional]</span></dt><dd><p>Options for the evolution.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver.CollapseFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CollapseFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.CollapseFeedback" title="Permalink to this definition"></a></dt>
<dd><p>Collapse of the trajectory argument for time dependent systems.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;cols&quot;:</span> <span class="pre">MCSolver.CollapseFeedback()})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive a list of <code class="docutils literal notranslate"><span class="pre">(time,</span> <span class="pre">operator</span> <span class="pre">number)</span></code> for
each collapses of the trajectory as <code class="docutils literal notranslate"><span class="pre">cols</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CollapseFeedback can’t be added to a running solver when updating
arguments between steps: <code class="docutils literal notranslate"><span class="pre">solver.step(...,</span> <span class="pre">args={})</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default</strong><span class="classifier">callable, default</span><span class="classifier">[]</span></dt><dd><p>Default function used outside the solver.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver.ExpectFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ExpectFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.ExpectFeedback" title="Permalink to this definition"></a></dt>
<dd><p>Expectation value of the instantaneous state of the evolution to be
used by a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;E0&quot;:</span> <span class="pre">Solver.ExpectFeedback(oper)})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive <code class="docutils literal notranslate"><span class="pre">expect(oper,</span> <span class="pre">state)</span></code> as <code class="docutils literal notranslate"><span class="pre">E0</span></code> during the
evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>operator</strong><span class="classifier">Qobj, QobjEvo</span></dt><dd><p>Operator to compute the expectation values of.</p>
</dd>
<dt><strong>default</strong><span class="classifier">float, default</span><span class="classifier">0.</span></dt><dd><p>Initial value to be used at setup.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver.StateFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">StateFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raw_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">open</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.StateFeedback" title="Permalink to this definition"></a></dt>
<dd><p>State of the evolution to be used in a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;state&quot;:</span> <span class="pre">MCSolver.StateFeedback()})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive the density matrix as <code class="docutils literal notranslate"><span class="pre">state</span></code> during the
evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default</strong><span class="classifier">Qobj or qutip.core.data.Data, default</span><span class="classifier">None</span></dt><dd><p>Initial value to be used at setup of the system.</p>
</dd>
<dt><strong>open</strong><span class="classifier">bool, default False</span></dt><dd><p>Set to <code class="docutils literal notranslate"><span class="pre">True</span></code> when using the monte carlo solver for open systems.</p>
</dd>
<dt><strong>raw_data</strong><span class="classifier">bool, default</span><span class="classifier">False</span></dt><dd><p>If True, the raw matrix will be passed instead of a Qobj.
For density matrices, the matrices can be column stacked or square
depending on the integration method.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver.current_martingale">
<span class="sig-name descname"><span class="pre">current_martingale</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/nm_mcsolve.html#NonMarkovianMCSolver.current_martingale"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.current_martingale" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of the influence martingale along the current
trajectory. The value of the martingale is the product of the
continuous and the discrete contribution. The current time and the
collapses that have happened are read out from the internal integrator.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.options" title="Permalink to this definition"></a></dt>
<dd><p>Options for non-Markovian Monte Carlo solver:</p>
<dl class="simple">
<dt>store_final_state: bool, default: False</dt><dd><p>Whether or not to store the final state of the evolution in the
result class.</p>
</dd>
<dt>store_states: bool, default: None</dt><dd><p>Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p>
</dd>
<dt>progress_bar: str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}, default: “text”</dt><dd><p>How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p>
</dd>
<dt>progress_kwargs: dict, default: {“chunk_size”:10}</dt><dd><p>Arguments to pass to the progress_bar. Qutip’s bars use
<code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>.</p>
</dd>
<dt>keep_runs_results: bool, default: False</dt><dd><p>Whether to store results from all trajectories or just store the
averages.</p>
</dd>
<dt>method: str, default: “adams”</dt><dd><p>Which differential equation integration method to use.</p>
</dd>
<dt>map: str {“serial”, “parallel”, “loky”, “mpi”}, default: “serial”</dt><dd><p>How to run the trajectories. “parallel” uses the multiprocessing
module to run in parallel while “loky” and “mpi” use the “loky” and
“mpi4py” modules to do so.</p>
</dd>
<dt>mpi_options: dict, default: {}</dt><dd><p>Only applies if map is “mpi”. This dictionary will be passed as
keyword arguments to the <cite>mpi4py.futures.MPIPoolExecutor</cite>
constructor. Note that the <cite>max_workers</cite> argument is provided
separately through the <cite>num_cpus</cite> option.</p>
</dd>
<dt>num_cpus: None, int</dt><dd><p>Number of cpus to use when running in parallel. <code class="docutils literal notranslate"><span class="pre">None</span></code> detect the
number of available cpus.</p>
</dd>
<dt>bitgenerator: {None, “MT19937”, “PCG64”, “PCG64DXSM”, …}</dt><dd><p>Which of numpy.random’s bitgenerator to use. With <code class="docutils literal notranslate"><span class="pre">None</span></code>, your
numpy version’s default is used.</p>
</dd>
<dt>mc_corr_eps: float, default: 1e-10</dt><dd><p>Small number used to detect non-physical collapse caused by
numerical imprecision.</p>
</dd>
<dt>norm_t_tol: float, default: 1e-6</dt><dd><p>Tolerance in time used when finding the collapse.</p>
</dd>
<dt>norm_tol: float, default: 1e-4</dt><dd><p>Tolerance in norm used when finding the collapse.</p>
</dd>
<dt>norm_steps: int, default: 5</dt><dd><p>Maximum number of tries to find the collapse.</p>
</dd>
<dt>completeness_rtol: float, default: 1e-5</dt><dd><p>Used in determining whether the given Lindblad operators satisfy
a certain completeness relation. If they do not, an additional
Lindblad operator is added automatically (with zero rate).</p>
</dd>
<dt>completeness_atol: float, default: 1e-8</dt><dd><p>Used in determining whether the given Lindblad operators satisfy
a certain completeness relation. If they do not, an additional
Lindblad operator is added automatically (with zero rate).</p>
</dd>
<dt>martingale_quad_limit: float or int, default: 100</dt><dd><p>An upper bound on the number of subintervals used in the adaptive
integration of the martingale.</p>
</dd>
</dl>
<p>Note that the ‘improved_sampling’ option is not currently supported.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver.rate">
<span class="sig-name descname"><span class="pre">rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/nm_mcsolve.html#NonMarkovianMCSolver.rate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.rate" title="Permalink to this definition"></a></dt>
<dd><p>Return the i’th unshifted rate at time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time at which to calculate the rate.</p>
</dd>
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>Which rate to calculate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rate</strong><span class="classifier">float</span></dt><dd><p>The value of rate <code class="docutils literal notranslate"><span class="pre">i</span></code> at time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver.rate_shift">
<span class="sig-name descname"><span class="pre">rate_shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/nm_mcsolve.html#NonMarkovianMCSolver.rate_shift"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.rate_shift" title="Permalink to this definition"></a></dt>
<dd><p>Return the rate shift at time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<p>The rate shift is <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">abs(min([0,</span> <span class="pre">rate_1(t),</span> <span class="pre">rate_2(t),</span> <span class="pre">...]))</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time at which to calculate the rate shift.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rate_shift</strong><span class="classifier">float</span></dt><dd><p>The rate shift amount.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/nm_mcsolve.html#NonMarkovianMCSolver.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.run" title="Permalink to this definition"></a></dt>
<dd><p>Do the evolution of the Quantum system.</p>
<p>For a <code class="docutils literal notranslate"><span class="pre">state</span></code> at time <code class="docutils literal notranslate"><span class="pre">tlist[0]</span></code> do the evolution as directed by
<code class="docutils literal notranslate"><span class="pre">rhs</span></code> and for each time in <code class="docutils literal notranslate"><span class="pre">tlist</span></code> store the state and/or
expectation values in a <a class="reference internal" href="#qutip.solver.result.Result" title="qutip.solver.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>. The evolution method and
stored results are determined by <code class="docutils literal notranslate"><span class="pre">options</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list of double</span></dt><dd><p>Time for which to save the results (state and/or expect) of the
evolution. The first element of the list is the initial time of the
evolution. Time in the list must be in increasing order, but does
not need to be uniformly distributed.</p>
</dd>
<dt><strong>ntraj</strong><span class="classifier">int</span></dt><dd><p>Number of trajectories to add.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional</span></dt><dd><p>Change the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the rhs for the evolution.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list</span></dt><dd><p>list of Qobj or QobjEvo to compute the expectation values.
Alternatively, function[s] with the signature f(t, state) -&gt; expect
can be used.</p>
</dd>
<dt><strong>timeout</strong><span class="classifier">float, optional</span></dt><dd><p>Maximum time in seconds for the trajectories to run. Once this time
is reached, the simulation will end even if the number
of trajectories is less than <code class="docutils literal notranslate"><span class="pre">ntraj</span></code>. The map function, set in
options, can interupt the running trajectory or wait for it to
finish. Set to an arbitrary high number to disable.</p>
</dd>
<dt><strong>target_tol</strong><span class="classifier">{float, tuple, list}, optional</span></dt><dd><p>Target tolerance of the evolution. The evolution will compute
trajectories until the error on the expectation values is lower
than this tolerance. The maximum number of trajectories employed is
given by <code class="docutils literal notranslate"><span class="pre">ntraj</span></code>. The error is computed using jackknife
resampling. <code class="docutils literal notranslate"><span class="pre">target_tol</span></code> can be an absolute tolerance or a pair
of absolute and relative tolerance, in that order. Lastly, it can
be a list of pairs of (atol, rtol) for each e_ops.</p>
</dd>
<dt><strong>seeds</strong><span class="classifier">{int, SeedSequence, list}, optional</span></dt><dd><p>Seed or list of seeds for each trajectories.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.result.MultiTrajResult" title="qutip.solver.result.MultiTrajResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiTrajResult</span></code></a></span></dt><dd><p>Results of the evolution. States and/or expect will be saved. You
can control the saved data in the options.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver.sqrt_shifted_rate">
<span class="sig-name descname"><span class="pre">sqrt_shifted_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/nm_mcsolve.html#NonMarkovianMCSolver.sqrt_shifted_rate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.sqrt_shifted_rate" title="Permalink to this definition"></a></dt>
<dd><p>Return the square root of the i’th shifted rate at time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">float</span></dt><dd><p>The time at wich to calculate the shifted rate.</p>
</dd>
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>Which shifted rate to calculate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rate</strong><span class="classifier">float</span></dt><dd><p>The square root of the shifted value of rate <code class="docutils literal notranslate"><span class="pre">i</span></code> at time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/nm_mcsolve.html#NonMarkovianMCSolver.start"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.start" title="Permalink to this definition"></a></dt>
<dd><p>Set the initial state and time for a step evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>t0</strong><span class="classifier">double</span></dt><dd><p>Initial time of the evolution.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, SeedSequence, list, optional</span></dt><dd><p>Seed for the random number generator. It can be a single seed used
to spawn seeds for each trajectory or a list of seed, one for each
trajectory.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When using step evolution, only one trajectory can be computed at once.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/nm_mcsolve.html#NonMarkovianMCSolver.step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.step" title="Permalink to this definition"></a></dt>
<dd><p>Evolve the state to <code class="docutils literal notranslate"><span class="pre">t</span></code> and return the state as a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">double</span></dt><dd><p>Time to evolve to, must be higher than the last call.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional</span></dt><dd><p>Update the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the system.
The change is effective from the beginning of the interval.
Changing <code class="docutils literal notranslate"><span class="pre">args</span></code> can slow the evolution.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default: True</span></dt><dd><p>Whether to return a copy of the data or the data in the ODE solver.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.nm_mcsolve.NonMarkovianMCSolver.sys_dims">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sys_dims</span></span><a class="headerlink" href="#qutip.solver.nm_mcsolve.NonMarkovianMCSolver.sys_dims" title="Permalink to this definition"></a></dt>
<dd><p>Dimensions of the space that the system use:</p>
<p><code class="docutils literal notranslate"><span class="pre">qutip.basis(sovler.dims)</span></code> will create a state with proper dimensions
for this solver.</p>
</dd></dl>

</dd></dl>

</section>
<section id="non-markovian-heom-solver">
<span id="classes-non-markov-heom"></span><h2>Non-Markovian HEOM Solver<a class="headerlink" href="#non-markovian-heom-solver" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.HEOMSolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HEOMSolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HEOMSolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HEOMSolver" title="Permalink to this definition"></a></dt>
<dd><p>HEOM solver that supports multiple baths.</p>
<p>The baths must be all either bosonic or fermionic baths.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a></span></dt><dd><p>Possibly time-dependent system Liouvillian or Hamiltonian as a Qobj or
QobjEvo. list of [<a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable that
can be made into <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> are also accepted.</p>
</dd>
<dt><strong>bath</strong><span class="classifier">Bath or list of Bath</span></dt><dd><p>A <a class="reference internal" href="#qutip.solver.heom.Bath" title="qutip.solver.heom.Bath"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Bath</span></code></a> containing the exponents of the expansion of the
bath correlation funcion and their associated coefficients
and coupling operators, or a list of baths.</p>
<p>If multiple baths are given, they must all be either fermionic
or bosonic baths.</p>
</dd>
<dt><strong>max_depth</strong><span class="classifier">int</span></dt><dd><p>The maximum depth of the heirarchy (i.e. the maximum number of bath
exponent “excitations” to retain).</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Generic solver options.
If set to None the default options will be used. Keyword only.
Default: None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>ados</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.heom.HierarchyADOs" title="qutip.solver.heom.HierarchyADOs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HierarchyADOs</span></code></a></span></dt><dd><p>The description of the hierarchy constructed from the given bath
and maximum depth.</p>
</dd>
<dt><strong>rhs</strong><span class="classifier"><a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a></span></dt><dd><p>The right-hand side (RHS) of the hierarchy evolution ODE. Internally
the system and bath coupling operators are converted to
<code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.data.CSR</span></code> instances during construction of the RHS,
so the operators in the <code class="docutils literal notranslate"><span class="pre">rhs</span></code> will all be sparse.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.heom.HEOMSolver.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.heom.HEOMSolver.options" title="Permalink to this definition"></a></dt>
<dd><p>Options for HEOMSolver:</p>
<dl class="simple">
<dt>store_final_state: bool, default: False</dt><dd><p>Whether or not to store the final state of the evolution in the
result class.</p>
</dd>
<dt>store_states: bool, default: None</dt><dd><p>Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p>
</dd>
<dt>normalize_output: bool, default: False</dt><dd><p>Normalize output state to hide ODE numerical errors.</p>
</dd>
<dt>progress_bar: str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}, default: “text”</dt><dd><p>How to present the solver progress.
‘tqdm’ uses the python module of the same name and raise an error
if not installed. Empty string or False will disable the bar.</p>
</dd>
<dt>progress_kwargs: dict, default: {“chunk_size”: 10}</dt><dd><p>Arguments to pass to the progress_bar. Qutip’s bars use
<code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>.</p>
</dd>
<dt>method: str, default: “adams”</dt><dd><p>Which ordinary differential equation integration method to use.</p>
</dd>
<dt>state_data_type: str, default: “dense”</dt><dd><p>Name of the data type of the state used during the ODE evolution.
Use an empty string to keep the input state type. Many integrators
support only work with <cite>Dense</cite>.</p>
</dd>
<dt>store_ados<span class="classifier">bool, default: False</span></dt><dd><p>Whether or not to store the HEOM ADOs. Only relevant when using
the HEOM solver.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.heom.HEOMSolver.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HEOMSolver.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HEOMSolver.run" title="Permalink to this definition"></a></dt>
<dd><p>Solve for the time evolution of the system.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> or <a class="reference internal" href="#qutip.solver.heom.HierarchyADOsState" title="qutip.solver.heom.HierarchyADOsState"><code class="xref py py-class docutils literal notranslate"><span class="pre">HierarchyADOsState</span></code></a> or array-like</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">rho0</span></code> is a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> the it is the initial state
of the system (i.e. a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> density matrix).</p>
<p>If it is a <a class="reference internal" href="#qutip.solver.heom.HierarchyADOsState" title="qutip.solver.heom.HierarchyADOsState"><code class="xref py py-class docutils literal notranslate"><span class="pre">HierarchyADOsState</span></code></a> or array-like, then
<code class="docutils literal notranslate"><span class="pre">rho0</span></code> gives the initial state of all ADOs.</p>
<p>Usually the state of the ADOs would be determine from a previous
call to <code class="docutils literal notranslate"><span class="pre">.run(...)</span></code> with the solver results option <code class="docutils literal notranslate"><span class="pre">store_ados</span></code>
set to True. For example, <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">solver.run(...)</span></code> could be
followed by <code class="docutils literal notranslate"><span class="pre">solver.run(result.ado_states[-1],</span> <span class="pre">tlist)</span></code>.</p>
<p>If a numpy array-like is passed its shape must be
<code class="docutils literal notranslate"><span class="pre">(number_of_ados,</span> <span class="pre">n,</span> <span class="pre">n)</span></code> where <code class="docutils literal notranslate"><span class="pre">(n,</span> <span class="pre">n)</span></code> is the system shape
(i.e. shape of the system density matrix) and the ADOs must
be in the same order as in <code class="docutils literal notranslate"><span class="pre">.ados.labels</span></code>.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list</span></dt><dd><p>An ordered list of times at which to return the value of the state.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional {None}</span></dt><dd><p>Change the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the RHS for the evolution.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">Qobj / QobjEvo / callable / list / dict / None, optional</span></dt><dd><p>A list or dictionary of operators as <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>,
<a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> and/or callable functions (they can be mixed) or
a single operator or callable function. For an operator <code class="docutils literal notranslate"><span class="pre">op</span></code>, the
result will be computed using <code class="docutils literal notranslate"><span class="pre">(state</span> <span class="pre">*</span> <span class="pre">op).tr()</span></code> and the state
at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>. For callable functions, <code class="docutils literal notranslate"><span class="pre">f</span></code>, the result is
computed using <code class="docutils literal notranslate"><span class="pre">f(t,</span> <span class="pre">ado_state)</span></code>. The values are stored in the
<code class="docutils literal notranslate"><span class="pre">expect</span></code> and <code class="docutils literal notranslate"><span class="pre">e_data</span></code> attributes of the result (see the return
section below).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><a class="reference internal" href="#qutip.solver.heom.HEOMResult" title="qutip.solver.heom.HEOMResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMResult</span></code></a></dt><dd><p>The results of the simulation run, with the following important
attributes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">times</span></code>: the times <code class="docutils literal notranslate"><span class="pre">t</span></code> (i.e. the <code class="docutils literal notranslate"><span class="pre">tlist</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">states</span></code>: the system state at each time <code class="docutils literal notranslate"><span class="pre">t</span></code> (only available
if <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> was <code class="docutils literal notranslate"><span class="pre">None</span></code> or if the solver option
<code class="docutils literal notranslate"><span class="pre">store_states</span></code> was set to <code class="docutils literal notranslate"><span class="pre">True</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ado_states</span></code>: the full ADO state at each time (only available
if the results option <code class="docutils literal notranslate"><span class="pre">ado_return</span></code> was set to <code class="docutils literal notranslate"><span class="pre">True</span></code>).
Each element is an instance of <a class="reference internal" href="#qutip.solver.heom.HierarchyADOsState" title="qutip.solver.heom.HierarchyADOsState"><code class="xref py py-class docutils literal notranslate"><span class="pre">HierarchyADOsState</span></code></a>.
The state of a particular ADO may be extracted from
<code class="docutils literal notranslate"><span class="pre">result.ado_states[i]</span></code> by calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">extract</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expect</span></code>: a list containing the values of each <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> at
time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">e_data</span></code>: a dictionary containing the values of each <code class="docutils literal notranslate"><span class="pre">e_ops</span></code>
at tme <code class="docutils literal notranslate"><span class="pre">t</span></code>. The keys are those given by <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> if it was
a dict, otherwise they are the indexes of the supplied <code class="docutils literal notranslate"><span class="pre">e_ops</span></code>.</p></li>
</ul>
<p>See <a class="reference internal" href="#qutip.solver.heom.HEOMResult" title="qutip.solver.heom.HEOMResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMResult</span></code></a> and <a class="reference internal" href="#qutip.solver.result.Result" title="qutip.solver.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a> for the complete
list of attributes.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.heom.HEOMSolver.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HEOMSolver.start"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HEOMSolver.start" title="Permalink to this definition"></a></dt>
<dd><p>Set the initial state and time for a step evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state0</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution. This may provide either just the
initial density matrix of the system, or the full set of ADOs
for the hierarchy. See the documentation for <code class="docutils literal notranslate"><span class="pre">rho0</span></code> in the
<code class="docutils literal notranslate"><span class="pre">.run(...)</span></code> method for details.</p>
</dd>
<dt><strong>t0</strong><span class="classifier">double</span></dt><dd><p>Initial time of the evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.heom.HEOMSolver.steady_state">
<span class="sig-name descname"><span class="pre">steady_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">use_mkl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mkl_max_iter_refine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mkl_weighted_matching</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HEOMSolver.steady_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HEOMSolver.steady_state" title="Permalink to this definition"></a></dt>
<dd><p>Compute the steady state of the system.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>use_mkl</strong><span class="classifier">bool, default=False</span></dt><dd><p>Whether to use mkl or not. If mkl is not installed or if
this is false, use the scipy splu solver instead.</p>
</dd>
<dt><strong>mkl_max_iter_refine</strong><span class="classifier">int</span></dt><dd><p>Specifies the the maximum number of iterative refinement steps that
the MKL PARDISO solver performs.</p>
<p>For a complete description, see iparm(7) in
<a class="reference external" href="https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html">https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html</a></p>
</dd>
<dt><strong>mkl_weighted_matching</strong><span class="classifier">bool</span></dt><dd><p>MKL PARDISO can use a maximum weighted matching algorithm to
permute large elements close the diagonal. This strategy adds an
additional level of reliability to the factorization methods.</p>
<p>For a complete description, see iparm(12) in
<a class="reference external" href="https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html">https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-c/2023-0/pardiso-iparm-parameter.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>steady_state</strong><span class="classifier">Qobj</span></dt><dd><p>The steady state density matrix of the system.</p>
</dd>
<dt><strong>steady_ados</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.heom.HierarchyADOsState" title="qutip.solver.heom.HierarchyADOsState"><code class="xref py py-class docutils literal notranslate"><span class="pre">HierarchyADOsState</span></code></a></span></dt><dd><p>The steady state of the full ADO hierarchy. A particular ADO may be
extracted from the full state by calling
<code class="xref py py-meth docutils literal notranslate"><span class="pre">extract</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.heom.HEOMSolver.sys_dims">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sys_dims</span></span><a class="headerlink" href="#qutip.solver.heom.HEOMSolver.sys_dims" title="Permalink to this definition"></a></dt>
<dd><p>Dimensions of the space that the system use, excluding any environment:</p>
<p><code class="docutils literal notranslate"><span class="pre">qutip.basis(sovler.dims)</span></code> will create a state with proper dimensions
for this solver.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.HSolverDL">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HSolverDL</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_sys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coup_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coup_strength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temperature</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_cut</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_exp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut_freq</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bnd_cut_approx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HSolverDL"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HSolverDL" title="Permalink to this definition"></a></dt>
<dd><p>A helper class for creating an <a class="reference internal" href="#qutip.solver.heom.HEOMSolver" title="qutip.solver.heom.HEOMSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a> that is backwards
compatible with the <code class="docutils literal notranslate"><span class="pre">HSolverDL</span></code> provided in <code class="docutils literal notranslate"><span class="pre">qutip.nonmarkov.heom</span></code>
in QuTiP 4.6 and below.</p>
<p>See <a class="reference internal" href="#qutip.solver.heom.HEOMSolver" title="qutip.solver.heom.HEOMSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a> and <a class="reference internal" href="#qutip.solver.heom.DrudeLorentzBath" title="qutip.solver.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a> for more
descriptions of the underlying solver and bath construction.</p>
<p>An exact copy of the QuTiP 4.6 HSolverDL is provided in
<code class="docutils literal notranslate"><span class="pre">qutip.nonmarkov.dlheom_solver</span></code> for cases where the functionality of
the older solver is required. The older solver will be completely
removed in QuTiP 5.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike the version of <code class="docutils literal notranslate"><span class="pre">HSolverDL</span></code> in QuTiP 4.6, this solver
supports supplying a time-dependent or Liouvillian <code class="docutils literal notranslate"><span class="pre">H_sys</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For compatibility with <code class="docutils literal notranslate"><span class="pre">HSolverDL</span></code> in QuTiP 4.6 and below, the
parameter <code class="docutils literal notranslate"><span class="pre">N_exp</span></code> specifying the number of exponents to keep in
the expansion of the bath correlation function is one more than
the equivalent <code class="docutils literal notranslate"><span class="pre">Nk</span></code> used in the <a class="reference internal" href="#qutip.solver.heom.DrudeLorentzBath" title="qutip.solver.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a>. I.e.,
<code class="docutils literal notranslate"><span class="pre">Nk</span> <span class="pre">=</span> <span class="pre">N_exp</span> <span class="pre">-</span> <span class="pre">1</span></code>. The <code class="docutils literal notranslate"><span class="pre">Nk</span></code> parameter in the
<a class="reference internal" href="#qutip.solver.heom.DrudeLorentzBath" title="qutip.solver.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a> does not count the zeroeth exponent in
order to better match common usage in the literature.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">stats</span></code> and <code class="docutils literal notranslate"><span class="pre">renorm</span></code> arguments accepted in QuTiP 4.6 and below
are no longer supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H_sys</strong><span class="classifier">Qobj or QobjEvo or list</span></dt><dd><p>The system Hamiltonian or Liouvillian. See <a class="reference internal" href="#qutip.solver.heom.HEOMSolver" title="qutip.solver.heom.HEOMSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a> for
a complete description.</p>
</dd>
<dt><strong>coup_op</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.
See parameter <code class="docutils literal notranslate"><span class="pre">Q</span></code> in <a class="reference internal" href="#qutip.solver.heom.BosonicBath" title="qutip.solver.heom.BosonicBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">BosonicBath</span></code></a> for a complete description.</p>
</dd>
<dt><strong>coup_strength</strong><span class="classifier">float</span></dt><dd><p>Coupling strength. Referred to as <code class="docutils literal notranslate"><span class="pre">lam</span></code> in <a class="reference internal" href="#qutip.solver.heom.DrudeLorentzBath" title="qutip.solver.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a>.</p>
</dd>
<dt><strong>temperature</strong><span class="classifier">float</span></dt><dd><p>Bath temperature. Referred to as <code class="docutils literal notranslate"><span class="pre">T</span></code> in <a class="reference internal" href="#qutip.solver.heom.DrudeLorentzBath" title="qutip.solver.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a>.</p>
</dd>
<dt><strong>N_cut</strong><span class="classifier">int</span></dt><dd><p>The maximum depth of the hierarchy. See <code class="docutils literal notranslate"><span class="pre">max_depth</span></code> in
<a class="reference internal" href="#qutip.solver.heom.HEOMSolver" title="qutip.solver.heom.HEOMSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a> for a full description.</p>
</dd>
<dt><strong>N_exp</strong><span class="classifier">int</span></dt><dd><p>Number of exponential terms used to approximate the bath correlation
functions. The equivalent <code class="docutils literal notranslate"><span class="pre">Nk</span></code> in <a class="reference internal" href="#qutip.solver.heom.DrudeLorentzBath" title="qutip.solver.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a> is one
less than <code class="docutils literal notranslate"><span class="pre">N_exp</span></code> (see note above).</p>
</dd>
<dt><strong>cut_freq</strong><span class="classifier">float</span></dt><dd><p>Bath spectral density cutoff frequency. Referred to as <code class="docutils literal notranslate"><span class="pre">gamma</span></code> in
<a class="reference internal" href="#qutip.solver.heom.DrudeLorentzBath" title="qutip.solver.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a>.</p>
</dd>
<dt><strong>bnd_cut_approx</strong><span class="classifier">bool</span></dt><dd><p>Use boundary cut off approximation. If true, the Matsubara
terminator is added to the system Liouvillian (and H_sys is
promoted to a Liouvillian if it was a Hamiltonian). Keyword only.
Default: False.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Generic solver options.
If set to None the default options will be used. Keyword only.
Default: None.</p>
</dd>
<dt><strong>combine</strong><span class="classifier">bool, default: True</span></dt><dd><p>Whether to combine exponents with the same frequency (and coupling
operator). See <a class="reference internal" href="#qutip.solver.heom.BosonicBath.combine" title="qutip.solver.heom.BosonicBath.combine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BosonicBath.combine</span></code></a> for details.
Keyword only. Default: True.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.BathExponent">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BathExponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ck</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ck2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_bar_k_offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_baths.html#BathExponent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.BathExponent" title="Permalink to this definition"></a></dt>
<dd><p>Represents a single exponent (naively, an excitation mode) within the
decomposition of the correlation functions of a bath.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>type</strong><span class="classifier">{“R”, “I”, “RI”, “+”, “-”} or BathExponent.ExponentType</span></dt><dd><p>The type of bath exponent.</p>
<p>“R” and “I” are bosonic bath exponents that appear in the real and
imaginary parts of the correlation expansion.</p>
<p>“RI” is combined bosonic bath exponent that appears in both the real
and imaginary parts of the correlation expansion. The combined exponent
has a single <code class="docutils literal notranslate"><span class="pre">vk</span></code>. The <code class="docutils literal notranslate"><span class="pre">ck</span></code> is the coefficient in the real
expansion and <code class="docutils literal notranslate"><span class="pre">ck2</span></code> is the coefficient in the imaginary expansion.</p>
<p>“+” and “-” are fermionic bath exponents. These fermionic bath
exponents must specify <code class="docutils literal notranslate"><span class="pre">sigma_bar_k_offset</span></code> which specifies
the amount to add to <code class="docutils literal notranslate"><span class="pre">k</span></code> (the exponent index within the bath of this
exponent) to determine the <code class="docutils literal notranslate"><span class="pre">k</span></code> of the corresponding exponent with
the opposite sign (i.e. “-” or “+”).</p>
</dd>
<dt><strong>dim</strong><span class="classifier">int or None</span></dt><dd><p>The dimension (i.e. maximum number of excitations for this exponent).
Usually <code class="docutils literal notranslate"><span class="pre">2</span></code> for fermionic exponents or <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e. unlimited) for
bosonic exponents.</p>
</dd>
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>The coupling operator for this excitation mode.</p>
</dd>
<dt><strong>vk</strong><span class="classifier">complex</span></dt><dd><p>The frequency of the exponent of the excitation term.</p>
</dd>
<dt><strong>ck</strong><span class="classifier">complex</span></dt><dd><p>The coefficient of the excitation term.</p>
</dd>
<dt><strong>ck2</strong><span class="classifier">optional, complex</span></dt><dd><p>For exponents of type “RI” this is the coefficient of the term in the
imaginary expansion (and <code class="docutils literal notranslate"><span class="pre">ck</span></code> is the coefficient in the real
expansion).</p>
</dd>
<dt><strong>sigma_bar_k_offset</strong><span class="classifier">optional, int</span></dt><dd><p>For exponents of type “+” this gives the offset (within the list of
exponents within the bath) of the corresponding “-” bath exponent.
For exponents of type “-” it gives the offset of the corresponding
“+” exponent.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the exponent (often the name of the bath). It
defaults to None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fermionic</strong><span class="classifier">bool</span></dt><dd><p>True if the type of the exponent is a Fermionic type (i.e. either
“+” or “-”) and False otherwise.</p>
</dd>
<dt><strong>All of the parameters are also available as attributes.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="qutip.solver.heom.BathExponent.types">
<span class="sig-name descname"><span class="pre">types</span></span><a class="headerlink" href="#qutip.solver.heom.BathExponent.types" title="Permalink to this definition"></a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentType</span></code></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.Bath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Bath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exponents</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_baths.html#Bath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.Bath" title="Permalink to this definition"></a></dt>
<dd><p>Represents a list of bath expansion exponents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>exponents</strong><span class="classifier">list of BathExponent</span></dt><dd><p>The exponents of the correlation function describing the bath.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>All of the parameters are available as attributes.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.BosonicBath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BosonicBath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ck_real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vk_real</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ck_imag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vk_imag</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_baths.html#BosonicBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.BosonicBath" title="Permalink to this definition"></a></dt>
<dd><p>A helper class for constructing a bosonic bath from the expansion
coefficients and frequencies for the real and imaginary parts of
the bath correlation function.</p>
<p>If the correlation functions <code class="docutils literal notranslate"><span class="pre">C(t)</span></code> is split into real and imaginary
parts:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">C_real</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">C_imag</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>then:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C_real</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ck_real</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">vk_real</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
<span class="n">C_imag</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ck_imag</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">vk_imag</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>Defines the coefficients <code class="docutils literal notranslate"><span class="pre">ck</span></code> and the frequencies <code class="docutils literal notranslate"><span class="pre">vk</span></code>.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">ck</span></code> and <code class="docutils literal notranslate"><span class="pre">vk</span></code> may be complex, even through <code class="docutils literal notranslate"><span class="pre">C_real(t)</span></code>
and <code class="docutils literal notranslate"><span class="pre">C_imag(t)</span></code> (i.e. the sum) is real.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>The coupling operator for the bath.</p>
</dd>
<dt><strong>ck_real</strong><span class="classifier">list of complex</span></dt><dd><p>The coefficients of the expansion terms for the real part of the
correlation function. The corresponding frequencies are passed as
vk_real.</p>
</dd>
<dt><strong>vk_real</strong><span class="classifier">list of complex</span></dt><dd><p>The frequencies (exponents) of the expansion terms for the real part of
the correlation function. The corresponding ceofficients are passed as
ck_real.</p>
</dd>
<dt><strong>ck_imag</strong><span class="classifier">list of complex</span></dt><dd><p>The coefficients of the expansion terms in the imaginary part of the
correlation function. The corresponding frequencies are passed as
vk_imag.</p>
</dd>
<dt><strong>vk_imag</strong><span class="classifier">list of complex</span></dt><dd><p>The frequencies (exponents) of the expansion terms for the imaginary
part of the correlation function. The corresponding ceofficients are
passed as ck_imag.</p>
</dd>
<dt><strong>combine</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to combine exponents with the same frequency (and coupling
operator). See <a class="reference internal" href="#qutip.solver.heom.BosonicBath.combine" title="qutip.solver.heom.BosonicBath.combine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">combine</span></code></a> for details.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.heom.BosonicBath.combine">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">combine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exponents</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-07</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_baths.html#BosonicBath.combine"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.BosonicBath.combine" title="Permalink to this definition"></a></dt>
<dd><p>Group bosonic exponents with the same frequency and return a
single exponent for each frequency present.</p>
<p>Exponents with the same frequency are only combined if they share the
same coupling operator <code class="docutils literal notranslate"><span class="pre">.Q</span></code>.</p>
<p>Note that combined exponents take their tag from the first
exponent in the group being combined (i.e. the one that occurs first
in the given exponents list).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>exponents</strong><span class="classifier">list of BathExponent</span></dt><dd><p>The list of exponents to combine.</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float, default 1e-5</span></dt><dd><p>The relative tolerance to use to when comparing frequencies and
coupling operators.</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float, default 1e-7</span></dt><dd><p>The absolute tolerance to use to when comparing frequencies and
coupling operators.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list of BathExponent</dt><dd><p>The new reduced list of exponents.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.DrudeLorentzBath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">DrudeLorentzBath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_baths.html#DrudeLorentzBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.DrudeLorentzBath" title="Permalink to this definition"></a></dt>
<dd><p>A helper class for constructing a Drude-Lorentz bosonic bath from the
bath parameters (see parameters below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.</p>
</dd>
<dt><strong>lam</strong><span class="classifier">float</span></dt><dd><p>Coupling strength.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>Bath spectral density cutoff frequency.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>Bath temperature.</p>
</dd>
<dt><strong>Nk</strong><span class="classifier">int</span></dt><dd><p>Number of exponential terms used to approximate the bath correlation
functions.</p>
</dd>
<dt><strong>combine</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to combine exponents with the same frequency (and coupling
operator). See <a class="reference internal" href="#qutip.solver.heom.BosonicBath.combine" title="qutip.solver.heom.BosonicBath.combine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BosonicBath.combine</span></code></a> for details.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.heom.DrudeLorentzBath.terminator">
<span class="sig-name descname"><span class="pre">terminator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_baths.html#DrudeLorentzBath.terminator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.DrudeLorentzBath.terminator" title="Permalink to this definition"></a></dt>
<dd><p>Return the Matsubara terminator for the bath and the calculated
approximation discrepancy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>delta: float</dt><dd><p>The approximation discrepancy. That is, the difference between the
true correlation function of the Drude-Lorentz bath and the sum of
the <code class="docutils literal notranslate"><span class="pre">Nk</span></code> exponential terms is approximately <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">delta</span> <span class="pre">*</span>
<span class="pre">dirac(t)</span></code>, where <code class="docutils literal notranslate"><span class="pre">dirac(t)</span></code> denotes the Dirac delta function.</p>
</dd>
<dt><strong>terminator</strong><span class="classifier">Qobj</span></dt><dd><p>The Matsubara terminator – i.e. a liouvillian term representing
the contribution to the system-bath dynamics of all exponential
expansion terms beyond <code class="docutils literal notranslate"><span class="pre">Nk</span></code>. It should be used by adding it to
the system liouvillian (i.e. <code class="docutils literal notranslate"><span class="pre">liouvillian(H_sys)</span></code>).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.DrudeLorentzPadeBath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">DrudeLorentzPadeBath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_baths.html#DrudeLorentzPadeBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.DrudeLorentzPadeBath" title="Permalink to this definition"></a></dt>
<dd><p>A helper class for constructing a Padé expansion for a Drude-Lorentz
bosonic bath from the bath parameters (see parameters below).</p>
<p>A Padé approximant is a sum-over-poles expansion (
see <a class="reference external" href="https://en.wikipedia.org/wiki/Pad%C3%A9_approximant">https://en.wikipedia.org/wiki/Pad%C3%A9_approximant</a>).</p>
<p>The application of the Padé method to spectrum decompoisitions is described
in “Padé spectrum decompositions of quantum distribution functions and
optimal hierarchical equations of motion construction for quantum open
systems” [1].</p>
<p>The implementation here follows the approach in the paper.</p>
<p>[1] J. Chem. Phys. 134, 244106 (2011); <a class="reference external" href="https://doi.org/10.1063/1.3602466">https://doi.org/10.1063/1.3602466</a></p>
<p>This is an alternative to the <a class="reference internal" href="#qutip.solver.heom.DrudeLorentzBath" title="qutip.solver.heom.DrudeLorentzBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">DrudeLorentzBath</span></code></a> which constructs
a simpler exponential expansion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.</p>
</dd>
<dt><strong>lam</strong><span class="classifier">float</span></dt><dd><p>Coupling strength.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>Bath spectral density cutoff frequency.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>Bath temperature.</p>
</dd>
<dt><strong>Nk</strong><span class="classifier">int</span></dt><dd><p>Number of Padé exponentials terms used to approximate the bath
correlation functions.</p>
</dd>
<dt><strong>combine</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to combine exponents with the same frequency (and coupling
operator). See <a class="reference internal" href="#qutip.solver.heom.BosonicBath.combine" title="qutip.solver.heom.BosonicBath.combine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BosonicBath.combine</span></code></a> for details.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.heom.DrudeLorentzPadeBath.terminator">
<span class="sig-name descname"><span class="pre">terminator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_baths.html#DrudeLorentzPadeBath.terminator"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.DrudeLorentzPadeBath.terminator" title="Permalink to this definition"></a></dt>
<dd><p>Return the Padé terminator for the bath and the calculated
approximation discrepancy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>delta: float</dt><dd><p>The approximation discrepancy. That is, the difference between the
true correlation function of the Drude-Lorentz bath and the sum of
the <code class="docutils literal notranslate"><span class="pre">Nk</span></code> exponential terms is approximately <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">delta</span> <span class="pre">*</span>
<span class="pre">dirac(t)</span></code>, where <code class="docutils literal notranslate"><span class="pre">dirac(t)</span></code> denotes the Dirac delta function.</p>
</dd>
<dt><strong>terminator</strong><span class="classifier">Qobj</span></dt><dd><p>The Padé terminator – i.e. a liouvillian term representing
the contribution to the system-bath dynamics of all exponential
expansion terms beyond <code class="docutils literal notranslate"><span class="pre">Nk</span></code>. It should be used by adding it to
the system liouvillian (i.e. <code class="docutils literal notranslate"><span class="pre">liouvillian(H_sys)</span></code>).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.UnderDampedBath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">UnderDampedBath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_baths.html#UnderDampedBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.UnderDampedBath" title="Permalink to this definition"></a></dt>
<dd><p>A helper class for constructing an under-damped bosonic bath from the
bath parameters (see parameters below).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.</p>
</dd>
<dt><strong>lam</strong><span class="classifier">float</span></dt><dd><p>Coupling strength.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>Bath spectral density cutoff frequency.</p>
</dd>
<dt><strong>w0</strong><span class="classifier">float</span></dt><dd><p>Bath spectral density resonance frequency.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>Bath temperature.</p>
</dd>
<dt><strong>Nk</strong><span class="classifier">int</span></dt><dd><p>Number of exponential terms used to approximate the bath correlation
functions.</p>
</dd>
<dt><strong>combine</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to combine exponents with the same frequency (and coupling
operator). See <a class="reference internal" href="#qutip.solver.heom.BosonicBath.combine" title="qutip.solver.heom.BosonicBath.combine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">BosonicBath.combine</span></code></a> for details.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.FermionicBath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FermionicBath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ck_plus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vk_plus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ck_minus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vk_minus</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_baths.html#FermionicBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.FermionicBath" title="Permalink to this definition"></a></dt>
<dd><p>A helper class for constructing a fermionic bath from the expansion
coefficients and frequencies for the <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code> modes of
the bath correlation function.</p>
<p>There must be the same number of <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">-</span></code> modes and their
coefficients must be specified in the same order so that <code class="docutils literal notranslate"><span class="pre">ck_plus[i],</span>
<span class="pre">vk_plus[i]</span></code> are the plus coefficient and frequency corresponding
to the minus mode <code class="docutils literal notranslate"><span class="pre">ck_minus[i],</span> <span class="pre">vk_minus[i]</span></code>.</p>
<p>In the fermionic case the order in which excitations are created or
destroyed is important, resulting in two different correlation functions
labelled <code class="docutils literal notranslate"><span class="pre">C_plus(t)</span></code> and <code class="docutils literal notranslate"><span class="pre">C_plus(t)</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C_plus</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ck_plus</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">vk_plus</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
<span class="n">C_minus</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ck_minus</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">vk_minus</span> <span class="o">*</span> <span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
<p>where the expansions above define the coeffiients <code class="docutils literal notranslate"><span class="pre">ck</span></code> and the
frequencies <code class="docutils literal notranslate"><span class="pre">vk</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>The coupling operator for the bath.</p>
</dd>
<dt><strong>ck_plus</strong><span class="classifier">list of complex</span></dt><dd><p>The coefficients of the expansion terms for the <code class="docutils literal notranslate"><span class="pre">+</span></code> part of the
correlation function. The corresponding frequencies are passed as
vk_plus.</p>
</dd>
<dt><strong>vk_plus</strong><span class="classifier">list of complex</span></dt><dd><p>The frequencies (exponents) of the expansion terms for the <code class="docutils literal notranslate"><span class="pre">+</span></code> part
of the correlation function. The corresponding ceofficients are passed
as ck_plus.</p>
</dd>
<dt><strong>ck_minus</strong><span class="classifier">list of complex</span></dt><dd><p>The coefficients of the expansion terms for the <code class="docutils literal notranslate"><span class="pre">-</span></code> part of the
correlation function. The corresponding frequencies are passed as
vk_minus.</p>
</dd>
<dt><strong>vk_minus</strong><span class="classifier">list of complex</span></dt><dd><p>The frequencies (exponents) of the expansion terms for the <code class="docutils literal notranslate"><span class="pre">-</span></code> part
of the correlation function. The corresponding ceofficients are passed
as ck_minus.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.LorentzianBath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LorentzianBath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_baths.html#LorentzianBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.LorentzianBath" title="Permalink to this definition"></a></dt>
<dd><p>A helper class for constructing a Lorentzian fermionic bath from the
bath parameters (see parameters below).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This Matsubara expansion used in this bath converges very slowly
and <code class="docutils literal notranslate"><span class="pre">Nk</span> <span class="pre">&gt;</span> <span class="pre">20</span></code> may be required to get good convergence. The
Padé expansion used by <a class="reference internal" href="#qutip.solver.heom.LorentzianPadeBath" title="qutip.solver.heom.LorentzianPadeBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">LorentzianPadeBath</span></code></a> converges much
more quickly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>The coupling strength between the system and the bath.</p>
</dd>
<dt><strong>w</strong><span class="classifier">float</span></dt><dd><p>The width of the environment.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float</span></dt><dd><p>The chemical potential of the bath.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>Bath temperature.</p>
</dd>
<dt><strong>Nk</strong><span class="classifier">int</span></dt><dd><p>Number of exponential terms used to approximate the bath correlation
functions.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.LorentzianPadeBath">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LorentzianPadeBath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_baths.html#LorentzianPadeBath"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.LorentzianPadeBath" title="Permalink to this definition"></a></dt>
<dd><p>A helper class for constructing a Padé expansion for Lorentzian fermionic
bath from the bath parameters (see parameters below).</p>
<p>A Padé approximant is a sum-over-poles expansion (
see <a class="reference external" href="https://en.wikipedia.org/wiki/Pad%C3%A9_approximant">https://en.wikipedia.org/wiki/Pad%C3%A9_approximant</a>).</p>
<p>The application of the Padé method to spectrum decompoisitions is described
in “Padé spectrum decompositions of quantum distribution functions and
optimal hierarchical equations of motion construction for quantum open
systems” [1].</p>
<p>The implementation here follows the approach in the paper.</p>
<p>[1] J. Chem. Phys. 134, 244106 (2011); <a class="reference external" href="https://doi.org/10.1063/1.3602466">https://doi.org/10.1063/1.3602466</a></p>
<p>This is an alternative to the <a class="reference internal" href="#qutip.solver.heom.LorentzianBath" title="qutip.solver.heom.LorentzianBath"><code class="xref py py-class docutils literal notranslate"><span class="pre">LorentzianBath</span></code></a> which constructs
a simpler exponential expansion that converges much more slowly in
this particular case.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">Qobj</span></dt><dd><p>Operator describing the coupling between system and bath.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float</span></dt><dd><p>The coupling strength between the system and the bath.</p>
</dd>
<dt><strong>w</strong><span class="classifier">float</span></dt><dd><p>The width of the environment.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">float</span></dt><dd><p>The chemical potential of the bath.</p>
</dd>
<dt><strong>T</strong><span class="classifier">float</span></dt><dd><p>Bath temperature.</p>
</dd>
<dt><strong>Nk</strong><span class="classifier">int</span></dt><dd><p>Number of exponential terms used to approximate the bath correlation
functions.</p>
</dd>
<dt><strong>tag</strong><span class="classifier">optional, str, tuple or any other object</span></dt><dd><p>A label for the bath exponents (for example, the name of the
bath). It defaults to None but can be set to help identify which
bath an exponent is from.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.HierarchyADOs">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HierarchyADOs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exponents</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HierarchyADOs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HierarchyADOs" title="Permalink to this definition"></a></dt>
<dd><p>A description of ADOs (auxilliary density operators) with the
hierarchical equations of motion.</p>
<p>The list of ADOs is constructed from a list of bath exponents
(corresponding to one or more baths). Each ADO is referred to by a label
that lists the number of “excitations” of each bath exponent. The
level of a label within the hierarchy is the sum of the “excitations”
within the label.</p>
<p>For example the label <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">...,</span> <span class="pre">0)</span></code> represents the density matrix
of the system being solved and is the only 0th level label.</p>
<p>The labels with a single 1, i.e. <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">0,</span> <span class="pre">...,</span> <span class="pre">0)</span></code>, <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">...</span> <span class="pre">0)</span></code>,
etc. are the 1st level labels.</p>
<p>The second level labels all have either two 1s or a single 2, and so on
for the third and higher levels of the hierarchy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>exponents</strong><span class="classifier">list of BathExponent</span></dt><dd><p>The exponents of the correlation function describing the bath or
baths.</p>
</dd>
<dt><strong>max_depth</strong><span class="classifier">int</span></dt><dd><p>The maximum depth of the hierarchy (i.e. the maximum sum of
“excitations” in the hierarchy ADO labels or maximum ADO level).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>exponents</strong><span class="classifier">list of BathExponent</span></dt><dd><p>The exponents of the correlation function describing the bath or
baths.</p>
</dd>
<dt><strong>max_depth</strong><span class="classifier">int</span></dt><dd><p>The maximum depth of the hierarchy (i.e. the maximum sum of
“excitations” in the hierarchy ADO labels).</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list of int</span></dt><dd><p>The dimensions of each exponent within the bath(s).</p>
</dd>
<dt><strong>vk</strong><span class="classifier">list of complex</span></dt><dd><p>The frequency of each exponent within the bath(s).</p>
</dd>
<dt><strong>ck</strong><span class="classifier">list of complex</span></dt><dd><p>The coefficient of each exponent within the bath(s).</p>
</dd>
<dt><strong>ck2: list of complex</strong></dt><dd><p>For exponents of type “RI”, the coefficient of the exponent within
the imaginary expansion. For other exponent types, the entry is None.</p>
</dd>
<dt><strong>sigma_bar_k_offset: list of int</strong></dt><dd><p>For exponents of type “+” or “-” the offset within the list of modes
of the corresponding “-” or “+” exponent. For other exponent types,
the entry is None.</p>
</dd>
<dt><strong>labels: list of tuples</strong></dt><dd><p>A list of the ADO labels within the hierarchy.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.heom.HierarchyADOs.exps">
<span class="sig-name descname"><span class="pre">exps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HierarchyADOs.exps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HierarchyADOs.exps" title="Permalink to this definition"></a></dt>
<dd><p>Converts an ADO label into a tuple of exponents, with one exponent
for each “excitation” within the label.</p>
<p>The number of exponents returned is always equal to the level of the
label within the hierarchy (i.e. the sum of the indices within the
label).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">tuple</span></dt><dd><p>The ADO label to convert to a list of exponents.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>tuple of BathExponent</dt><dd><p>A tuple of BathExponents.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p><code class="docutils literal notranslate"><span class="pre">ados.exps((1,</span> <span class="pre">0,</span> <span class="pre">0))</span></code> would return <code class="docutils literal notranslate"><span class="pre">[ados.exponents[0]]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">ados.exps((2,</span> <span class="pre">0,</span> <span class="pre">0))</span></code> would return
<code class="docutils literal notranslate"><span class="pre">[ados.exponents[0],</span> <span class="pre">ados.exponents[0]]</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ados.exps((1,</span> <span class="pre">2,</span> <span class="pre">1))</span></code> would return
<code class="docutils literal notranslate"><span class="pre">[ados.exponents[0],</span> <span class="pre">ados.exponents[1],</span> <span class="pre">ados.exponents[1],</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">ados.exponents[2]]</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.heom.HierarchyADOs.filter">
<span class="sig-name descname"><span class="pre">filter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tags</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HierarchyADOs.filter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HierarchyADOs.filter" title="Permalink to this definition"></a></dt>
<dd><p>Return a list of ADO labels for ADOs whose “excitations”
match the given patterns.</p>
<p>Each of the filter parameters (tags, dims, types) may be either
unspecified (None) or a list. Unspecified parameters are excluded
from the filtering.</p>
<p>All specified filter parameters must be lists of the same length.
Each position in the lists describes a particular excitation and
any exponent that matches the filters may supply that excitation.
The level of all labels returned is thus equal to the length of
the filter parameter lists.</p>
<p>Within a filter parameter list, items that are None represent
wildcards and match any value of that exponent attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int</span></dt><dd><p>The hierarchy depth to return ADOs from.</p>
</dd>
<dt><strong>tags</strong><span class="classifier">list of object or None</span></dt><dd><p>Filter parameter that matches the <code class="docutils literal notranslate"><span class="pre">.tag</span></code> attribute of
exponents.</p>
</dd>
<dt><strong>dims</strong><span class="classifier">list of int</span></dt><dd><p>Filter parameter that matches the <code class="docutils literal notranslate"><span class="pre">.dim</span></code> attribute of
exponents.</p>
</dd>
<dt><strong>types</strong><span class="classifier">list of BathExponent types or list of str</span></dt><dd><p>Filter parameter that matches the <code class="docutils literal notranslate"><span class="pre">.type</span></code> attribute
of exponents. Types may be supplied by name (e.g. “R”, “I”, “+”)
instead of by the actual type (e.g. <code class="docutils literal notranslate"><span class="pre">BathExponent.types.R</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>list of tuple</dt><dd><p>The ADO label for each ADO whose exponent excitations
(i.e. label) match the given filters or level.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.heom.HierarchyADOs.idx">
<span class="sig-name descname"><span class="pre">idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HierarchyADOs.idx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HierarchyADOs.idx" title="Permalink to this definition"></a></dt>
<dd><p>Return the index of the ADO label within the list of labels,
i.e. within <code class="docutils literal notranslate"><span class="pre">self.labels</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">tuple</span></dt><dd><p>The label to look up.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>The index of the label within the list of ADO labels.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This implementation of the <code class="docutils literal notranslate"><span class="pre">.idx(...)</span></code> method is just for
reference and documentation. To avoid the cost of a Python
function call, it is replaced with
<code class="docutils literal notranslate"><span class="pre">self._label_idx.__getitem__</span></code> when the instance is created.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.heom.HierarchyADOs.next">
<span class="sig-name descname"><span class="pre">next</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HierarchyADOs.next"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HierarchyADOs.next" title="Permalink to this definition"></a></dt>
<dd><p>Return the ADO label with one more excitation in the k’th exponent
dimension or <code class="docutils literal notranslate"><span class="pre">None</span></code> if adding the excitation would exceed the
dimension or maximum depth of the hierarchy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">tuple</span></dt><dd><p>The ADO label to add an excitation to.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The exponent to add the excitation to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>tuple or None</dt><dd><p>The next label.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.heom.HierarchyADOs.prev">
<span class="sig-name descname"><span class="pre">prev</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HierarchyADOs.prev"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HierarchyADOs.prev" title="Permalink to this definition"></a></dt>
<dd><p>Return the ADO label with one fewer excitation in the k’th
exponent dimension or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the label has no exciations in the
k’th exponent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">tuple</span></dt><dd><p>The ADO label to remove the excitation from.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The exponent to remove the excitation from.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>tuple or None</dt><dd><p>The previous label.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.HierarchyADOsState">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HierarchyADOsState</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ados</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ado_state</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HierarchyADOsState"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HierarchyADOsState" title="Permalink to this definition"></a></dt>
<dd><p>Provides convenient access to the full hierarchy ADO state at a particular
point in time, <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The current state of the system (i.e. the 0th component of the
hierarchy).</p>
</dd>
<dt><strong>ados</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.heom.HierarchyADOs" title="qutip.solver.heom.HierarchyADOs"><code class="xref py py-class docutils literal notranslate"><span class="pre">HierarchyADOs</span></code></a></span></dt><dd><p>The description of the hierarchy.</p>
</dd>
<dt><strong>ado_state</strong><span class="classifier">numpy.array</span></dt><dd><p>The full state of the hierarchy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rho</strong><span class="classifier">Qobj</span></dt><dd><p>The system state.</p>
</dd>
<dt><strong>In addition, all of the attributes of the hierarchy description,</strong></dt><dd></dd>
<dt><strong>i.e. ``HierarchyADOs``, are provided directly on this class for</strong></dt><dd></dd>
<dt><strong>convenience. E.g. one can access ``.labels``, or ``.exponents`` or</strong></dt><dd></dd>
<dt><strong>call ``.idx(label)`` directly.</strong></dt><dd></dd>
<dt><strong>See :class:`HierarchyADOs` for a full list of the available attributes</strong></dt><dd></dd>
<dt><strong>and methods.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.heom.HierarchyADOsState.extract">
<span class="sig-name descname"><span class="pre">extract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idx_or_label</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HierarchyADOsState.extract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HierarchyADOsState.extract" title="Permalink to this definition"></a></dt>
<dd><p>Extract a Qobj representing the specified ADO from a full
representation of the ADO states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>idx</strong><span class="classifier">int or label</span></dt><dd><p>The index of the ADO to extract. If an ADO label, e.g.
<code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">...)</span></code> is supplied instead, then the ADO
is extracted by label instead.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>Qobj</dt><dd><p>A <code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code> representing the state of the specified ADO.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.heom.HEOMResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">HEOMResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">e_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ResultOptions</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/heom/bofin_solvers.html#HEOMResult"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.heom.HEOMResult" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="stochastic-solver">
<span id="classes-stochastic"></span><h2>Stochastic Solver<a class="headerlink" href="#stochastic-solver" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SMESolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SMESolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">heterodyne</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/stochastic.html#SMESolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.stochastic.SMESolver" title="Permalink to this definition"></a></dt>
<dd><p>Stochastic Master Equation Solver.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> compatible format.</span></dt><dd><p>System Hamiltonian as a Qobj or QobjEvo for time-dependent
Hamiltonians. List of [<a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable
that can be made into <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> are also accepted.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of (<a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> compatible format)</span></dt><dd><p>List of stochastic collapse operators.</p>
</dd>
<dt><strong>heterodyne</strong><span class="classifier">bool, default: False</span></dt><dd><p>Whether to use heterodyne or homodyne detection.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver, see <a class="reference internal" href="#qutip.solver.stochastic.SMESolver.options" title="qutip.solver.stochastic.SMESolver.options"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SMESolver.options</span></code></a> and
<a class="reference external" href="./classes.html#classes-sode">SIntegrator</a> for a list of all options.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SMESolver.ExpectFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ExpectFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.stochastic.SMESolver.ExpectFeedback" title="Permalink to this definition"></a></dt>
<dd><p>Expectation value of the instantaneous state of the evolution to be
used by a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;E0&quot;:</span> <span class="pre">Solver.ExpectFeedback(oper)})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive <code class="docutils literal notranslate"><span class="pre">expect(oper,</span> <span class="pre">state)</span></code> as <code class="docutils literal notranslate"><span class="pre">E0</span></code> during the
evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>operator</strong><span class="classifier">Qobj, QobjEvo</span></dt><dd><p>Operator to compute the expectation values of.</p>
</dd>
<dt><strong>default</strong><span class="classifier">float, default</span><span class="classifier">0.</span></dt><dd><p>Initial value to be used at setup.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SMESolver.StateFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">StateFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raw_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.stochastic.SMESolver.StateFeedback" title="Permalink to this definition"></a></dt>
<dd><p>State of the evolution to be used in a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;state&quot;:</span> <span class="pre">SMESolver.StateFeedback()})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive the density matrix as <code class="docutils literal notranslate"><span class="pre">state</span></code> during the
evolution.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Not supported by the <code class="docutils literal notranslate"><span class="pre">rouchon</span></code> mehtod.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default</strong><span class="classifier">Qobj or qutip.core.data.Data, default</span><span class="classifier">None</span></dt><dd><p>Initial value to be used at setup of the system.</p>
</dd>
<dt><strong>raw_data</strong><span class="classifier">bool, default</span><span class="classifier">False</span></dt><dd><p>If True, the raw matrix will be passed instead of a Qobj.
For density matrices, the matrices can be column stacked or square
depending on the integration method.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SMESolver.WeinerFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">WeinerFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.stochastic.SMESolver.WeinerFeedback" title="Permalink to this definition"></a></dt>
<dd><p>Weiner function of the trajectory argument for time dependent systems.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;W&quot;:</span> <span class="pre">SMESolver.WeinerFeedback()})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive a function as <code class="docutils literal notranslate"><span class="pre">W</span></code> that return an array of
wiener processes values at <code class="docutils literal notranslate"><span class="pre">t</span></code>. The wiener process for the i-th
sc_ops is the i-th element for homodyne detection and the (2i, 2i+1)
pairs of process in heterodyne detection. The process is a step
function with step of length <code class="docutils literal notranslate"><span class="pre">options[&quot;dt&quot;]</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>WeinerFeedback can’t be added to a running solver when updating
arguments between steps: <code class="docutils literal notranslate"><span class="pre">solver.step(...,</span> <span class="pre">args={})</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default</strong><span class="classifier">callable, optional</span></dt><dd><p>Default function used outside the solver.
When not passed, a function returning <code class="docutils literal notranslate"><span class="pre">np.array([0])</span></code> is used.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SMESolver.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.stochastic.SMESolver.options" title="Permalink to this definition"></a></dt>
<dd><p>Options for stochastic solver:</p>
<dl class="simple">
<dt>store_final_state: bool, default: False</dt><dd><p>Whether or not to store the final state of the evolution in the
result class.</p>
</dd>
<dt>store_states: None, bool, default: None</dt><dd><p>Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p>
</dd>
<dt>store_measurement: bool, default: False</dt><dd><p>Whether to store the measurement for each trajectories.
Storing measurements will also store the wiener process, or
brownian noise for each trajectories.</p>
</dd>
<dt>progress_bar: str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}, default: “text”</dt><dd><p>How to present the solver progress. ‘tqdm’ uses the python module
of the same name and raise an error if not installed. Empty string
or False will disable the bar.</p>
</dd>
<dt>progress_kwargs: dict, default: {“chunk_size”:10}</dt><dd><p>Arguments to pass to the progress_bar. Qutip’s bars use
<code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>.</p>
</dd>
<dt>keep_runs_results: bool, default: False</dt><dd><p>Whether to store results from all trajectories or just store the
averages.</p>
</dd>
<dt>normalize_output: bool</dt><dd><p>Normalize output state to hide ODE numerical errors.</p>
</dd>
<dt>method: str, default: “platen”</dt><dd><p>Which differential equation integration method to use.</p>
</dd>
<dt>map: str {“serial”, “parallel”, “loky”, “mpi”}, default: “serial”</dt><dd><p>How to run the trajectories. “parallel” uses the multiprocessing
module to run in parallel while “loky” and “mpi” use the “loky” and
“mpi4py” modules to do so.</p>
</dd>
<dt>mpi_options: dict, default: {}</dt><dd><p>Only applies if map is “mpi”. This dictionary will be passed as
keyword arguments to the <cite>mpi4py.futures.MPIPoolExecutor</cite>
constructor. Note that the <cite>max_workers</cite> argument is provided
separately through the <cite>num_cpus</cite> option.</p>
</dd>
<dt>num_cpus: None, int, default: None</dt><dd><p>Number of cpus to use when running in parallel. <code class="docutils literal notranslate"><span class="pre">None</span></code> detect the
number of available cpus.</p>
</dd>
<dt>bitgenerator: {None, “MT19937”, “PCG64DXSM”, …}, default: None</dt><dd><p>Which of numpy.random’s bitgenerator to use. With <code class="docutils literal notranslate"><span class="pre">None</span></code>, your
numpy version’s default is used.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SMESolver.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seeds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.stochastic.SMESolver.run" title="Permalink to this definition"></a></dt>
<dd><p>Do the evolution of the Quantum system.</p>
<p>For a <code class="docutils literal notranslate"><span class="pre">state</span></code> at time <code class="docutils literal notranslate"><span class="pre">tlist[0]</span></code> do the evolution as directed by
<code class="docutils literal notranslate"><span class="pre">rhs</span></code> and for each time in <code class="docutils literal notranslate"><span class="pre">tlist</span></code> store the state and/or
expectation values in a <a class="reference internal" href="#qutip.solver.result.Result" title="qutip.solver.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>. The evolution method and
stored results are determined by <code class="docutils literal notranslate"><span class="pre">options</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list of double</span></dt><dd><p>Time for which to save the results (state and/or expect) of the
evolution. The first element of the list is the initial time of the
evolution. Time in the list must be in increasing order, but does
not need to be uniformly distributed.</p>
</dd>
<dt><strong>ntraj</strong><span class="classifier">int</span></dt><dd><p>Number of trajectories to add.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional</span></dt><dd><p>Change the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the rhs for the evolution.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list</span></dt><dd><p>list of Qobj or QobjEvo to compute the expectation values.
Alternatively, function[s] with the signature f(t, state) -&gt; expect
can be used.</p>
</dd>
<dt><strong>timeout</strong><span class="classifier">float, optional</span></dt><dd><p>Maximum time in seconds for the trajectories to run. Once this time
is reached, the simulation will end even if the number
of trajectories is less than <code class="docutils literal notranslate"><span class="pre">ntraj</span></code>. The map function, set in
options, can interupt the running trajectory or wait for it to
finish. Set to an arbitrary high number to disable.</p>
</dd>
<dt><strong>target_tol</strong><span class="classifier">{float, tuple, list}, optional</span></dt><dd><p>Target tolerance of the evolution. The evolution will compute
trajectories until the error on the expectation values is lower
than this tolerance. The maximum number of trajectories employed is
given by <code class="docutils literal notranslate"><span class="pre">ntraj</span></code>. The error is computed using jackknife
resampling. <code class="docutils literal notranslate"><span class="pre">target_tol</span></code> can be an absolute tolerance or a pair
of absolute and relative tolerance, in that order. Lastly, it can
be a list of pairs of (atol, rtol) for each e_ops.</p>
</dd>
<dt><strong>seeds</strong><span class="classifier">{int, SeedSequence, list}, optional</span></dt><dd><p>Seed or list of seeds for each trajectories.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.result.MultiTrajResult" title="qutip.solver.result.MultiTrajResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiTrajResult</span></code></a></span></dt><dd><p>Results of the evolution. States and/or expect will be saved. You
can control the saved data in the options.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SMESolver.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.stochastic.SMESolver.start" title="Permalink to this definition"></a></dt>
<dd><p>Set the initial state and time for a step evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>t0</strong><span class="classifier">double</span></dt><dd><p>Initial time of the evolution.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, SeedSequence, list, optional</span></dt><dd><p>Seed for the random number generator. It can be a single seed used
to spawn seeds for each trajectory or a list of seed, one for each
trajectory.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When using step evolution, only one trajectory can be computed at once.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SMESolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.stochastic.SMESolver.step" title="Permalink to this definition"></a></dt>
<dd><p>Evolve the state to <code class="docutils literal notranslate"><span class="pre">t</span></code> and return the state as a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">double</span></dt><dd><p>Time to evolve to, must be higher than the last call.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional</span></dt><dd><p>Update the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the system.
The change is effective from the beginning of the interval.
Changing <code class="docutils literal notranslate"><span class="pre">args</span></code> can slow the evolution.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default: True</span></dt><dd><p>Whether to return a copy of the data or the data in the ODE solver.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SMESolver.sys_dims">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sys_dims</span></span><a class="headerlink" href="#qutip.solver.stochastic.SMESolver.sys_dims" title="Permalink to this definition"></a></dt>
<dd><p>Dimensions of the space that the system use:</p>
<p><code class="docutils literal notranslate"><span class="pre">qutip.basis(sovler.dims)</span></code> will create a state with proper dimensions
for this solver.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SSESolver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">SSESolver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">heterodyne</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/stochastic.html#SSESolver"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.stochastic.SSESolver" title="Permalink to this definition"></a></dt>
<dd><p>Stochastic Schrodinger Equation Solver.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>H</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> compatible format.</span></dt><dd><p>System Hamiltonian as a Qobj or QobjEvo for time-dependent
Hamiltonians. List of [<a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Coefficient</span></code>] or callable
that can be made into <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> are also accepted.</p>
</dd>
<dt><strong>c_ops</strong><span class="classifier">list of (<a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> compatible format)</span></dt><dd><p>Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</dd>
<dt><strong>sc_ops</strong><span class="classifier">list of (<a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> compatible format)</span></dt><dd><p>List of stochastic collapse operators.</p>
</dd>
<dt><strong>heterodyne</strong><span class="classifier">bool, default: False</span></dt><dd><p>Whether to use heterodyne or homodyne detection.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict, optional</span></dt><dd><p>Options for the solver, see <a class="reference internal" href="#qutip.solver.stochastic.SSESolver.options" title="qutip.solver.stochastic.SSESolver.options"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SSESolver.options</span></code></a> and
<a class="reference external" href="./classes.html#classes-sode">SIntegrator</a> for a list of all options.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SSESolver.ExpectFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ExpectFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.stochastic.SSESolver.ExpectFeedback" title="Permalink to this definition"></a></dt>
<dd><p>Expectation value of the instantaneous state of the evolution to be
used by a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;E0&quot;:</span> <span class="pre">Solver.ExpectFeedback(oper)})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive <code class="docutils literal notranslate"><span class="pre">expect(oper,</span> <span class="pre">state)</span></code> as <code class="docutils literal notranslate"><span class="pre">E0</span></code> during the
evolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>operator</strong><span class="classifier">Qobj, QobjEvo</span></dt><dd><p>Operator to compute the expectation values of.</p>
</dd>
<dt><strong>default</strong><span class="classifier">float, default</span><span class="classifier">0.</span></dt><dd><p>Initial value to be used at setup.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SSESolver.StateFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">StateFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">raw_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.stochastic.SSESolver.StateFeedback" title="Permalink to this definition"></a></dt>
<dd><p>State of the evolution to be used in a time-dependent operator.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;state&quot;:</span> <span class="pre">SMESolver.StateFeedback()})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive the density matrix as <code class="docutils literal notranslate"><span class="pre">state</span></code> during the
evolution.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Not supported by the <code class="docutils literal notranslate"><span class="pre">rouchon</span></code> mehtod.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default</strong><span class="classifier">Qobj or qutip.core.data.Data, default</span><span class="classifier">None</span></dt><dd><p>Initial value to be used at setup of the system.</p>
</dd>
<dt><strong>raw_data</strong><span class="classifier">bool, default</span><span class="classifier">False</span></dt><dd><p>If True, the raw matrix will be passed instead of a Qobj.
For density matrices, the matrices can be column stacked or square
depending on the integration method.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SSESolver.WeinerFeedback">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">WeinerFeedback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">default</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.stochastic.SSESolver.WeinerFeedback" title="Permalink to this definition"></a></dt>
<dd><p>Weiner function of the trajectory argument for time dependent systems.</p>
<p>When used as an args:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">QobjEvo([op,</span> <span class="pre">func],</span> <span class="pre">args={&quot;W&quot;:</span> <span class="pre">SMESolver.WeinerFeedback()})</span></code></p>
</div></blockquote>
<p>The <code class="docutils literal notranslate"><span class="pre">func</span></code> will receive a function as <code class="docutils literal notranslate"><span class="pre">W</span></code> that return an array of
wiener processes values at <code class="docutils literal notranslate"><span class="pre">t</span></code>. The wiener process for the i-th
sc_ops is the i-th element for homodyne detection and the (2i, 2i+1)
pairs of process in heterodyne detection. The process is a step
function with step of length <code class="docutils literal notranslate"><span class="pre">options[&quot;dt&quot;]</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>WeinerFeedback can’t be added to a running solver when updating
arguments between steps: <code class="docutils literal notranslate"><span class="pre">solver.step(...,</span> <span class="pre">args={})</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>default</strong><span class="classifier">callable, optional</span></dt><dd><p>Default function used outside the solver.
When not passed, a function returning <code class="docutils literal notranslate"><span class="pre">np.array([0])</span></code> is used.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SSESolver.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.stochastic.SSESolver.options" title="Permalink to this definition"></a></dt>
<dd><p>Options for stochastic solver:</p>
<dl class="simple">
<dt>store_final_state: bool, default: False</dt><dd><p>Whether or not to store the final state of the evolution in the
result class.</p>
</dd>
<dt>store_states: None, bool, default: None</dt><dd><p>Whether or not to store the state vectors or density matrices.
On <cite>None</cite> the states will be saved if no expectation operators are
given.</p>
</dd>
<dt>store_measurement: bool, default: False</dt><dd><p>Whether to store the measurement for each trajectories.
Storing measurements will also store the wiener process, or
brownian noise for each trajectories.</p>
</dd>
<dt>progress_bar: str {‘text’, ‘enhanced’, ‘tqdm’, ‘’}, default: “text”</dt><dd><p>How to present the solver progress. ‘tqdm’ uses the python module
of the same name and raise an error if not installed. Empty string
or False will disable the bar.</p>
</dd>
<dt>progress_kwargs: dict, default: {“chunk_size”:10}</dt><dd><p>Arguments to pass to the progress_bar. Qutip’s bars use
<code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>.</p>
</dd>
<dt>keep_runs_results: bool, default: False</dt><dd><p>Whether to store results from all trajectories or just store the
averages.</p>
</dd>
<dt>normalize_output: bool</dt><dd><p>Normalize output state to hide ODE numerical errors.</p>
</dd>
<dt>method: str, default: “platen”</dt><dd><p>Which differential equation integration method to use.</p>
</dd>
<dt>map: str {“serial”, “parallel”, “loky”, “mpi”}, default: “serial”</dt><dd><p>How to run the trajectories. “parallel” uses the multiprocessing
module to run in parallel while “loky” and “mpi” use the “loky” and
“mpi4py” modules to do so.</p>
</dd>
<dt>mpi_options: dict, default: {}</dt><dd><p>Only applies if map is “mpi”. This dictionary will be passed as
keyword arguments to the <cite>mpi4py.futures.MPIPoolExecutor</cite>
constructor. Note that the <cite>max_workers</cite> argument is provided
separately through the <cite>num_cpus</cite> option.</p>
</dd>
<dt>num_cpus: None, int, default: None</dt><dd><p>Number of cpus to use when running in parallel. <code class="docutils literal notranslate"><span class="pre">None</span></code> detect the
number of available cpus.</p>
</dd>
<dt>bitgenerator: {None, “MT19937”, “PCG64DXSM”, …}, default: None</dt><dd><p>Which of numpy.random’s bitgenerator to use. With <code class="docutils literal notranslate"><span class="pre">None</span></code>, your
numpy version’s default is used.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SSESolver.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seeds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.stochastic.SSESolver.run" title="Permalink to this definition"></a></dt>
<dd><p>Do the evolution of the Quantum system.</p>
<p>For a <code class="docutils literal notranslate"><span class="pre">state</span></code> at time <code class="docutils literal notranslate"><span class="pre">tlist[0]</span></code> do the evolution as directed by
<code class="docutils literal notranslate"><span class="pre">rhs</span></code> and for each time in <code class="docutils literal notranslate"><span class="pre">tlist</span></code> store the state and/or
expectation values in a <a class="reference internal" href="#qutip.solver.result.Result" title="qutip.solver.result.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a>. The evolution method and
stored results are determined by <code class="docutils literal notranslate"><span class="pre">options</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>tlist</strong><span class="classifier">list of double</span></dt><dd><p>Time for which to save the results (state and/or expect) of the
evolution. The first element of the list is the initial time of the
evolution. Time in the list must be in increasing order, but does
not need to be uniformly distributed.</p>
</dd>
<dt><strong>ntraj</strong><span class="classifier">int</span></dt><dd><p>Number of trajectories to add.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional</span></dt><dd><p>Change the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the rhs for the evolution.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">list</span></dt><dd><p>list of Qobj or QobjEvo to compute the expectation values.
Alternatively, function[s] with the signature f(t, state) -&gt; expect
can be used.</p>
</dd>
<dt><strong>timeout</strong><span class="classifier">float, optional</span></dt><dd><p>Maximum time in seconds for the trajectories to run. Once this time
is reached, the simulation will end even if the number
of trajectories is less than <code class="docutils literal notranslate"><span class="pre">ntraj</span></code>. The map function, set in
options, can interupt the running trajectory or wait for it to
finish. Set to an arbitrary high number to disable.</p>
</dd>
<dt><strong>target_tol</strong><span class="classifier">{float, tuple, list}, optional</span></dt><dd><p>Target tolerance of the evolution. The evolution will compute
trajectories until the error on the expectation values is lower
than this tolerance. The maximum number of trajectories employed is
given by <code class="docutils literal notranslate"><span class="pre">ntraj</span></code>. The error is computed using jackknife
resampling. <code class="docutils literal notranslate"><span class="pre">target_tol</span></code> can be an absolute tolerance or a pair
of absolute and relative tolerance, in that order. Lastly, it can
be a list of pairs of (atol, rtol) for each e_ops.</p>
</dd>
<dt><strong>seeds</strong><span class="classifier">{int, SeedSequence, list}, optional</span></dt><dd><p>Seed or list of seeds for each trajectories.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>results</strong><span class="classifier"><a class="reference internal" href="#qutip.solver.result.MultiTrajResult" title="qutip.solver.result.MultiTrajResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiTrajResult</span></code></a></span></dt><dd><p>Results of the evolution. States and/or expect will be saved. You
can control the saved data in the options.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SSESolver.start">
<span class="sig-name descname"><span class="pre">start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.stochastic.SSESolver.start" title="Permalink to this definition"></a></dt>
<dd><p>Set the initial state and time for a step evolution.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>state</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>Initial state of the evolution.</p>
</dd>
<dt><strong>t0</strong><span class="classifier">double</span></dt><dd><p>Initial time of the evolution.</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, SeedSequence, list, optional</span></dt><dd><p>Seed for the random number generator. It can be a single seed used
to spawn seeds for each trajectory or a list of seed, one for each
trajectory.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When using step evolution, only one trajectory can be computed at once.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SSESolver.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.stochastic.SSESolver.step" title="Permalink to this definition"></a></dt>
<dd><p>Evolve the state to <code class="docutils literal notranslate"><span class="pre">t</span></code> and return the state as a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">double</span></dt><dd><p>Time to evolve to, must be higher than the last call.</p>
</dd>
<dt><strong>args</strong><span class="classifier">dict, optional</span></dt><dd><p>Update the <code class="docutils literal notranslate"><span class="pre">args</span></code> of the system.
The change is effective from the beginning of the interval.
Changing <code class="docutils literal notranslate"><span class="pre">args</span></code> can slow the evolution.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default: True</span></dt><dd><p>Whether to return a copy of the data or the data in the ODE solver.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.stochastic.SSESolver.sys_dims">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sys_dims</span></span><a class="headerlink" href="#qutip.solver.stochastic.SSESolver.sys_dims" title="Permalink to this definition"></a></dt>
<dd><p>Dimensions of the space that the system use:</p>
<p><code class="docutils literal notranslate"><span class="pre">qutip.basis(sovler.dims)</span></code> will create a state with proper dimensions
for this solver.</p>
</dd></dl>

</dd></dl>

</section>
<section id="classes-ode">
<span id="id6"></span><h2>Integrator<a class="headerlink" href="#classes-ode" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntegratorScipyAdams</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/integrator/scipy_integrator.html#IntegratorScipyAdams"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams" title="Permalink to this definition"></a></dt>
<dd><p>Integrator using Scipy <cite>ode</cite> with zvode integrator using adams method.
Ordinary Differential Equation solver by netlib
(<a class="reference external" href="https://www.netlib.org/odepack">https://www.netlib.org/odepack</a>).</p>
<p>Usable with <code class="docutils literal notranslate"><span class="pre">method=&quot;adams&quot;</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.integrator.scipy_integrator.IntegratorScipyAdams.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by zvode integrator:</p>
<dl class="simple">
<dt>atol<span class="classifier">float, default: 1e-8</span></dt><dd><p>Absolute tolerance.</p>
</dd>
<dt>rtol<span class="classifier">float, default: 1e-6</span></dt><dd><p>Relative tolerance.</p>
</dd>
<dt>order<span class="classifier">int, default: 12, ‘adams’ or 5, ‘bdf’</span></dt><dd><p>Order of integrator &lt;=12 ‘adams’, &lt;=5 ‘bdf’</p>
</dd>
<dt>nsteps<span class="classifier">int, default: 2500</span></dt><dd><p>Max. number of internal steps/call.</p>
</dd>
<dt>first_step<span class="classifier">float, default: 0</span></dt><dd><p>Size of initial step (0 = automatic).</p>
</dd>
<dt>min_step<span class="classifier">float, default: 0</span></dt><dd><p>Minimum step size (0 = automatic).</p>
</dd>
<dt>max_step<span class="classifier">float, default: 0</span></dt><dd><p>Maximum step size (0 = automatic)
When using pulses, change to half the thinest pulse otherwise it
may be skipped.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntegratorScipyBDF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/integrator/scipy_integrator.html#IntegratorScipyBDF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF" title="Permalink to this definition"></a></dt>
<dd><p>Integrator using Scipy <cite>ode</cite> with zvode integrator using bdf method.
Ordinary Differential Equation solver by netlib
(<a class="reference external" href="https://www.netlib.org/odepack">https://www.netlib.org/odepack</a>).</p>
<p>Usable with <code class="docutils literal notranslate"><span class="pre">method=&quot;bdf&quot;</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.integrator.scipy_integrator.IntegratorScipyBDF.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by zvode integrator:</p>
<dl class="simple">
<dt>atol<span class="classifier">float, default: 1e-8</span></dt><dd><p>Absolute tolerance.</p>
</dd>
<dt>rtol<span class="classifier">float, default: 1e-6</span></dt><dd><p>Relative tolerance.</p>
</dd>
<dt>order<span class="classifier">int, default: 12, ‘adams’ or 5, ‘bdf’</span></dt><dd><p>Order of integrator &lt;=12 ‘adams’, &lt;=5 ‘bdf’</p>
</dd>
<dt>nsteps<span class="classifier">int, default: 2500</span></dt><dd><p>Max. number of internal steps/call.</p>
</dd>
<dt>first_step<span class="classifier">float, default: 0</span></dt><dd><p>Size of initial step (0 = automatic).</p>
</dd>
<dt>min_step<span class="classifier">float, default: 0</span></dt><dd><p>Minimum step size (0 = automatic).</p>
</dd>
<dt>max_step<span class="classifier">float, default: 0</span></dt><dd><p>Maximum step size (0 = automatic)
When using pulses, change to half the thinest pulse otherwise it
may be skipped.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntegratorScipylsoda</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/integrator/scipy_integrator.html#IntegratorScipylsoda"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda" title="Permalink to this definition"></a></dt>
<dd><p>Integrator using Scipy <cite>ode</cite> with lsoda integrator. ODE solver by netlib
(<a class="reference external" href="https://www.netlib.org/odepack">https://www.netlib.org/odepack</a>) Automatically choose between ‘Adams’ and
‘BDF’ methods to solve both stiff and non-stiff systems.</p>
<p>Usable with <code class="docutils literal notranslate"><span class="pre">method=&quot;lsoda&quot;</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.integrator.scipy_integrator.IntegratorScipylsoda.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by lsoda integrator:</p>
<dl class="simple">
<dt>atol<span class="classifier">float, default: 1e-8</span></dt><dd><p>Absolute tolerance.</p>
</dd>
<dt>rtol<span class="classifier">float, default: 1e-6</span></dt><dd><p>Relative tolerance.</p>
</dd>
<dt>nsteps<span class="classifier">int, default: 2500</span></dt><dd><p>Max. number of internal steps/call.</p>
</dd>
<dt>max_order_ns<span class="classifier">int, default: 12</span></dt><dd><p>Maximum order used in the nonstiff case (&lt;= 12).</p>
</dd>
<dt>max_order_s<span class="classifier">int, default: 5</span></dt><dd><p>Maximum order used in the stiff case (&lt;= 5).</p>
</dd>
<dt>first_step<span class="classifier">float, default: 0</span></dt><dd><p>Size of initial step (0 = automatic).</p>
</dd>
<dt>max_step<span class="classifier">float, default: 0</span></dt><dd><p>Maximum step size (0 = automatic)
When using pulses, change to half the thinest pulse otherwise it
may be skipped.</p>
</dd>
<dt>min_step<span class="classifier">float, default: 0</span></dt><dd><p>Minimum step size (0 = automatic)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntegratorScipyDop853</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/integrator/scipy_integrator.html#IntegratorScipyDop853"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853" title="Permalink to this definition"></a></dt>
<dd><p>Integrator using Scipy <cite>ode</cite> with dop853 integrator. Eight order
runge-kutta method by Dormand &amp; Prince. Use fortran implementation
from [E. Hairer, S.P. Norsett and G. Wanner, Solving Ordinary Differential
Equations i. Nonstiff Problems. 2nd edition. Springer Series in
Computational Mathematics, Springer-Verlag (1993)].</p>
<p>Usable with <code class="docutils literal notranslate"><span class="pre">method=&quot;dop853&quot;</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.integrator.scipy_integrator.IntegratorScipyDop853.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by dop853 integrator:</p>
<dl class="simple">
<dt>atol<span class="classifier">float, default: 1e-8</span></dt><dd><p>Absolute tolerance.</p>
</dd>
<dt>rtol<span class="classifier">float, default: 1e-6</span></dt><dd><p>Relative tolerance.</p>
</dd>
<dt>nsteps<span class="classifier">int, default: 2500</span></dt><dd><p>Max. number of internal steps/call.</p>
</dd>
<dt>first_step<span class="classifier">float, default: 0</span></dt><dd><p>Size of initial step (0 = automatic).</p>
</dd>
<dt>max_step<span class="classifier">float, default: 0</span></dt><dd><p>Maximum step size (0 = automatic)</p>
</dd>
<dt>ifactor, dfactor<span class="classifier">float, default: 6., 0.3</span></dt><dd><p>Maximum factor to increase/decrease step size by in one step</p>
</dd>
<dt>beta<span class="classifier">float, default: 0</span></dt><dd><p>Beta parameter for stabilised step size control.</p>
</dd>
</dl>
<p>See scipy.integrate.ode ode for more detail</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.integrator.qutip_integrator.IntegratorVern7">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntegratorVern7</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/integrator/qutip_integrator.html#IntegratorVern7"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.integrator.qutip_integrator.IntegratorVern7" title="Permalink to this definition"></a></dt>
<dd><p>QuTiP’s implementation of Verner’s “most efficient” Runge-Kutta method
of order 7. These are Runge-Kutta methods with variable steps and dense
output.</p>
<p>The implementation uses QuTiP’s Data objects for the state, allowing
sparse, GPU or other data layer objects to be used efficiently by the
solver in their native formats.</p>
<p>See <a class="reference external" href="https://www.sfu.ca/~jverner/">https://www.sfu.ca/~jverner/</a> for a detailed description of the
methods.</p>
<p>Usable with <code class="docutils literal notranslate"><span class="pre">method=&quot;vern7&quot;</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.integrator.qutip_integrator.IntegratorVern7.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.integrator.qutip_integrator.IntegratorVern7.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by verner method:</p>
<dl class="simple">
<dt>atol<span class="classifier">float, default: 1e-8</span></dt><dd><p>Absolute tolerance.</p>
</dd>
<dt>rtol<span class="classifier">float, default: 1e-6</span></dt><dd><p>Relative tolerance.</p>
</dd>
<dt>nsteps<span class="classifier">int, default: 1000</span></dt><dd><p>Max. number of internal steps/call.</p>
</dd>
<dt>first_step<span class="classifier">float, default: 0</span></dt><dd><p>Size of initial step (0 = automatic).</p>
</dd>
<dt>min_step<span class="classifier">float, default: 0</span></dt><dd><p>Minimum step size (0 = automatic).</p>
</dd>
<dt>max_step<span class="classifier">float, default: 0</span></dt><dd><p>Maximum step size (0 = automatic)
When using pulses, change to half the thinest pulse otherwise it
may be skipped.</p>
</dd>
<dt>interpolate<span class="classifier">bool, default: True</span></dt><dd><p>Whether to use interpolation step, faster most of the time.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.integrator.qutip_integrator.IntegratorVern9">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntegratorVern9</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/integrator/qutip_integrator.html#IntegratorVern9"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.integrator.qutip_integrator.IntegratorVern9" title="Permalink to this definition"></a></dt>
<dd><p>QuTiP’s implementation of Verner’s “most efficient” Runge-Kutta method
of order 9. These are Runge-Kutta methods with variable steps and dense
output.</p>
<p>The implementation uses QuTiP’s Data objects for the state, allowing
sparse, GPU or other data layer objects to be used efficiently by the
solver in their native formats.</p>
<p>See <a class="reference external" href="https://www.sfu.ca/~jverner/">https://www.sfu.ca/~jverner/</a> for a detailed description of the
methods.</p>
<p>Usable with <code class="docutils literal notranslate"><span class="pre">method=&quot;vern9&quot;</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.integrator.qutip_integrator.IntegratorVern9.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.integrator.qutip_integrator.IntegratorVern9.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by verner method:</p>
<dl class="simple">
<dt>atol<span class="classifier">float, default: 1e-8</span></dt><dd><p>Absolute tolerance.</p>
</dd>
<dt>rtol<span class="classifier">float, default: 1e-6</span></dt><dd><p>Relative tolerance.</p>
</dd>
<dt>nsteps<span class="classifier">int, default: 1000</span></dt><dd><p>Max. number of internal steps/call.</p>
</dd>
<dt>first_step<span class="classifier">float, default: 0</span></dt><dd><p>Size of initial step (0 = automatic).</p>
</dd>
<dt>min_step<span class="classifier">float, default: 0</span></dt><dd><p>Minimum step size (0 = automatic).</p>
</dd>
<dt>max_step<span class="classifier">float, default: 0</span></dt><dd><p>Maximum step size (0 = automatic)
When using pulses, change to half the thinest pulse otherwise it
may be skipped.</p>
</dd>
<dt>interpolate<span class="classifier">bool, default: True</span></dt><dd><p>Whether to use interpolation step, faster most of the time.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.integrator.qutip_integrator.IntegratorDiag">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntegratorDiag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/integrator/qutip_integrator.html#IntegratorDiag"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.integrator.qutip_integrator.IntegratorDiag" title="Permalink to this definition"></a></dt>
<dd><p>Integrator solving the ODE by diagonalizing the system and solving
analytically. It can only solve constant system and has a long preparation
time, but the integration is fast.</p>
<p>Usable with <code class="docutils literal notranslate"><span class="pre">method=&quot;diag&quot;</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.integrator.qutip_integrator.IntegratorDiag.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.integrator.qutip_integrator.IntegratorDiag.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by “diag” method:</p>
<dl class="simple">
<dt>eigensolver_dtype<span class="classifier">str, default: “dense”</span></dt><dd><p>Qutip data type {“dense”, “csr”, etc.} to use when computing the
eigenstates. The dense eigen solver is usually faster and more
stable.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.integrator.krylov.IntegratorKrylov">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntegratorKrylov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/integrator/krylov.html#IntegratorKrylov"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.integrator.krylov.IntegratorKrylov" title="Permalink to this definition"></a></dt>
<dd><p>Evolve the state vector (“psi0”) finding an approximation for the time
evolution operator of Hamiltonian (“H”) by obtaining the projection of
the time evolution operator on a set of small dimensional Krylov
subspaces (m &lt;&lt; dim(H)).</p>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.integrator.krylov.IntegratorKrylov.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.integrator.krylov.IntegratorKrylov.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by krylov method:</p>
<dl class="simple">
<dt>atol<span class="classifier">float, default: 1e-7</span></dt><dd><p>Absolute tolerance.</p>
</dd>
<dt>nsteps<span class="classifier">int, default: 100</span></dt><dd><p>Max. number of internal steps/call.</p>
</dd>
<dt>min_step, max_step<span class="classifier">float, default: (1e-5, 1e5)</span></dt><dd><p>Minimum and maximum step size.</p>
</dd>
<dt>krylov_dim: int, default: 0</dt><dd><p>Dimension of Krylov approximation subspaces used for the time
evolution approximation. If the defaut 0 is given, the dimension is calculated
from the system size N, using <cite>min(int((N + 100)**0.5), N-1)</cite>.</p>
</dd>
<dt>sub_system_tol: float, default: 1e-7</dt><dd><p>Tolerance to detect a happy breakdown. A happy breakdown occurs
when the initial ket is in a subspace of the Hamiltonian smaller
than <code class="docutils literal notranslate"><span class="pre">krylov_dim</span></code>.</p>
</dd>
<dt>always_compute_step: bool, default: False</dt><dd><p>If True, the step length is computed each time a new Krylov
subspace is computed. Otherwise it is computed only once when
creating the integrator.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="stochastic-integrator">
<span id="classes-sode"></span><h2>Stochastic Integrator<a class="headerlink" href="#stochastic-integrator" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.sode.rouchon.RouchonSODE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RouchonSODE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/sode/rouchon.html#RouchonSODE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.sode.rouchon.RouchonSODE" title="Permalink to this definition"></a></dt>
<dd><p>Stochastic integration method keeping the positivity of the density matrix.
See eq. (4) Pierre Rouchon and Jason F. Ralpha,
<em>Efficient Quantum Filtering for Quantum Feedback Control</em>,
<a class="reference external" href="https://arxiv.org/abs/1410.5345">arXiv:1410.5345 [quant-ph]</a>,
Phys. Rev. A 91, 012118, (2015).</p>
<ul class="simple">
<li><p>Order: strong 1</p></li>
</ul>
<p class="rubric">Notes</p>
<p>This method should be used with very small <code class="docutils literal notranslate"><span class="pre">dt</span></code>. Unlike other
methods that will return unphysical state (negative eigenvalues, Nans)
when the time step is too large, this method will return state that
seems normal.</p>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.sode.rouchon.RouchonSODE.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.sode.rouchon.RouchonSODE.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by Rouchon Stochastic Integrators:</p>
<dl class="simple">
<dt>dt<span class="classifier">float, default: 0.001</span></dt><dd><p>Internal time step.</p>
</dd>
<dt>tol<span class="classifier">float, default: 1e-7</span></dt><dd><p>Relative tolerance.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.sode.itotaylor.EulerSODE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EulerSODE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/sode/itotaylor.html#EulerSODE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.sode.itotaylor.EulerSODE" title="Permalink to this definition"></a></dt>
<dd><p>A simple generalization of the Euler method for ordinary
differential equations to stochastic differential equations.  Only
solver which could take non-commuting <code class="docutils literal notranslate"><span class="pre">sc_ops</span></code>.</p>
<ul class="simple">
<li><p>Order: 0.5</p></li>
</ul>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.sode.itotaylor.EulerSODE.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.sode.itotaylor.EulerSODE.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by Explicit Stochastic Integrators:</p>
<dl class="simple">
<dt>dt<span class="classifier">float, default: 0.001</span></dt><dd><p>Internal time step.</p>
</dd>
<dt>tol<span class="classifier">float, default: 1e-10</span></dt><dd><p>Tolerance for the time steps.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.sode.itotaylor.Milstein_SODE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Milstein_SODE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/sode/itotaylor.html#Milstein_SODE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.sode.itotaylor.Milstein_SODE" title="Permalink to this definition"></a></dt>
<dd><p>An order 1.0 strong Taylor scheme.  Better approximate numerical
solution to stochastic differential equations.  See eq. (3.12) of
chapter 10.3 of Peter E. Kloeden and Exkhard Platen,
<em>Numerical Solution of Stochastic Differential Equations</em>..</p>
<ul class="simple">
<li><p>Order strong 1.0</p></li>
</ul>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.sode.itotaylor.Milstein_SODE.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.sode.itotaylor.Milstein_SODE.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by Explicit Stochastic Integrators:</p>
<dl class="simple">
<dt>dt<span class="classifier">float, default: 0.001</span></dt><dd><p>Internal time step.</p>
</dd>
<dt>tol<span class="classifier">float, default: 1e-10</span></dt><dd><p>Tolerance for the time steps.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.sode.itotaylor.Taylor1_5_SODE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Taylor1_5_SODE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/sode/itotaylor.html#Taylor1_5_SODE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.sode.itotaylor.Taylor1_5_SODE" title="Permalink to this definition"></a></dt>
<dd><p>Order 1.5 strong Taylor scheme.  Solver with more terms of the
Ito-Taylor expansion. See eq. (4.6) of chapter 10.4 of Peter E. Kloeden and
Exkhard Platen, <em>Numerical Solution of Stochastic Differential Equations</em>.</p>
<ul class="simple">
<li><p>Order strong 1.5</p></li>
</ul>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.sode.itotaylor.Taylor1_5_SODE.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.sode.itotaylor.Taylor1_5_SODE.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by Order 1.5 strong Taylor Stochastic Integrators:</p>
<dl class="simple">
<dt>dt<span class="classifier">float, default: 0.001</span></dt><dd><p>Internal time step.</p>
</dd>
<dt>tol<span class="classifier">float, default: 1e-10</span></dt><dd><p>Relative tolerance.</p>
</dd>
<dt>derr_dt<span class="classifier">float, default: 1e-6</span></dt><dd><p>Finite time difference used to compute the derrivative of the
hamiltonian and <code class="docutils literal notranslate"><span class="pre">sc_ops</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.sode.itotaylor.Implicit_Milstein_SODE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Implicit_Milstein_SODE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/sode/itotaylor.html#Implicit_Milstein_SODE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.sode.itotaylor.Implicit_Milstein_SODE" title="Permalink to this definition"></a></dt>
<dd><p>An order 1.0 implicit strong Taylor scheme.  Implicit Milstein
scheme for the numerical simulation of stiff stochastic
differential equations.  Eq. (2.11) with alpha=0.5 of
chapter 12.2 of Peter E. Kloeden and Exkhard Platen,
<em>Numerical Solution of Stochastic Differential Equations</em>.</p>
<ul class="simple">
<li><p>Order strong 1.0</p></li>
</ul>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.sode.itotaylor.Implicit_Milstein_SODE.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.sode.itotaylor.Implicit_Milstein_SODE.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by Implicit Stochastic Integrators:</p>
<dl class="simple">
<dt>dt<span class="classifier">float, default: 0.001</span></dt><dd><p>Internal time step.</p>
</dd>
<dt>tol<span class="classifier">float, default: 1e-10</span></dt><dd><p>Tolerance for the time steps.</p>
</dd>
<dt>solve_method<span class="classifier">str, default: None</span></dt><dd><p>Method used for solver the <code class="docutils literal notranslate"><span class="pre">Ax=b</span></code> of the implicit step.
Accept methods supported by <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.core.data.solve</span></code>.
When the system is constant, the inverse of the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> can be
used by entering <code class="docutils literal notranslate"><span class="pre">inv</span></code>.</p>
</dd>
<dt>solve_options<span class="classifier">dict, default: {}</span></dt><dd><p>Options to pass to the call to <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.core.data.solve</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Implicit_Taylor1_5_SODE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/sode/itotaylor.html#Implicit_Taylor1_5_SODE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE" title="Permalink to this definition"></a></dt>
<dd><p>Order 1.5 implicit strong Taylor scheme.  Solver with more terms of the
Ito-Taylor expansion.  Eq. (2.18) with <code class="docutils literal notranslate"><span class="pre">alpha=0.5</span></code> of chapter 12.2 of
Peter E. Kloeden and Exkhard Platen,
<em>Numerical Solution of Stochastic Differential Equations</em>.</p>
<ul class="simple">
<li><p>Order strong 1.5</p></li>
</ul>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.sode.itotaylor.Implicit_Taylor1_5_SODE.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by Implicit Order 1.5 strong Taylor Stochastic
Integrators:</p>
<dl class="simple">
<dt>dt<span class="classifier">float, default: 0.001</span></dt><dd><p>Internal time step.</p>
</dd>
<dt>tol<span class="classifier">float, default: 1e-10</span></dt><dd><p>Tolerance for the time steps.</p>
</dd>
<dt>solve_method<span class="classifier">str, default: None</span></dt><dd><p>Method used for solver the <code class="docutils literal notranslate"><span class="pre">Ax=b</span></code> of the implicit step.
Accept methods supported by <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.core.data.solve</span></code>.
When the system is constant, the inverse of the matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> can be
used by entering <code class="docutils literal notranslate"><span class="pre">inv</span></code>.</p>
</dd>
<dt>solve_options<span class="classifier">dict, default: {}</span></dt><dd><p>Options to pass to the call to <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.core.data.solve</span></code>.</p>
</dd>
<dt>derr_dt<span class="classifier">float, default: 1e-6</span></dt><dd><p>Finite time difference used to compute the derrivative of the
hamiltonian and <code class="docutils literal notranslate"><span class="pre">sc_ops</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.sode.sode.PlatenSODE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PlatenSODE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/sode/sode.html#PlatenSODE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.sode.sode.PlatenSODE" title="Permalink to this definition"></a></dt>
<dd><p>Explicit scheme, creates the Milstein using finite differences
instead of analytic derivatives. Also contains some higher order
terms, thus converges better than Milstein while staying strong
order 1.0.  Does not require derivatives. See eq. (7.47) of chapter 7 of
H.-P. Breuer and F. Petruccione, <em>The Theory of Open Quantum Systems</em>.</p>
<ul class="simple">
<li><p>Order: strong 1, weak 2</p></li>
</ul>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.sode.sode.PlatenSODE.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.sode.sode.PlatenSODE.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by Explicit Stochastic Integrators:</p>
<dl class="simple">
<dt>dt<span class="classifier">float, default: 0.001</span></dt><dd><p>Internal time step.</p>
</dd>
<dt>tol<span class="classifier">float, default: 1e-10</span></dt><dd><p>Tolerance for the time steps.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.sode.itotaylor.Explicit1_5_SODE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Explicit1_5_SODE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/sode/itotaylor.html#Explicit1_5_SODE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.sode.itotaylor.Explicit1_5_SODE" title="Permalink to this definition"></a></dt>
<dd><p>Explicit order 1.5 strong schemes.  Reproduce the order 1.5 strong
Taylor scheme using finite difference instead of derivatives.
Slower than <code class="docutils literal notranslate"><span class="pre">taylor15</span></code> but usable when derrivatives cannot be
analytically obtained.
See eq. (2.13) of chapter 11.2 of Peter E. Kloeden and Exkhard Platen,
<em>Numerical Solution of Stochastic Differential Equations.</em></p>
<ul class="simple">
<li><p>Order: strong 1.5</p></li>
</ul>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.sode.itotaylor.Explicit1_5_SODE.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.sode.itotaylor.Explicit1_5_SODE.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by Explicit Stochastic Integrators:</p>
<dl class="simple">
<dt>dt<span class="classifier">float, default: 0.001</span></dt><dd><p>Internal time step.</p>
</dd>
<dt>tol<span class="classifier">float, default: 1e-10</span></dt><dd><p>Tolerance for the time steps.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.sode.sode.PredCorr_SODE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PredCorr_SODE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/sode/sode.html#PredCorr_SODE"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.sode.sode.PredCorr_SODE" title="Permalink to this definition"></a></dt>
<dd><p>Generalization of the trapezoidal method to stochastic differential
equations. More stable than explicit methods.  See eq. (5.4) of
chapter 15.5 of Peter E. Kloeden and Exkhard Platen,
<em>Numerical Solution of Stochastic Differential Equations</em>.</p>
<ul class="simple">
<li><p>Order strong 0.5, weak 1.0</p></li>
<li><p>Codes to only correct the stochastic part (<span class="math notranslate nohighlight">\(\alpha=0\)</span>,
<span class="math notranslate nohighlight">\(\eta=1/2\)</span>): <code class="docutils literal notranslate"><span class="pre">'pred-corr'</span></code>, <code class="docutils literal notranslate"><span class="pre">'predictor-corrector'</span></code> or
<code class="docutils literal notranslate"><span class="pre">'pc-euler'</span></code></p></li>
<li><p>Codes to correct both the stochastic and deterministic parts
(<span class="math notranslate nohighlight">\(\alpha=1/2\)</span>, <span class="math notranslate nohighlight">\(\eta=1/2\)</span>): <code class="docutils literal notranslate"><span class="pre">'pc-euler-imp'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'pc-euler-2'</span></code> or <code class="docutils literal notranslate"><span class="pre">'pred-corr-2'</span></code></p></li>
</ul>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.sode.sode.PredCorr_SODE.options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">options</span></span><a class="headerlink" href="#qutip.solver.sode.sode.PredCorr_SODE.options" title="Permalink to this definition"></a></dt>
<dd><p>Supported options by Explicit Stochastic Integrators:</p>
<dl class="simple">
<dt>dt<span class="classifier">float, default: 0.001</span></dt><dd><p>Internal time step.</p>
</dd>
<dt>tol<span class="classifier">float, default: 1e-10</span></dt><dd><p>Tolerance for the time steps.</p>
</dd>
<dt>alpha<span class="classifier">float, default: 0.</span></dt><dd><p>Implicit factor to the drift.
eff_drift ~= drift(t) * (1-alpha) + drift(t+dt) * alpha</p>
</dd>
<dt>eta<span class="classifier">float, default: 0.5</span></dt><dd><p>Implicit factor to the diffusion.
eff_diffusion ~= diffusion(t) * (1-eta) + diffusion(t+dt) * eta</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="solver-options-and-results">
<span id="classes-odeoptions"></span><h2>Solver Options and Results<a class="headerlink" href="#solver-options-and-results" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.result.Result">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">e_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ResultOptions</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/result.html#Result"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.result.Result" title="Permalink to this definition"></a></dt>
<dd><p>Base class for storing solver results.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>e_ops</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, function or list or dict of these</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> parameter defines the set of values to record at
each time step <code class="docutils literal notranslate"><span class="pre">t</span></code>. If an element is a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> or
<a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> the value recorded is the expectation value of that
operator given the state at <code class="docutils literal notranslate"><span class="pre">t</span></code>. If the element is a function, <code class="docutils literal notranslate"><span class="pre">f</span></code>,
the value recorded is <code class="docutils literal notranslate"><span class="pre">f(t,</span> <span class="pre">state)</span></code>.</p>
<p>The values are recorded in the <code class="docutils literal notranslate"><span class="pre">e_data</span></code> and <code class="docutils literal notranslate"><span class="pre">expect</span></code> attributes of
this result object. <code class="docutils literal notranslate"><span class="pre">e_data</span></code> is a dictionary and <code class="docutils literal notranslate"><span class="pre">expect</span></code> is a
list, where each item contains the values of the corresponding
<code class="docutils literal notranslate"><span class="pre">e_op</span></code>.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict</span></dt><dd><p>The options for this result class.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str or None</span></dt><dd><p>The name of the solver generating these results.</p>
</dd>
<dt><strong>stats</strong><span class="classifier">dict or None</span></dt><dd><p>The stats generated by the solver while producing these results. Note
that the solver may update the stats directly while producing results.</p>
</dd>
<dt><strong>kw</strong><span class="classifier">dict</span></dt><dd><p>Additional parameters specific to a result sub-class.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>times</strong><span class="classifier">list</span></dt><dd><p>A list of the times at which the expectation values and states were
recorded.</p>
</dd>
<dt><strong>states</strong><span class="classifier">list of <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The state at each time <code class="docutils literal notranslate"><span class="pre">t</span></code> (if the recording of the state was
requested).</p>
</dd>
<dt><strong>final_state</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>:</span></dt><dd><p>The final state (if the recording of the final state was requested).</p>
</dd>
<dt><strong>expect</strong><span class="classifier">list of arrays of expectation values</span></dt><dd><p>A list containing the values of each <code class="docutils literal notranslate"><span class="pre">e_op</span></code>. The list is in
the same order in which the <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> were supplied and empty if
no <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> were given.</p>
<p>Each element is itself a list and contains the values of the
corresponding <code class="docutils literal notranslate"><span class="pre">e_op</span></code>, with one value for each time in <code class="docutils literal notranslate"><span class="pre">.times</span></code>.</p>
<p>The same lists of values may be accessed via the <code class="docutils literal notranslate"><span class="pre">.e_data</span></code> dictionary
and the original <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> are available via the <code class="docutils literal notranslate"><span class="pre">.e_ops</span></code> attribute.</p>
</dd>
<dt><strong>e_data</strong><span class="classifier">dict</span></dt><dd><p>A dictionary containing the values of each <code class="docutils literal notranslate"><span class="pre">e_op</span></code>. If the <code class="docutils literal notranslate"><span class="pre">e_ops</span></code>
were supplied as a dictionary, the keys are the same as in
that dictionary. Otherwise the keys are the index of the <code class="docutils literal notranslate"><span class="pre">e_op</span></code>
in the <code class="docutils literal notranslate"><span class="pre">.expect</span></code> list.</p>
<p>The lists of expectation values returned are the <em>same</em> lists as
those returned by <code class="docutils literal notranslate"><span class="pre">.expect</span></code>.</p>
</dd>
<dt><strong>e_ops</strong><span class="classifier">dict</span></dt><dd><p>A dictionary containing the supplied e_ops as <code class="docutils literal notranslate"><span class="pre">ExpectOp</span></code> instances.
The keys of the dictionary are the same as for <code class="docutils literal notranslate"><span class="pre">.e_data</span></code>.
Each value is object where <code class="docutils literal notranslate"><span class="pre">.e_ops[k](t,</span> <span class="pre">state)</span></code> calculates the
value of <code class="docutils literal notranslate"><span class="pre">e_op</span></code> <code class="docutils literal notranslate"><span class="pre">k</span></code> at time <code class="docutils literal notranslate"><span class="pre">t</span></code> and the given <code class="docutils literal notranslate"><span class="pre">state</span></code>, and
<code class="docutils literal notranslate"><span class="pre">.e_ops[k].op</span></code> is the original object supplied to create the
<code class="docutils literal notranslate"><span class="pre">e_op</span></code>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str or None</span></dt><dd><p>The name of the solver generating these results.</p>
</dd>
<dt><strong>stats</strong><span class="classifier">dict or None</span></dt><dd><p>The stats generated by the solver while producing these results.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict</span></dt><dd><p>The options for this result class.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.result.MultiTrajResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MultiTrajResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">e_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">MultiTrajResultOptions</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/result.html#MultiTrajResult"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.result.MultiTrajResult" title="Permalink to this definition"></a></dt>
<dd><p>Base class for storing results for solver using multiple trajectories.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>e_ops</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, function or list or dict of these</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> parameter defines the set of values to record at
each time step <code class="docutils literal notranslate"><span class="pre">t</span></code>. If an element is a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> or
<a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> the value recorded is the expectation value of that
operator given the state at <code class="docutils literal notranslate"><span class="pre">t</span></code>. If the element is a function, <code class="docutils literal notranslate"><span class="pre">f</span></code>,
the value recorded is <code class="docutils literal notranslate"><span class="pre">f(t,</span> <span class="pre">state)</span></code>.</p>
<p>The values are recorded in the <code class="docutils literal notranslate"><span class="pre">.expect</span></code> attribute of this result
object. <code class="docutils literal notranslate"><span class="pre">.expect</span></code> is a list, where each item contains the values
of the corresponding <code class="docutils literal notranslate"><span class="pre">e_op</span></code>.</p>
<p>Function <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> must return a number so the average can be computed.</p>
</dd>
<dt><strong>options</strong><span class="classifier">dict</span></dt><dd><p>The options for this result class.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str or None</span></dt><dd><p>The name of the solver generating these results.</p>
</dd>
<dt><strong>stats</strong><span class="classifier">dict or None</span></dt><dd><p>The stats generated by the solver while producing these results. Note
that the solver may update the stats directly while producing results.</p>
</dd>
<dt><strong>kw</strong><span class="classifier">dict</span></dt><dd><p>Additional parameters specific to a result sub-class.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl>
<dt><strong>times</strong><span class="classifier">list</span></dt><dd><p>A list of the times at which the expectation values and states were
recorded.</p>
</dd>
<dt><a class="reference internal" href="#qutip.solver.result.MultiTrajResult.average_states" title="qutip.solver.result.MultiTrajResult.average_states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average_states</span></code></a><span class="classifier">list of <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>States averages as density matrices.</p>
</dd>
<dt><a class="reference internal" href="#qutip.solver.result.MultiTrajResult.runs_states" title="qutip.solver.result.MultiTrajResult.runs_states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">runs_states</span></code></a><span class="classifier">list of list of <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>States of every runs as <code class="docutils literal notranslate"><span class="pre">states[run][t]</span></code>.</p>
</dd>
<dt><a class="reference internal" href="#qutip.solver.result.MultiTrajResult.final_state" title="qutip.solver.result.MultiTrajResult.final_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">final_state</span></code></a><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>:</span></dt><dd><p>Runs final states if available, average otherwise.</p>
</dd>
<dt><strong>runs_final_state</strong><span class="classifier">list of <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The final state for each trajectory (if the recording of the final
state and trajectories was requested).</p>
</dd>
<dt><strong>average_expect</strong><span class="classifier">list of array of expectation values</span></dt><dd><p>A list containing the values of each <code class="docutils literal notranslate"><span class="pre">e_op</span></code> averaged over each
trajectories. The list is in the same order in which the <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> were
supplied and empty if no <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> were given.</p>
<p>Each element is itself an array and contains the values of the
corresponding <code class="docutils literal notranslate"><span class="pre">e_op</span></code>, with one value for each time in <code class="docutils literal notranslate"><span class="pre">.times</span></code>.</p>
</dd>
<dt><strong>std_expect</strong><span class="classifier">list of array of expectation values</span></dt><dd><p>A list containing the standard derivation of each <code class="docutils literal notranslate"><span class="pre">e_op</span></code> over each
trajectories. The list is in the same order in which the <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> were
supplied and empty if no <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> were given.</p>
<p>Each element is itself an array and contains the values of the
corresponding <code class="docutils literal notranslate"><span class="pre">e_op</span></code>, with one value for each time in <code class="docutils literal notranslate"><span class="pre">.times</span></code>.</p>
</dd>
<dt><strong>runs_expect</strong><span class="classifier">list of array of expectation values</span></dt><dd><p>A list containing the values of each <code class="docutils literal notranslate"><span class="pre">e_op</span></code> for each trajectories.
The list is in the same order in which the <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> were
supplied and empty if no <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> were given. Only available if the
storing of trajectories was requested.</p>
<p>The order of the elements is <code class="docutils literal notranslate"><span class="pre">runs_expect[e_ops][trajectory][time]</span></code>.</p>
<p>Each element is itself an array and contains the values of the
corresponding <code class="docutils literal notranslate"><span class="pre">e_op</span></code>, with one value for each time in <code class="docutils literal notranslate"><span class="pre">.times</span></code>.</p>
</dd>
<dt><strong>average_e_data</strong><span class="classifier">dict</span></dt><dd><p>A dictionary containing the values of each <code class="docutils literal notranslate"><span class="pre">e_op</span></code> averaged over each
trajectories. If the <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> were supplied as a dictionary, the keys
are the same as in that dictionary. Otherwise the keys are the index of
the <code class="docutils literal notranslate"><span class="pre">e_op</span></code> in the <code class="docutils literal notranslate"><span class="pre">.expect</span></code> list.</p>
<p>The lists of expectation values returned are the <em>same</em> lists as
those returned by <code class="docutils literal notranslate"><span class="pre">.expect</span></code>.</p>
</dd>
<dt><strong>average_e_data</strong><span class="classifier">dict</span></dt><dd><p>A dictionary containing the standard derivation of each <code class="docutils literal notranslate"><span class="pre">e_op</span></code> over
each trajectories. If the <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> were supplied as a dictionary, the
keys are the same as in that dictionary. Otherwise the keys are the
index of the <code class="docutils literal notranslate"><span class="pre">e_op</span></code> in the <code class="docutils literal notranslate"><span class="pre">.expect</span></code> list.</p>
<p>The lists of expectation values returned are the <em>same</em> lists as
those returned by <code class="docutils literal notranslate"><span class="pre">.expect</span></code>.</p>
</dd>
<dt><strong>runs_e_data</strong><span class="classifier">dict</span></dt><dd><p>A dictionary containing the values of each <code class="docutils literal notranslate"><span class="pre">e_op</span></code> for each
trajectories. If the <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> were supplied as a dictionary, the keys
are the same as in that dictionary. Otherwise the keys are the index of
the <code class="docutils literal notranslate"><span class="pre">e_op</span></code> in the <code class="docutils literal notranslate"><span class="pre">.expect</span></code> list. Only available if the storing
of trajectories was requested.</p>
<p>The order of the elements is <code class="docutils literal notranslate"><span class="pre">runs_expect[e_ops][trajectory][time]</span></code>.</p>
<p>The lists of expectation values returned are the <em>same</em> lists as
those returned by <code class="docutils literal notranslate"><span class="pre">.expect</span></code>.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str or None</span></dt><dd><p>The name of the solver generating these results.</p>
</dd>
<dt><strong>stats</strong><span class="classifier">dict or None</span></dt><dd><p>The stats generated by the solver while producing these results.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SolverResultsOptions</span></code></span></dt><dd><p>The options for this result class.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.MultiTrajResult.average_final_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">average_final_state</span></span><a class="headerlink" href="#qutip.solver.result.MultiTrajResult.average_final_state" title="Permalink to this definition"></a></dt>
<dd><p>Last states of each trajectories averaged into a density matrix.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.MultiTrajResult.average_states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">average_states</span></span><a class="headerlink" href="#qutip.solver.result.MultiTrajResult.average_states" title="Permalink to this definition"></a></dt>
<dd><p>States averages as density matrices.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.MultiTrajResult.final_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">final_state</span></span><a class="headerlink" href="#qutip.solver.result.MultiTrajResult.final_state" title="Permalink to this definition"></a></dt>
<dd><p>Runs final states if available, average otherwise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.MultiTrajResult.runs_final_states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">runs_final_states</span></span><a class="headerlink" href="#qutip.solver.result.MultiTrajResult.runs_final_states" title="Permalink to this definition"></a></dt>
<dd><p>Last states of each trajectories.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.MultiTrajResult.runs_states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">runs_states</span></span><a class="headerlink" href="#qutip.solver.result.MultiTrajResult.runs_states" title="Permalink to this definition"></a></dt>
<dd><p>States of every runs as <code class="docutils literal notranslate"><span class="pre">states[run][t]</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.MultiTrajResult.states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">states</span></span><a class="headerlink" href="#qutip.solver.result.MultiTrajResult.states" title="Permalink to this definition"></a></dt>
<dd><p>Runs final states if available, average otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.result.MultiTrajResult.steady_state">
<span class="sig-name descname"><span class="pre">steady_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/result.html#MultiTrajResult.steady_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.result.MultiTrajResult.steady_state" title="Permalink to this definition"></a></dt>
<dd><p>Average the states of the last <code class="docutils literal notranslate"><span class="pre">N</span></code> times of every runs as a density
matrix. Should converge to the steady state in the right circumstances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int [optional]</span></dt><dd><p>Number of states from the end of <code class="docutils literal notranslate"><span class="pre">tlist</span></code> to average. Per default
all states will be averaged.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.result.McResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">McResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">e_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">MultiTrajResultOptions</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/result.html#McResult"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.result.McResult" title="Permalink to this definition"></a></dt>
<dd><p>Class for storing Monte-Carlo solver results.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>e_ops</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, function or list or dict of these</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> parameter defines the set of values to record at
each time step <code class="docutils literal notranslate"><span class="pre">t</span></code>. If an element is a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> or
<a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> the value recorded is the expectation value of that
operator given the state at <code class="docutils literal notranslate"><span class="pre">t</span></code>. If the element is a function, <code class="docutils literal notranslate"><span class="pre">f</span></code>,
the value recorded is <code class="docutils literal notranslate"><span class="pre">f(t,</span> <span class="pre">state)</span></code>.</p>
<p>The values are recorded in the <code class="docutils literal notranslate"><span class="pre">.expect</span></code> attribute of this result
object. <code class="docutils literal notranslate"><span class="pre">.expect</span></code> is a list, where each item contains the values
of the corresponding <code class="docutils literal notranslate"><span class="pre">e_op</span></code>.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SolverResultsOptions</span></code></span></dt><dd><p>The options for this result class.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str or None</span></dt><dd><p>The name of the solver generating these results.</p>
</dd>
<dt><strong>stats</strong><span class="classifier">dict</span></dt><dd><p>The stats generated by the solver while producing these results. Note
that the solver may update the stats directly while producing results.
Must include a value for “num_collapse”.</p>
</dd>
<dt><strong>kw</strong><span class="classifier">dict</span></dt><dd><p>Additional parameters specific to a result sub-class.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>collapse</strong><span class="classifier">list</span></dt><dd><p>For each runs, a list of every collapse as a tuple of the time it
happened and the corresponding <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> index.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.McResult.average_final_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">average_final_state</span></span><a class="headerlink" href="#qutip.solver.result.McResult.average_final_state" title="Permalink to this definition"></a></dt>
<dd><p>Last states of each trajectories averaged into a density matrix.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.McResult.average_states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">average_states</span></span><a class="headerlink" href="#qutip.solver.result.McResult.average_states" title="Permalink to this definition"></a></dt>
<dd><p>States averages as density matrices.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.McResult.col_times">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">col_times</span></span><a class="headerlink" href="#qutip.solver.result.McResult.col_times" title="Permalink to this definition"></a></dt>
<dd><p>List of the times of the collapses for each runs.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.McResult.col_which">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">col_which</span></span><a class="headerlink" href="#qutip.solver.result.McResult.col_which" title="Permalink to this definition"></a></dt>
<dd><p>List of the indexes of the collapses for each runs.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.McResult.final_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">final_state</span></span><a class="headerlink" href="#qutip.solver.result.McResult.final_state" title="Permalink to this definition"></a></dt>
<dd><p>Runs final states if available, average otherwise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.McResult.photocurrent">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">photocurrent</span></span><a class="headerlink" href="#qutip.solver.result.McResult.photocurrent" title="Permalink to this definition"></a></dt>
<dd><p>Average photocurrent or measurement of the evolution.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.McResult.runs_final_states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">runs_final_states</span></span><a class="headerlink" href="#qutip.solver.result.McResult.runs_final_states" title="Permalink to this definition"></a></dt>
<dd><p>Last states of each trajectories.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.McResult.runs_photocurrent">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">runs_photocurrent</span></span><a class="headerlink" href="#qutip.solver.result.McResult.runs_photocurrent" title="Permalink to this definition"></a></dt>
<dd><p>Photocurrent or measurement of each runs.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.McResult.runs_states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">runs_states</span></span><a class="headerlink" href="#qutip.solver.result.McResult.runs_states" title="Permalink to this definition"></a></dt>
<dd><p>States of every runs as <code class="docutils literal notranslate"><span class="pre">states[run][t]</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.McResult.states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">states</span></span><a class="headerlink" href="#qutip.solver.result.McResult.states" title="Permalink to this definition"></a></dt>
<dd><p>Runs final states if available, average otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.result.McResult.steady_state">
<span class="sig-name descname"><span class="pre">steady_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.result.McResult.steady_state" title="Permalink to this definition"></a></dt>
<dd><p>Average the states of the last <code class="docutils literal notranslate"><span class="pre">N</span></code> times of every runs as a density
matrix. Should converge to the steady state in the right circumstances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int [optional]</span></dt><dd><p>Number of states from the end of <code class="docutils literal notranslate"><span class="pre">tlist</span></code> to average. Per default
all states will be averaged.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">NmmcResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">e_ops</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">MultiTrajResultOptions</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stats</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kw</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/solver/result.html#NmmcResult"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.solver.result.NmmcResult" title="Permalink to this definition"></a></dt>
<dd><p>Class for storing the results of the non-Markovian Monte-Carlo solver.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>e_ops</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a>, <a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a>, function or list or dict of these</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> parameter defines the set of values to record at
each time step <code class="docutils literal notranslate"><span class="pre">t</span></code>. If an element is a <a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Qobj</span></code></a> or
<a class="reference internal" href="#qutip.core.cy.qobjevo.QobjEvo" title="qutip.core.cy.qobjevo.QobjEvo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QobjEvo</span></code></a> the value recorded is the expectation value of that
operator given the state at <code class="docutils literal notranslate"><span class="pre">t</span></code>. If the element is a function, <code class="docutils literal notranslate"><span class="pre">f</span></code>,
the value recorded is <code class="docutils literal notranslate"><span class="pre">f(t,</span> <span class="pre">state)</span></code>.</p>
<p>The values are recorded in the <code class="docutils literal notranslate"><span class="pre">.expect</span></code> attribute of this result
object. <code class="docutils literal notranslate"><span class="pre">.expect</span></code> is a list, where each item contains the values
of the corresponding <code class="docutils literal notranslate"><span class="pre">e_op</span></code>.</p>
</dd>
<dt><strong>options</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SolverResultsOptions</span></code></span></dt><dd><p>The options for this result class.</p>
</dd>
<dt><strong>solver</strong><span class="classifier">str or None</span></dt><dd><p>The name of the solver generating these results.</p>
</dd>
<dt><strong>stats</strong><span class="classifier">dict</span></dt><dd><p>The stats generated by the solver while producing these results. Note
that the solver may update the stats directly while producing results.
Must include a value for “num_collapse”.</p>
</dd>
<dt><strong>kw</strong><span class="classifier">dict</span></dt><dd><p>Additional parameters specific to a result sub-class.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>average_trace</strong><span class="classifier">list</span></dt><dd><p>The average trace (i.e., averaged over all trajectories) at each time.</p>
</dd>
<dt><strong>std_trace</strong><span class="classifier">list</span></dt><dd><p>The standard deviation of the trace at each time.</p>
</dd>
<dt><strong>runs_trace</strong><span class="classifier">list of lists</span></dt><dd><p>For each recorded trajectory, the trace at each time.
Only present if <code class="docutils literal notranslate"><span class="pre">keep_runs_results</span></code> is set in the options.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult.average_final_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">average_final_state</span></span><a class="headerlink" href="#qutip.solver.result.NmmcResult.average_final_state" title="Permalink to this definition"></a></dt>
<dd><p>Last states of each trajectories averaged into a density matrix.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult.average_states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">average_states</span></span><a class="headerlink" href="#qutip.solver.result.NmmcResult.average_states" title="Permalink to this definition"></a></dt>
<dd><p>States averages as density matrices.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult.col_times">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">col_times</span></span><a class="headerlink" href="#qutip.solver.result.NmmcResult.col_times" title="Permalink to this definition"></a></dt>
<dd><p>List of the times of the collapses for each runs.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult.col_which">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">col_which</span></span><a class="headerlink" href="#qutip.solver.result.NmmcResult.col_which" title="Permalink to this definition"></a></dt>
<dd><p>List of the indexes of the collapses for each runs.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult.final_state">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">final_state</span></span><a class="headerlink" href="#qutip.solver.result.NmmcResult.final_state" title="Permalink to this definition"></a></dt>
<dd><p>Runs final states if available, average otherwise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult.photocurrent">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">photocurrent</span></span><a class="headerlink" href="#qutip.solver.result.NmmcResult.photocurrent" title="Permalink to this definition"></a></dt>
<dd><p>Average photocurrent or measurement of the evolution.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult.runs_final_states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">runs_final_states</span></span><a class="headerlink" href="#qutip.solver.result.NmmcResult.runs_final_states" title="Permalink to this definition"></a></dt>
<dd><p>Last states of each trajectories.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult.runs_photocurrent">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">runs_photocurrent</span></span><a class="headerlink" href="#qutip.solver.result.NmmcResult.runs_photocurrent" title="Permalink to this definition"></a></dt>
<dd><p>Photocurrent or measurement of each runs.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult.runs_states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">runs_states</span></span><a class="headerlink" href="#qutip.solver.result.NmmcResult.runs_states" title="Permalink to this definition"></a></dt>
<dd><p>States of every runs as <code class="docutils literal notranslate"><span class="pre">states[run][t]</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult.states">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">states</span></span><a class="headerlink" href="#qutip.solver.result.NmmcResult.states" title="Permalink to this definition"></a></dt>
<dd><p>Runs final states if available, average otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult.steady_state">
<span class="sig-name descname"><span class="pre">steady_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#qutip.solver.result.NmmcResult.steady_state" title="Permalink to this definition"></a></dt>
<dd><p>Average the states of the last <code class="docutils literal notranslate"><span class="pre">N</span></code> times of every runs as a density
matrix. Should converge to the steady state in the right circumstances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N</strong><span class="classifier">int [optional]</span></dt><dd><p>Number of states from the end of <code class="docutils literal notranslate"><span class="pre">tlist</span></code> to average. Per default
all states will be averaged.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qutip.solver.result.NmmcResult.trace">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">trace</span></span><a class="headerlink" href="#qutip.solver.result.NmmcResult.trace" title="Permalink to this definition"></a></dt>
<dd><p>Refers to <code class="docutils literal notranslate"><span class="pre">average_trace</span></code> or <code class="docutils literal notranslate"><span class="pre">runs_trace</span></code>, depending on whether
<code class="docutils literal notranslate"><span class="pre">keep_runs_results</span></code> is set in the options.</p>
</dd></dl>

</dd></dl>

</section>
<section id="permutational-invariance">
<span id="classes-piqs"></span><h2>Permutational Invariance<a class="headerlink" href="#permutational-invariance" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Dicke">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Dicke</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamiltonian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">emission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dephasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pumping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_emission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_dephasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_pumping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Dicke"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Dicke" title="Permalink to this definition"></a></dt>
<dd><p>The Dicke class which builds the Lindbladian and Liouvillian matrix.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>hamiltonian</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>A Hamiltonian in the Dicke basis.</p>
<p>The matrix dimensions are (nds, nds),
with nds being the number of Dicke states.
The Hamiltonian can be built with the operators
given by the <cite>jspin</cite> functions.</p>
</dd>
<dt><strong>emission: float</strong></dt><dd><p>Incoherent emission coefficient (also nonradiative emission).
default: 0.0</p>
</dd>
<dt><strong>dephasing: float</strong></dt><dd><p>Local dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>pumping: float</strong></dt><dd><p>Incoherent pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_emission: float</strong></dt><dd><p>Collective (superradiant) emmission coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_pumping: float</strong></dt><dd><p>Collective pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_dephasing: float</strong></dt><dd><p>Collective dephasing coefficient.
default: 0.0</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">qutip.piqs</span> <span class="kn">import</span> <span class="n">Dicke</span><span class="p">,</span> <span class="n">jspin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">N</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jx</span><span class="p">,</span> <span class="n">jy</span><span class="p">,</span> <span class="n">jz</span> <span class="o">=</span> <span class="n">jspin</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jp</span> <span class="o">=</span> <span class="n">jspin</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jm</span> <span class="o">=</span> <span class="n">jspin</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensemble</span> <span class="o">=</span> <span class="n">Dicke</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">emission</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span> <span class="o">=</span> <span class="n">ensemble</span><span class="o">.</span><span class="n">liouvillian</span><span class="p">()</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Attributes<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>hamiltonian</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>A Hamiltonian in the Dicke basis.</p>
<p>The matrix dimensions are (nds, nds),
with nds being the number of Dicke states.
The Hamiltonian can be built with the operators given
by the <cite>jspin</cite> function in the “dicke” basis.</p>
</dd>
<dt><strong>emission: float</strong></dt><dd><p>Incoherent emission coefficient (also nonradiative emission).
default: 0.0</p>
</dd>
<dt><strong>dephasing: float</strong></dt><dd><p>Local dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>pumping: float</strong></dt><dd><p>Incoherent pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_emission: float</strong></dt><dd><p>Collective (superradiant) emmission coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_dephasing: float</strong></dt><dd><p>Collective dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_pumping: float</strong></dt><dd><p>Collective pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>nds: int</strong></dt><dd><p>The number of Dicke states.</p>
</dd>
<dt><strong>dshape: tuple</strong></dt><dd><p>The shape of the Hilbert space in the Dicke or uncoupled basis.
default: (nds, nds).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Dicke.c_ops">
<span class="sig-name descname"><span class="pre">c_ops</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Dicke.c_ops"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Dicke.c_ops" title="Permalink to this definition"></a></dt>
<dd><p>Build collapse operators in the full Hilbert space 2^N.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>c_ops_list: list</dt><dd><p>The list with the collapse operators in the 2^N Hilbert space.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Dicke.coefficient_matrix">
<span class="sig-name descname"><span class="pre">coefficient_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Dicke.coefficient_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Dicke.coefficient_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Build coefficient matrix for ODE for a diagonal problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt>M: ndarray</dt><dd><p>The matrix M of the coefficients for the ODE dp/dt = Mp.
p is the vector of the diagonal matrix elements
of the density matrix rho in the Dicke basis.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Dicke.lindbladian">
<span class="sig-name descname"><span class="pre">lindbladian</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Dicke.lindbladian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Dicke.lindbladian" title="Permalink to this definition"></a></dt>
<dd><p>Build the Lindbladian superoperator of the dissipative dynamics.</p>
<dl class="field-list">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>lindbladian</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The Lindbladian matrix as a <cite>qutip.Qobj</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Dicke.liouvillian">
<span class="sig-name descname"><span class="pre">liouvillian</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Dicke.liouvillian"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Dicke.liouvillian" title="Permalink to this definition"></a></dt>
<dd><p>Build the total Liouvillian using the Dicke basis.</p>
<dl class="field-list">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>liouv</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>The Liouvillian matrix for the system.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Dicke.pisolve">
<span class="sig-name descname"><span class="pre">pisolve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">initial_state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Dicke.pisolve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Dicke.pisolve" title="Permalink to this definition"></a></dt>
<dd><p>Solve for diagonal Hamiltonians and initial states faster.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl>
<dt><strong>initial_state</strong><span class="classifier"><a class="reference internal" href="#qutip.core.qobj.Qobj" title="qutip.core.qobj.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">Qobj</span></code></a></span></dt><dd><p>An initial state specified as a density matrix of
<cite>qutip.Qbj</cite> type.</p>
</dd>
<dt><strong>tlist: ndarray</strong></dt><dd><p>A 1D numpy array of list of timesteps to integrate</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>result: list</dt><dd><p>A dictionary of the type <cite>qutip.piqs.Result</cite> which holds the
results of the evolution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Pim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">emission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dephasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pumping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_emission</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_pumping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">collective_dephasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim" title="Permalink to this definition"></a></dt>
<dd><p>The Permutation Invariant Matrix class.</p>
<p>Initialize the class with the parameters for generating a Permutation
Invariant matrix which evolves a given diagonal initial state <cite>p</cite> as:</p>
<blockquote>
<div><p>dp/dt = Mp</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>emission: float</strong></dt><dd><p>Incoherent emission coefficient (also nonradiative emission).
default: 0.0</p>
</dd>
<dt><strong>dephasing: float</strong></dt><dd><p>Local dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>pumping: float</strong></dt><dd><p>Incoherent pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_emission: float</strong></dt><dd><p>Collective (superradiant) emmission coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_pumping: float</strong></dt><dd><p>Collective pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_dephasing: float</strong></dt><dd><p>Collective dephasing coefficient.
default: 0.0</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>N: int</strong></dt><dd><p>The number of two-level systems.</p>
</dd>
<dt><strong>emission: float</strong></dt><dd><p>Incoherent emission coefficient (also nonradiative emission).
default: 0.0</p>
</dd>
<dt><strong>dephasing: float</strong></dt><dd><p>Local dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>pumping: float</strong></dt><dd><p>Incoherent pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_emission: float</strong></dt><dd><p>Collective (superradiant) emmission coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_dephasing: float</strong></dt><dd><p>Collective dephasing coefficient.
default: 0.0</p>
</dd>
<dt><strong>collective_pumping: float</strong></dt><dd><p>Collective pumping coefficient.
default: 0.0</p>
</dd>
<dt><strong>M: dict</strong></dt><dd><p>A nested dictionary of the structure {row: {col: val}} which holds
non zero elements of the matrix M</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.calculate_j_m">
<span class="sig-name descname"><span class="pre">calculate_j_m</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dicke_row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dicke_col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.calculate_j_m"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.calculate_j_m" title="Permalink to this definition"></a></dt>
<dd><p>Get the value of j and m for the particular Dicke space element.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dicke_row, dicke_col: int</strong></dt><dd><p>The row and column from the Dicke space matrix</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>j, m: float</dt><dd><p>The j and m values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.calculate_k">
<span class="sig-name descname"><span class="pre">calculate_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dicke_row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dicke_col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.calculate_k"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.calculate_k" title="Permalink to this definition"></a></dt>
<dd><p>Get k value from the current row and column element in the Dicke space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dicke_row, dicke_col: int</strong></dt><dd><p>The row and column from the Dicke space matrix.</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>——-</strong></dt><dd></dd>
<dt><strong>k: int</strong></dt><dd><p>The row index for the matrix M for given Dicke space
element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.coefficient_matrix">
<span class="sig-name descname"><span class="pre">coefficient_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.coefficient_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.coefficient_matrix" title="Permalink to this definition"></a></dt>
<dd><p>Generate the matrix M governing the dynamics for diagonal cases.</p>
<p>If the initial density matrix and the Hamiltonian is diagonal, the
evolution of the system is given by the simple ODE: dp/dt = Mp.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.isdicke">
<span class="sig-name descname"><span class="pre">isdicke</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dicke_row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dicke_col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.isdicke"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.isdicke" title="Permalink to this definition"></a></dt>
<dd><p>Check if an element in a matrix is a valid element in the Dicke space.
Dicke row: j value index. Dicke column: m value index.
The function returns True if the element exists in the Dicke space and
False otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dicke_row, dicke_col</strong><span class="classifier">int</span></dt><dd><p>Index of the element in Dicke space which needs to be checked</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tlist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.solve"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.solve" title="Permalink to this definition"></a></dt>
<dd><p>Solve the ODE for the evolution of diagonal states and Hamiltonians.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.tau1">
<span class="sig-name descname"><span class="pre">tau1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.tau1"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.tau1" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coefficient matrix element relative to (j, m, m).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.tau2">
<span class="sig-name descname"><span class="pre">tau2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.tau2"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.tau2" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coefficient matrix element relative to (j, m+1, m+1).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.tau3">
<span class="sig-name descname"><span class="pre">tau3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.tau3"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.tau3" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coefficient matrix element relative to (j+1, m+1, m+1).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.tau4">
<span class="sig-name descname"><span class="pre">tau4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.tau4"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.tau4" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coefficient matrix element relative to (j-1, m+1, m+1).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.tau5">
<span class="sig-name descname"><span class="pre">tau5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.tau5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.tau5" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coefficient matrix element relative to (j+1, m, m).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.tau6">
<span class="sig-name descname"><span class="pre">tau6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.tau6"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.tau6" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coefficient matrix element relative to (j-1, m, m).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.tau7">
<span class="sig-name descname"><span class="pre">tau7</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.tau7"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.tau7" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coefficient matrix element relative to (j+1, m-1, m-1).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.tau8">
<span class="sig-name descname"><span class="pre">tau8</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.tau8"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.tau8" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coefficient matrix element relative to (j, m-1, m-1).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.tau9">
<span class="sig-name descname"><span class="pre">tau9</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.tau9"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.tau9" title="Permalink to this definition"></a></dt>
<dd><p>Calculate coefficient matrix element relative to (j-1, m-1, m-1).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.piqs.piqs.Pim.tau_valid">
<span class="sig-name descname"><span class="pre">tau_valid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dicke_row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dicke_col</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/piqs/piqs.html#Pim.tau_valid"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.piqs.piqs.Pim.tau_valid" title="Permalink to this definition"></a></dt>
<dd><p>Find the Tau functions which are valid for this value of (dicke_row,
dicke_col) given the number of TLS. This calculates the valid tau
values and reurns a dictionary specifying the tau function name and
the value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dicke_row, dicke_col</strong><span class="classifier">int</span></dt><dd><p>Index of the element in Dicke space which needs to be checked.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt>taus: dict</dt><dd><p>A dictionary of key, val as {tau: value} consisting of the valid
taus for this row and column of the Dicke space element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="distribution-functions">
<span id="classes-distributions"></span><h2>Distribution functions<a class="headerlink" href="#distribution-functions" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="qutip.distributions.Distribution">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xvecs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#Distribution"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.Distribution" title="Permalink to this definition"></a></dt>
<dd><p>A class for representation spatial distribution functions.</p>
<p>The Distribution class can be used to prepresent spatial distribution
functions of arbitray dimension (although only 1D and 2D distributions
are used so far).</p>
<p>It is indented as a base class for specific distribution function, and
provide implementation of basic functions that are shared among all
Distribution functions, such as visualization, calculating marginal
distributions, etc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array_like</span></dt><dd><p>Data for the distribution. The dimensions must match the lengths of
the coordinate arrays in xvecs.</p>
</dd>
<dt><strong>xvecs</strong><span class="classifier">list</span></dt><dd><p>List of arrays that spans the space for each coordinate.</p>
</dd>
<dt><strong>xlabels</strong><span class="classifier">list</span></dt><dd><p>List of labels for each coordinate.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qutip.distributions.Distribution.marginal">
<span class="sig-name descname"><span class="pre">marginal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#Distribution.marginal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.Distribution.marginal" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the marginal distribution function along the dimension
<cite>dim</cite>. Return a new Distribution instance describing this reduced-
dimensionality distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>The dimension (coordinate index) along which to obtain the
marginal distribution.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>d</strong><span class="classifier">Distributions</span></dt><dd><p>A new instances of Distribution that describes the marginal
distribution.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.distributions.Distribution.project">
<span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#Distribution.project"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.Distribution.project" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the projection (max value) distribution function along the
dimension <cite>dim</cite>. Return a new Distribution instance describing this
reduced-dimensionality distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dim</strong><span class="classifier">int</span></dt><dd><p>The dimension (coordinate index) along which to obtain the
projected distribution.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><dl class="simple">
<dt><strong>d</strong><span class="classifier">Distributions</span></dt><dd><p>A new instances of Distribution that describes the projection.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qutip.distributions.Distribution.visualize">
<span class="sig-name descname"><span class="pre">visualize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fig</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">6)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorbar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'colormap'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_xlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_ylabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../modules/qutip/distributions.html#Distribution.visualize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qutip.distributions.Distribution.visualize" title="Permalink to this definition"></a></dt>
<dd><p>Visualize the data of the distribution in 1D or 2D, depending
on the dimensionality of the underlaying distribution.</p>
<p>Parameters:</p>
<dl class="simple">
<dt>fig<span class="classifier">matplotlib Figure instance</span></dt><dd><p>If given, use this figure instance for the visualization,</p>
</dd>
<dt>ax<span class="classifier">matplotlib Axes instance</span></dt><dd><p>If given, render the visualization using this axis instance.</p>
</dd>
<dt>figsize<span class="classifier">tuple</span></dt><dd><p>Size of the new Figure instance, if one needs to be created.</p>
</dd>
<dt>colorbar: Bool</dt><dd><p>Whether or not the colorbar (in 2D visualization) should be used.</p>
</dd>
<dt>cmap: matplotlib colormap instance</dt><dd><p>If given, use this colormap for 2D visualizations.</p>
</dd>
<dt>style<span class="classifier">string</span></dt><dd><p>Type of visualization: ‘colormap’ (default) or ‘surface’.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>A tuple of matplotlib figure and axes instances.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="apidoc.html" class="btn btn-neutral float-left" title="API documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="functions.html" class="btn btn-neutral float-right" title="Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="../copyright.html">Copyright</a> 2011 to 2021 inclusive, QuTiP developers and contributors.
      <span class="lastupdated">Last updated on Mar 05, 2024.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>