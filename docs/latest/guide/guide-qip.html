


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Quantum Information Processing &mdash; QuTiP 4.5 Documentation</title>
  

  
  
    <link rel="shortcut icon" href="../static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../static/documentation_options.js"></script>
        <script type="text/javascript" src="../static/jquery.js"></script>
        <script type="text/javascript" src="../static/underscore.js"></script>
        <script type="text/javascript" src="../static/doctools.js"></script>
        <script type="text/javascript" src="../static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../static/gallery.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Gallery" href="../gallery/qutip_examples/index.html" />
    <link rel="prev" title="Modifying Internal QuTiP Settings" href="guide-settings.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> QuTiP: Quantum Toolbox in Python
          

          
          </a>

          
            
            
              <div class="version">
                4.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="guide.html">Users Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="guide-overview.html">Guide Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-basics.html">Basic Operations on Quantum Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-states.html">Manipulating States and Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-tensor.html">Using Tensor Products and Partial Traces</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-dynamics.html">Time Evolution and Quantum System Dynamics</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-steady.html">Solving for Steady-State Solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-eseries.html">An Overview of the Eseries Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-correlation.html">Two-time correlation functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-control.html">Quantum Optimal Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-bloch.html">Plotting on the Bloch Sphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-visualization.html">Visualization of quantum states and processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-parfor.html">Parallel computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-saving.html">Saving QuTiP Objects and Data Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-random.html">Generating Random Quantum States &amp; Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="guide-settings.html">Modifying Internal QuTiP Settings</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Quantum Information Processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quantum-circuit">Quantum Circuit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#processor-for-qip-simulation">Processor for QIP simulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#spinchain">SpinChain</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dispersivecqed">DispersivecQED</a></li>
<li class="toctree-l4"><a class="reference internal" href="#optpulseprocessor">OptPulseProcessor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#noise-simulation">Noise Simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#workflow-of-the-processor">Workflow of the Processor</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../gallery/qutip_examples/index.html">Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuTiP: Quantum Toolbox in Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="guide.html">Users Guide</a> &raquo;</li>
        
      <li>Quantum Information Processing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="quantum-information-processing">
<span id="qip"></span><h1>Quantum Information Processing<a class="headerlink" href="#quantum-information-processing" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with <a class="reference internal" href="../apidoc/classes.html#qutip.qip.QubitCircuit" title="qutip.qip.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.QubitCircuit</span></code></a> calculating unitary evolution under quantum gates by matrix product, another called <a class="reference internal" href="../apidoc/classes.html#qutip.qip.device.Processor" title="qutip.qip.device.Processor"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.device.Processor</span></code></a> using open system solver in QuTiP to simulate noisy quantum device.</p>
</div>
<div class="section" id="quantum-circuit">
<h2>Quantum Circuit<a class="headerlink" href="#quantum-circuit" title="Permalink to this headline">¶</a></h2>
<p>The most common model for quantum computing is the quantum circuit model. In QuTiP, we use <a class="reference internal" href="../apidoc/classes.html#qutip.qip.QubitCircuit" title="qutip.qip.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.QubitCircuit</span></code></a> to represent a quantum circuit. Each quantum gate is saved as a class object <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.operations.Gate</span></code> with information such as gate name, target qubits and arguments. To get the matrix representation of each gate, we can call the class method <code class="xref py py-meth docutils literal notranslate"><span class="pre">qutip.qip.QubitCircuit.propagators</span></code>. Carrying out the matrices product, one gets the matrix representation of the whole evolution. This process is demonstrated in the following example.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">qutip.qip.circuit</span> <span class="kn">import</span> <span class="n">QubitCircuit</span><span class="p">,</span> <span class="n">Gate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">qutip.qip.operations</span> <span class="kn">import</span> <span class="n">gate_sequence_product</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">swap_gate</span> <span class="o">=</span> <span class="n">Gate</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;SWAP&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">swap_gate</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;CNOT&quot;</span><span class="p">,</span> <span class="n">controls</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">swap_gate</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">gates</span><span class="p">)</span>
<span class="go">[Gate(SWAP, targets=[0, 1], controls=None), Gate(CNOT, targets=[1],</span>
<span class="go">controls=[0]), Gate(SWAP, targets=[0, 1], controls=None)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">U_list</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">propagators</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gate_sequence_product</span><span class="p">(</span><span class="n">U_list</span><span class="p">))</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[1. 0. 0. 0.]</span>
<span class="go">[0. 0. 0. 1.]</span>
<span class="go">[0. 0. 1. 0.]</span>
<span class="go">[0. 1. 0. 0.]]</span>
</pre></div>
</div>
<p>The pre-defined gates for the class <a class="reference internal" href="../apidoc/classes.html#qutip.qip.Gate" title="qutip.qip.Gate"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.Gate</span></code></a> are shown in the table below:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 28%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Gate name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>“RX”</p></td>
<td><p>Rotation around x axis</p></td>
</tr>
<tr class="row-odd"><td><p>“RY”</p></td>
<td><p>Rotation around y axis</p></td>
</tr>
<tr class="row-even"><td><p>“RZ”</p></td>
<td><p>Rotation around z axis</p></td>
</tr>
<tr class="row-odd"><td><p>“SQRTNOT”</p></td>
<td><p>Square root of NOT gate</p></td>
</tr>
<tr class="row-even"><td><p>“SNOT”</p></td>
<td><p>Hardmard gate</p></td>
</tr>
<tr class="row-odd"><td><p>“PHASEGATE”</p></td>
<td><p>Add a phase one the state 1</p></td>
</tr>
<tr class="row-even"><td><p>“CRX”</p></td>
<td><p>Controlled rotation around x axis</p></td>
</tr>
<tr class="row-odd"><td><p>“CRY”</p></td>
<td><p>Controlled rotation around y axis</p></td>
</tr>
<tr class="row-even"><td><p>“CRZ”</p></td>
<td><p>Controlled rotation around z axis</p></td>
</tr>
<tr class="row-odd"><td><p>“CPHASE”</p></td>
<td><p>Controlled phase gate</p></td>
</tr>
<tr class="row-even"><td><p>“CNOT”</p></td>
<td><p>Controlled NOT gate</p></td>
</tr>
<tr class="row-odd"><td><p>“CSIGN”</p></td>
<td><p>Same as CPHASE</p></td>
</tr>
<tr class="row-even"><td><p>“BERKELEY”</p></td>
<td><p>Berkeley gate</p></td>
</tr>
<tr class="row-odd"><td><p>“SWAPalpha”</p></td>
<td><p>SWAPalpha gate</p></td>
</tr>
<tr class="row-even"><td><p>“SWAP”</p></td>
<td><p>Swap the states of two qubits</p></td>
</tr>
<tr class="row-odd"><td><p>“ISWAP”</p></td>
<td><p>Swap gate with additional phase for 01 and 10 states</p></td>
</tr>
<tr class="row-even"><td><p>“SQRTSWAP”</p></td>
<td><p>Square root of the SWAP gate</p></td>
</tr>
<tr class="row-odd"><td><p>“SQRTISWAP”</p></td>
<td><p>Square root of the ISWAP gate</p></td>
</tr>
<tr class="row-even"><td><p>“FREDKIN”</p></td>
<td><p>Fredkin gate</p></td>
</tr>
<tr class="row-odd"><td><p>“TOFFOLI”</p></td>
<td><p>Toffoli gate</p></td>
</tr>
<tr class="row-even"><td><p>“GLOBALPHASE”</p></td>
<td><p>Global phase</p></td>
</tr>
</tbody>
</table>
<p>For some of the gates listed above, <a class="reference internal" href="../apidoc/classes.html#qutip.qip.QubitCircuit" title="qutip.qip.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.QubitCircuit</span></code></a> also has a primitive <code class="xref py py-meth docutils literal notranslate"><span class="pre">qutip.qip.QubitCircuit.resolve_gates</span></code> method that decomposes them into elementary gate sets such as CNOT or SWAP with single-qubit gates. However, this method is not fully optimized. It is very likely that the depth of the circuit can be further reduced by merging quantum gates. Apart from it, there is also a function drawing the circuit with LaTeX code using the <code class="docutils literal notranslate"><span class="pre">Q-qircuit</span></code> package from <a class="reference external" href="http://physics.unm.edu/CQuIC/Qcircuit">http://physics.unm.edu/CQuIC/Qcircuit</a>.</p>
<p>In addition to these pre-defined gates, QuTiP also allows the user to define their own gate. The following example shows how to define a customized gate.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Available from QuTiP 4.4</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">qutip.qip.circuit</span> <span class="kn">import</span> <span class="n">Gate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">qutip.qip.operations</span> <span class="kn">import</span> <span class="n">rx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">qutip</span> <span class="kn">import</span> <span class="n">Qobj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">user_gate1</span><span class="p">(</span><span class="n">arg_value</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># controlled rotation X</span>
<span class="gp">... </span>    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="gp">... </span>    <span class="n">mat</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">rx</span><span class="p">(</span><span class="n">arg_value</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">user_gate2</span><span class="p">():</span>
<span class="gp">... </span>    <span class="c1"># S gate</span>
<span class="gp">... </span>    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span>   <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="n">j</span><span class="p">]])</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">Qobj</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span> <span class="o">=</span> <span class="n">QubitCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">user_gates</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;CTRLRX&quot;</span><span class="p">:</span> <span class="n">user_gate1</span><span class="p">,</span>
<span class="gp">... </span>                 <span class="s2">&quot;S&quot;</span>     <span class="p">:</span> <span class="n">user_gate2</span><span class="p">}</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># qubit 0 controlls qubit 1</span>
<span class="gp">... </span><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;CTRLRX&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">arg_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># qubit 1 controlls qubit 0</span>
<span class="gp">... </span><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;CTRLRX&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">arg_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># we also add a gate using a predefined Gate object</span>
<span class="gp">... </span><span class="n">g_T</span> <span class="o">=</span> <span class="n">Gate</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">g_T</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">propagators</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[1.    +0.j     0.    +0.j     0.    +0.j     0.    +0.j    ]</span>
<span class="go">[0.    +0.j     1.    +0.j     0.    +0.j     0.    +0.j    ]</span>
<span class="go">[0.    +0.j     0.    +0.j     0.7071+0.j     0.    -0.7071j]</span>
<span class="go">[0.    +0.j     0.    +0.j     0.    -0.7071j 0.7071+0.j    ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[1.    +0.j     0.    +0.j     0.    +0.j     0.    +0.j    ]</span>
<span class="go">[0.    +0.j     0.7071+0.j     0.    +0.j     0.    -0.7071j]</span>
<span class="go">[0.    +0.j     0.    +0.j     1.    +0.j     0.    +0.j    ]</span>
<span class="go">[0.    +0.j     0.    -0.7071j 0.    +0.j     0.7071+0.j    ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[1.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go">[0.+0.j 0.+1.j 0.+0.j 0.+0.j]</span>
<span class="go">[0.+0.j 0.+0.j 1.+0.j 0.+0.j]</span>
<span class="go">[0.+0.j 0.+0.j 0.+0.j 0.+1.j]]</span>
</pre></div>
</div>
</div>
<div class="section" id="processor-for-qip-simulation">
<h2>Processor for QIP simulation<a class="headerlink" href="#processor-for-qip-simulation" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Available from QuTiP 4.5</p>
</div>
<p>In addition to direct matrix product, QuTiP also offers another approach to QIP simulation. Based on the open system solver, <a class="reference internal" href="../apidoc/classes.html#qutip.qip.device.Processor" title="qutip.qip.device.Processor"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.device.Processor</span></code></a> in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">qutip.qip</span></code> module simulates quantum circuits at the level of driving Hamiltonians. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution can be calculated using the solver. A control pulse is characterized by <a class="reference internal" href="../apidoc/classes.html#qutip.qip.pulse.Pulse" title="qutip.qip.pulse.Pulse"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.pulse.Pulse</span></code></a>, consisting of the control Hamiltonian, the targets qubit, the pulse coefficients and the time sequence. We can either use the coefficients as a step function or with cubic spline. For step function, <code class="docutils literal notranslate"><span class="pre">tlist</span></code> specifies the start and the end of each pulse and thus is one element longer the <code class="docutils literal notranslate"><span class="pre">coeffs</span></code>. One example of defining the control pulse coefficients and the time array is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">qutip.qip.device</span> <span class="kn">import</span> <span class="n">Processor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span> <span class="o">=</span> <span class="n">Processor</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span><span class="o">.</span><span class="n">add_control</span><span class="p">(</span><span class="n">sigmaz</span><span class="p">(),</span> <span class="n">cyclic_permutation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># sigmaz for all qubits</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span><span class="o">.</span><span class="n">pulses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.8</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span><span class="o">.</span><span class="n">pulses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the coefficients represent a step function, the length of each array is 1 element shorter than <code class="docutils literal notranslate"><span class="pre">tlist</span></code>. If it is supposed to be a continuous function, the length should be the same as <code class="docutils literal notranslate"><span class="pre">tlist</span></code>.</p>
</div>
<p>The above example shows the framework and the most essential part of the simulator’s API. For now, it looks like just a wrap for the open system solver. However, based on this, we can implement different physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:</p>
<div class="line-block">
<div class="line">Processor</div>
<div class="line">├── ModelProcessor</div>
<div class="line">│   ├── DispersivecQED</div>
<div class="line">│   └── SpinChain</div>
<div class="line">└── OptPulseProcessor</div>
</div>
<p>In general, there are two ways to find the control pulses. The first one, <a class="reference internal" href="../apidoc/classes.html#qutip.qip.device.ModelProcessor" title="qutip.qip.device.ModelProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.device.ModelProcessor</span></code></a>, is more experiment-oriented and based on physical models. A universal set of
gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the CQED model for quantum computing. In those models, the driving Hamiltonians are predefined. The other approach, based on the optimal control module in QuTiP (see <a class="reference internal" href="guide-control.html#control"><span class="std std-ref">Quantum Optimal Control</span></a>), is called <a class="reference internal" href="../apidoc/classes.html#qutip.qip.device.OptPulseProcessor" title="qutip.qip.device.OptPulseProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.device.OptPulseProcessor</span></code></a>. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.</p>
<p>Despite this difference, the logic behind all processors is the same:</p>
<ul class="simple">
<li><p>One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In the model bases processor, the Hamiltonians are predefined and one only need to give the device parameters like frequency and interaction strength.</p></li>
<li><p>The control pulse coefficients and time slices are either specified by the user or calculated by the method <a class="reference internal" href="../apidoc/classes.html#qutip.qip.device.Processor.load_circuit" title="qutip.qip.device.Processor.load_circuit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">qutip.qip.device.Processor.load_circuit</span></code></a>, which takes a <a class="reference internal" href="../apidoc/classes.html#qutip.qip.QubitCircuit" title="qutip.qip.QubitCircuit"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.QubitCircuit</span></code></a> and find the control pulse for this evolution.</p></li>
<li><p>The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method <a class="reference internal" href="../apidoc/classes.html#qutip.qip.device.Processor.run_state" title="qutip.qip.device.Processor.run_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">qutip.qip.device.Processor.run_state</span></code></a> returns a object <a class="reference internal" href="../apidoc/classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p></li>
</ul>
<p>It is also possible to calculate the evolution analytically with matrix exponentiation by setting <code class="docutils literal notranslate"><span class="pre">analytical=True</span></code>. A list of the matrices representing the gates is returned just like for <code class="xref py py-meth docutils literal notranslate"><span class="pre">qutip.qip.QubitCircuit.propagators</span></code>. However, this does not consider the collapse operators or the noise. As the system size gets larger, this approach will become very inefficient.</p>
<div class="section" id="spinchain">
<h3>SpinChain<a class="headerlink" href="#spinchain" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="../apidoc/classes.html#qutip.qip.device.LinearSpinChain" title="qutip.qip.device.LinearSpinChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.device.LinearSpinChain</span></code></a> and <a class="reference internal" href="../apidoc/classes.html#qutip.qip.device.CircularSpinChain" title="qutip.qip.device.CircularSpinChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.device.CircularSpinChain</span></code></a> are quantum computing models base on the spin chain realization. The control Hamiltonians are <span class="math notranslate nohighlight">\(\sigma_x\)</span>, <span class="math notranslate nohighlight">\(\sigma_z\)</span> and <span class="math notranslate nohighlight">\(\sigma_x \sigma_x + \sigma_y \sigma_y\)</span>. This processor will first decompose the gate into the universal gate set with ISWAP and SQRTISWAP as two-qubit gates, resolve them into quantum gates of adjacent qubits and then calculate the pulse coefficients.</p>
</div>
<div class="section" id="dispersivecqed">
<h3>DispersivecQED<a class="headerlink" href="#dispersivecqed" title="Permalink to this headline">¶</a></h3>
<p>Same as above, <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.device.DispersivecQED</span></code> is a simulator based on Cavity Quantum Electrodynamics. The workflow is similar to the one for the spin chain, except that the component systems are a multi-level cavity and a qubits system. The control Hamiltonians are the single-qubit rotation together with the qubits-cavity interaction <span class="math notranslate nohighlight">\(a^{\dagger} \sigma^{-} + a \sigma^{+}\)</span>. The device parameters including the cavity frequency, qubits frequency, detuning and interaction strength etc.</p>
</div>
<div class="section" id="optpulseprocessor">
<h3>OptPulseProcessor<a class="headerlink" href="#optpulseprocessor" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../apidoc/classes.html#qutip.qip.device.OptPulseProcessor" title="qutip.qip.device.OptPulseProcessor"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.device.OptPulseProcessor</span></code></a> uses the function in <a class="reference internal" href="../apidoc/functions.html#qutip.control.pulseoptim.optimize_pulse_unitary" title="qutip.control.pulseoptim.optimize_pulse_unitary"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.control.pulseoptim.optimize_pulse_unitary</span></code></a> in the optimal control module to find the control pulses. The Hamiltonian includes a drift part and a control part and only the control part will be optimized. The unitary evolution follows</p>
<div class="math notranslate nohighlight">
\[U(\Delta t)=\exp(\rm{i} \cdot \Delta t [H_d  + \sum_j u_j H_j] )\]</div>
<p>To let it find the optimal pulses, we need to give the parameters for <a class="reference internal" href="../apidoc/functions.html#qutip.control.pulseoptim.optimize_pulse_unitary" title="qutip.control.pulseoptim.optimize_pulse_unitary"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.control.pulseoptim.optimize_pulse_unitary</span></code></a> as keyword arguments to <a class="reference internal" href="../apidoc/classes.html#qutip.qip.device.OptPulseProcessor.load_circuit" title="qutip.qip.device.OptPulseProcessor.load_circuit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">qutip.qip.device.OptPulseProcessor.load_circuit</span></code></a>. Usually the minimal requirements are the evolution time <code class="docutils literal notranslate"><span class="pre">evo_time</span></code> and the number of time slices <code class="docutils literal notranslate"><span class="pre">num_tslots</span></code> for each gate. Other parameters can also be given in the keyword arguments. For available choices, see <a class="reference internal" href="../apidoc/functions.html#qutip.control.pulseoptim.optimize_pulse_unitary" title="qutip.control.pulseoptim.optimize_pulse_unitary"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.control.pulseoptim.optimize_pulse_unitary</span></code></a>. It is also possible to specify different parameters for different gates, as shown in the following example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">qutip.qip.device</span> <span class="kn">import</span> <span class="n">OptPulseProcessor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">qutip.operators</span> <span class="kn">import</span> <span class="n">sigmaz</span><span class="p">,</span> <span class="n">sigmax</span><span class="p">,</span> <span class="n">sigmay</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">qutip.tensor</span> <span class="kn">import</span> <span class="n">tensor</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Same parameter for all the gates</span>
<span class="gp">... </span><span class="n">qc</span> <span class="o">=</span> <span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;SNOT&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_tslots</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evo_time</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">processor</span> <span class="o">=</span> <span class="n">OptPulseProcessor</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">drift</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">processor</span><span class="o">.</span><span class="n">add_control</span><span class="p">(</span><span class="n">sigmax</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># num_tslots and evo_time are two keyword arguments</span>
<span class="gp">... </span><span class="n">tlist</span><span class="p">,</span> <span class="n">coeffs</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">load_circuit</span><span class="p">(</span>
<span class="gp">... </span><span class="n">qc</span><span class="p">,</span> <span class="n">num_tslots</span><span class="o">=</span><span class="n">num_tslots</span><span class="p">,</span> <span class="n">evo_time</span><span class="o">=</span><span class="n">evo_time</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Different parameters for different gates</span>
<span class="gp">... </span><span class="n">qc</span> <span class="o">=</span> <span class="n">QubitCircuit</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;SNOT&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s2">&quot;SWAP&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">qc</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="s1">&#39;CNOT&#39;</span><span class="p">,</span> <span class="n">controls</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">processor</span> <span class="o">=</span> <span class="n">OptPulseProcessor</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">drift</span><span class="o">=</span><span class="n">tensor</span><span class="p">([</span><span class="n">sigmaz</span><span class="p">()]</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">processor</span><span class="o">.</span><span class="n">add_control</span><span class="p">(</span><span class="n">sigmax</span><span class="p">(),</span> <span class="n">cyclic_permutation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">processor</span><span class="o">.</span><span class="n">add_control</span><span class="p">(</span><span class="n">sigmay</span><span class="p">(),</span> <span class="n">cyclic_permutation</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">processor</span><span class="o">.</span><span class="n">add_control</span><span class="p">(</span><span class="n">tensor</span><span class="p">([</span><span class="n">sigmay</span><span class="p">(),</span> <span class="n">sigmay</span><span class="p">()]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">setting_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;SNOT&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;num_tslots&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;evo_time&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
<span class="gp">... </span>                <span class="s2">&quot;SWAP&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;num_tslots&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;evo_time&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
<span class="gp">... </span>                <span class="s2">&quot;CNOT&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;num_tslots&quot;</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s2">&quot;evo_time&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tlist</span><span class="p">,</span> <span class="n">coeffs</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">load_circuit</span><span class="p">(</span>
<span class="gp">... </span><span class="n">qc</span><span class="p">,</span> <span class="n">setting_args</span><span class="o">=</span><span class="n">setting_args</span><span class="p">,</span> <span class="n">merge_gates</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="noise-simulation">
<h2>Noise Simulation<a class="headerlink" href="#noise-simulation" title="Permalink to this headline">¶</a></h2>
<p>In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors. The typical approaches are either applying bit/sign flipping gate probabilistically or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.</p>
<p>Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous time evolution. Instead, the error is added to the driving Hamiltonian list (coherent control error) or the collapse operators (decoherent error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how <a class="reference internal" href="../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mcsolve</span></code></a> works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.</p>
<p>Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation, there is no need to go through all the calculations. However, this simulator is closer to the real experiment and, therefore, more convenient in some cases, such as when coherent noise or correlated noise exist. For instance, a pulse on one qubit might affect the neighbouring qubits, the evolution is still unitary but the gate fidelity will decrease. It is not always easy or even possible to define a noisy gate matrix. In our simulator, it can be done by defining a <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.device.ControlAmpNoise</span></code> (Control Amplitude Noise). Here we show two examples (the source code can be found in the gallery):</p>
<p>The first example is a processor with one qubit under rotation around the z-axis and relaxation time <span class="math notranslate nohighlight">\(T_2=5\)</span>. We measure the population of the <span class="math notranslate nohighlight">\(\left| + \right\rangle\)</span> state and observe the Ramsey signal:</p>
<img alt="../images/sphx_glr_plot_qip_relaxation_001.png" src="../images/sphx_glr_plot_qip_relaxation_001.png" />
<p>The second example demonstrates a biased Gaussian noise on the pulse amplitude. For visualization purposes, we plot the noisy pulse intensity instead of the state fidelity. The three pulses can, for example, be a zyz-decomposition of an arbitrary single-qubit gate:</p>
<img alt="../images/sphx_glr_plot_qip_amplitude_noise_001.png" src="../images/sphx_glr_plot_qip_amplitude_noise_001.png" />
<img alt="../images/sphx_glr_plot_qip_amplitude_noise_002.png" src="../images/sphx_glr_plot_qip_amplitude_noise_002.png" />
<p>As the design of our simulator follows the physical realization, so is the noise simulation. Noise can be added to the processor at different levels:</p>
<ul class="simple">
<li><p>The decoherence time T1 and T2 can be defined for the processor or for each qubit. When calculating the evolution, the corresponding collapse operators will be added automatically to the solver.</p></li>
<li><p>The noise of the physical parameters (e.g. detuned frequency) can be simulated by changing the parameters in the model, e.g. laser frequency in cavity QED. (This can only be time-independent since QuTiP open system solver only allows varying coefficients, not varying Hamiltonian operators.)</p></li>
<li><p>The noise of the pulse intensity can be simulated by modifying the coefficients of the Hamiltonian operators or even adding new Hamiltonians.</p></li>
</ul>
<p>To add noise to a processor, one needs to first define a noise object <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.noise.Noise</span></code>. The simplest relaxation noise can be defined directly in the processor with relaxation time. Other pre-defined noise can be found as subclasses of  <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qip.noise.Noise</span></code>. We add noise to the simulator with the method <a class="reference internal" href="../apidoc/classes.html#qutip.qip.device.Processor.add_noise" title="qutip.qip.device.Processor.add_noise"><code class="xref py py-meth docutils literal notranslate"><span class="pre">qutip.qip.device.Processor.add_noise</span></code></a>.</p>
</div>
<div class="section" id="workflow-of-the-processor">
<h2>Workflow of the Processor<a class="headerlink" href="#workflow-of-the-processor" title="Permalink to this headline">¶</a></h2>
<p>This section helps you understand the workflow inside the simulator.</p>
<img alt="../images/processor-workflow.png" src="../images/processor-workflow.png" />
<p>The figure above shows how the noise is processed in <code class="docutils literal notranslate"><span class="pre">processor</span></code>. The noise is defined separately in a class object. When called, it takes parameters and the unitary noiseless <a class="reference internal" href="../apidoc/classes.html#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> from the processor, generates the noisy version and sends the noisy <a class="reference internal" href="../apidoc/classes.html#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> together with the collapse operators to the processor.</p>
<p>When calculating the evolution, the processor first creates its own <a class="reference internal" href="../apidoc/classes.html#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> of the noiseless evolution.
It will then find all the noise objects saved in the attributes <code class="xref py py-attr docutils literal notranslate"><span class="pre">qutip.qip.device.Processor.noise</span></code> and call the corresponding methods to get the <a class="reference internal" href="../apidoc/classes.html#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> and a list of collapse operators representing the noise. (For collapse operators, we don’t want to add all the constant collapse into one time-independent operator, so we use a list).
The processor then combines its own <a class="reference internal" href="../apidoc/classes.html#qutip.QobjEvo" title="qutip.QobjEvo"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code></a> with those from the noise object and give them to the solver. The figure below shows how the noiseless part and the noisy part are combined.</p>
<img alt="../images/processor-noise.png" src="../images/processor-noise.png" />
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../gallery/qutip_examples/index.html" class="btn btn-neutral float-right" title="Gallery" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="guide-settings.html" class="btn btn-neutral float-left" title="Modifying Internal QuTiP Settings" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere
      <span class="lastupdated">
        Last updated on Feb 01, 2020.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>